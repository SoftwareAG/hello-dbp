VERS 00000001 5
HEAD 00001411 <?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/resources/transform.xslt"?><header><componentName>correlator</componentName><version>10.1.0.4.324292</version><build>rel/10.1.0.x@324292</build><buildPlatform>amd64-win</buildPlatform><platform>Windows 7 Professional (Service Pack 1)</platform><cputype>GenuineIntel family 6 model 14 stepping 3 Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz</cputype><cpus>4</cpus><javaEnabled>true</javaEnabled><replayLogMode>inputLog</replayLogMode><args><arg>C:\SoftwareAG101\Apama\bin\correlator.exe</arg><arg>--port</arg><arg>15903</arg><arg>--config</arg><arg>C:\SoftwareAG101\Apama\connectivity\bundles\standard-codecs.yaml</arg><arg>--config</arg><arg>C:\Users\jagt\workspace101\HelloApama\config\connectivity\DigitalEventServices</arg><arg>--loglevel</arg><arg>INFO</arg><arg>--name</arg><arg>Apama Designer Correlator for HelloApama(HelloApama:defaultCorrelator)</arg><arg>-j</arg><arg>--inputLog</arg><arg>logs/defaultCorrelator_${START_TIME}_${ID}.input.log</arg></args><environment><variable>ALLUSERSPROFILE=C:\ProgramData</variable><variable>APAMA_HOME=C:\SoftwareAG101\Apama</variable><variable>APAMA_WORK=C:\Users\Public\SoftwareAG\ApamaWork_10.1</variable><variable>APPDATA=C:\Users\jagt\AppData\Roaming</variable><variable>COMMONPROGRAMFILES=C:\Program Files\Common Files</variable><variable>COMMONPROGRAMFILES(X86)=C:\Program Files (x86)\Common Files</variable><variable>COMMONPROGRAMW6432=C:\Program Files\Common Files</variable><variable>COMPUTERNAME=MC2029402218</variable><variable>COMSPEC=C:\Windows\system32\cmd.exe</variable><variable>DEFLOGDIR=C:\ProgramData\McAfee\DesktopProtection</variable><variable>DISPLAYLINKCONFIGROOT=C:\Program Files\DisplayLink Core Software\8.2.1956.0\</variable><variable>EMPIRUMSERVER=PKGDEPOT.emp.softwareag.com</variable><variable>EMPIRUMSERVICEPARTITION=0</variable><variable>FP_NO_HOST_CHECK=NO</variable><variable>HOMEDRIVE=C:</variable><variable>HOMEPATH=\Users\jagt</variable><variable>JAVA_HOME=C:\SoftwareAG101\jvm\jvm</variable><variable>LOCALAPPDATA=C:\Users\jagt\AppData\Local</variable><variable>LOGONSERVER=\\ASHDC04</variable><variable>NUMBER_OF_PROCESSORS=4</variable><variable>OS=Windows_NT</variable><variable>PATH=C:\SoftwareAG101\Apama\..\jvm\jvm\jre\bin\server;C:\SoftwareAG101\Apama\..\jvm\jvm\jre\bin;C:\SoftwareAG101\Apama\..\UniversalMessaging\cplus\lib\x86_64;C:\SoftwareAG101\Apama\..\jvm\jvm\jre\bin\server;C:\SoftwareAG101\Apama\..\jvm\jvm\jre\bin;C:\Users\Public\SoftwareAG\ApamaWork_10.1\lib;C:\SoftwareAG101\Apama\bin;C:\SoftwareAG101\Apama\bin;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\iCLS\;C:\Program Files\Intel\Intel(R) Management Engine Components\iCLS\;C:\ProgramData\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\SysWOW64\Empirum;C:\Program Files (x86)\Intel\UCRT\;C:\Program Files\Intel\UCRT\;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\WiFi\bin\;C:\Program Files\Common Files\Intel\WirelessCommon\;C:\Program Files\Microsoft SQL Server\110\DTS\Binn\;C:\Program Files (x86)\Microsoft SQL Server\110\Tools\Binn\;C:\Program Files\Microsoft SQL Server\110\Tools\Binn\;C:\Program Files (x86)\Microsoft SQL Server\110\Tools\Binn\ManagementStudio\;C:\Program Files (x86)\Microsoft SQL Server\110\DTS\Binn\;C:\SoftwareAG101\jvm\jvm\bin\server</variable><variable>PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</variable><variable>PROCESSOR_ARCHITECTURE=AMD64</variable><variable>PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 78 Stepping 3, GenuineIntel</variable><variable>PROCESSOR_LEVEL=6</variable><variable>PROCESSOR_REVISION=4e03</variable><variable>PROGRAMDATA=C:\ProgramData</variable><variable>PROGRAMFILES=C:\Program Files</variable><variable>PROGRAMFILES(X86)=C:\Program Files (x86)</variable><variable>PROGRAMW6432=C:\Program Files</variable><variable>PROMPT=$P$G</variable><variable>PSMODULEPATH=C:\Windows\system32\WindowsPowerShell\v1.0\Modules\;C:\Program Files (x86)\Microsoft SQL Server\110\Tools\PowerShell\Modules\</variable><variable>PUBLIC=C:\Users\Public</variable><variable>SESSIONNAME=Console</variable><variable>SYSTEMDRIVE=C:</variable><variable>SYSTEMROOT=C:\Windows</variable><variable>TEMP=C:\Users\jagt\AppData\Local\Temp</variable><variable>TMP=C:\Users\jagt\AppData\Local\Temp</variable><variable>USERDNSDOMAIN=EUR.AD.SAG</variable><variable>USERDOMAIN=EUR</variable><variable>USERDOMAIN_ROAMINGPROFILE=EUR</variable><variable>USERNAME=jagt</variable><variable>USERPROFILE=C:\Users\jagt</variable><variable>VSEDEFLOGDIR=C:\ProgramData\McAfee\DesktopProtection</variable><variable>WINDIR=C:\Windows</variable><variable>WINDOWS_TRACING_FLAGS=3</variable><variable>WINDOWS_TRACING_LOGFILE=C:\BVTBin\Tests\installpackage\csilogfile.log</variable></environment><version>10.1.0.4.324292</version></header>
PROP 00000a7b # $Copyright (c) 2016-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
# Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

###########################################################################################
# Connectivity plug-in configuration for correlator <-> Digital Event Services connectivity
###########################################################################################

# Configures DES to use a single default service, pointed at a particular
# Universal Messaging realm e.g. nsp://server.example.com:9000
#
# Use this setting if you want a simple DES configuration and do not want to use
# Command Central or any other external tool to configure DES. Otherwise, leave
# it blank to allow DES to be configured by standard means, or to connect to the
# default local installation of Universal Messaging.
#
DigitalEventServices_replaceConfigWithRNAME=


# The directory that Digital Event Services will use for its configuration
# files. This default will locate the configuration relative to the current
# working directory of the correlator, and is appropriate for configuration from
# Command Central.
#
DigitalEventServices_configDir=.


# Specify the subscriber Id to be used for reliably receiving from DES.
#
# This is used to identify your application across restarts, upgrades or system
# failures. DES can identify which events your application has missed during
# the downtime, and redeliver them as if the interruption had not happened.
#
# If not set, reliable receiving is not enabled for this transport.
DigitalEventServices_reliability_subscriberId=


# Specify the maximum number of unacknowledged events that DES will allow.
# Beyond this, DES will temporarily stop delivering events to the correlator
# until some portion of previously delivered events have been acknowledged.
#
# Larger values for this property can improve throughput in some situations,
# where your application needs to take time to fully process and acknowledge
# events. DES will then spend less time blocking waiting for acknowledgements
# of previous events.
#
# However, larger values can increase the number of duplicate messages
# delivered after an interruption, and will also consume more resources on the
# messaging system being used by DES e.g. Universal Messaging.
#
# This property is ignored if reliability_subscriberId is not used.
DigitalEventServices_reliability_maxUnacknowledgedEvents=5000
 00000069 C:\Users\jagt\workspace101\HelloApama\config\connectivity\DigitalEventServices\DESConnectivity.properties
YAML 0000031f # $Copyright (c) 2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
# Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

connectivityPlugins:
    stringCodec:
        libraryName: connectivity-string-codec
        class: StringCodec

    classifierCodec:
        libraryName: ClassifierCodec
        class: ClassifierCodec

    mapperCodec:
        libraryName: MapperCodec
        class: MapperCodec

    diagnosticCodec:
        libraryName: DiagnosticCodec
        class: DiagnosticCodec

    jsonCodec:
        libraryName: connectivity-json-codec
        class: JSONCodec 00000040 C:\SoftwareAG101\Apama\connectivity\bundles\standard-codecs.yaml
YAML 000005fb # $Copyright (c) 2016-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
# Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

###########################################################################################
# Connectivity plug-in configuration for correlator <-> Digital Event Services connectivity
#
# This configuration file should not be modified by a user. All user-accessible
# configuration is available and documented in the properties file.
###########################################################################################

connectivityPlugins:
  DES:
    directory: ${APAMA_HOME}/lib
    classpath: des-transport.jar
    class: com.apama.digitalevents.DigitalEventServicesChainManager

dynamicChainManagers:
  DES:
    transport: DES
    managerConfig:
      log4jConfigFile: ${APAMA_HOME}/etc/digital-event-services-log4j.properties
      replaceConfigWithRNAME: ${DigitalEventServices_replaceConfigWithRNAME}
      configDir: ${DigitalEventServices_configDir}
      reliableMessaging:
        subscriberId: ${DigitalEventServices_reliability_subscriberId}
        maxUnacknowledgedEvents: ${DigitalEventServices_reliability_maxUnacknowledgedEvents}


dynamicChains:
  DES:
    - apama.eventMap:
        suppressLoopback: true
        allowMissing: false
    - DES
 00000063 C:\Users\jagt\workspace101\HelloApama\config\connectivity\DigitalEventServices\DESConnectivity.yaml
RAND 0000000a 1848881000
TIME 00000010 1522267306.428,1
CONN 0000003c 7940883334667444254:7940896640478355486 from 127.0.0.1:64968
TIME 0000000e 1522267307.1,1
MONF 00000b40 /**
 * $Copyright (c) 2016-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */

package com.softwareag.connectivity.control;

/**
 * Used for com.softwareag.connectivity.Chain#ackUpTo() and
 * com.softwareag.connectivity.control.AckRequired#ackUpTo() , sent to the
 * control channel of the chain.
 * @private
 */
event AckUpTo {
	string messageId;
}

/**
 * Request from a connectivity chain to the application, asking it to reliably
 * acknowledge all events that came from the chain immediately prior to this
 * AckRequired.
 *
 * This event will be sent to the default channel of that chain. That is, your
 * EPL will not normally need to subscribe to any extra channels to receive
 * these requests, if it is already receiving regular events from that chain.
 *
 * A reliable-messaging-aware transport will issue these requests with as large
 * an interval as it can get away with, based on the constraints of the
 * external messaging system. So if your application has a "commit" mechanism
 * that has a large fixed cost (for example, a filesystem sync, a database
 * commit or an expensive computation) then doing a commit and acknowledgment
 * on and only on AckRequired requests makes sense.
 *
 * Do not rely on these requests being high frequency or timely; the functional
 * behaviour of your application should not depend on them, especially if
 * latency is important. Only the operations required for safely preserving the
 * effect of incoming events should be tied to AckRequired requests.
 *
 * @see com.softwareag.connectivity.Chain#ackUpTo() Otherwise, you can use this
 * action to perform per-event acknowledgments if the message id of each
 * incoming event is available.
 */
event AckRequired {
	/** The message id of the regular event received immediately before this AckRequired. */
	string messageId;

	/** Id of the connectivity chain that this request has come from. */
	string chainId;

	/**
	 * Acknowledge all previously received events from the connectivity chain
	 * as having been reliably processed by your application.
	 */
	action ackUpTo() {
		send AckUpTo(messageId) to "com.softwareag.connectivity.chaincontrol." + chainId;
	}
}

/**
 * Used by com.softwareag.connectivity.Chain#flush(). This event gets sent to
 * the control channel of the chain.
 * @private
 */
event Flush {
	integer requestId;
	context replyTo;
}

/**
 * Response to a flush request.
 *
 * @see com.softwareag.connectivity.Chain#flush()
 */
event FlushAck {
	/** Identifies the corresponding flush request. */
	integer requestId;
}
 0000003e C:\SoftwareAG101\Apama\monitors\ConnectivityPluginsControl.mon
TIME 0000000e 1522267307.2,1
MONF 00001fd8 /**
 * $Copyright (c) 2015-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */

package com.softwareag.connectivity;

/**
 * Represents a chain instance and provides methods to perform various operations on it.
 */
event Chain
{
	/** @private */
	import "ConnectivityPlugin" as _plugin;
	/** 
	 * Destroy this chain instance. Chains that are managed by a dynamic chain
	 * manager cannot be destroyed this way.
	 * This should be called only once.
	 */
	action destroy()
	{
		_plugin.destroyChain(chain);
	}
	
	/**
	 * Return the unique id of the chain instance.
	 *
	 * @return The id of the chain instance
	 */
	action getId() returns string
	{
		return _plugin.getChainId(chain);
	}

	/**
	 * Acknowledge that a specific event and all previous events received from
	 * this connectivity chain have been reliably processed by your
	 * application.
	 *
	 * If you are going to make use of this action, then the message id of the
	 * incoming events will need to be available somehow. For example, as a
	 * field on the event.
	 *
	 * This action will only have an effect on chains with a
	 * reliable-messaging-aware transport, and should not be used otherwise.
	 *
	 * @see com.softwareag.connectivity.control.AckRequired  In some situations
	 * it may make more sense to do acknowledgments on AckRequired requests,
	 * rather than against events of the application's choice.
	 *
	 * @param messageId The message id of the specific event
	 */
	action ackUpTo(string messageId) {
		send control.AckUpTo(messageId) to "com.softwareag.connectivity.chaincontrol." + getId();
	}

	/**
	 * Ask the chain to acknowledge all events previously sent to it by the
	 * application. A FlushAck reply will be sent to the current context once
	 * these events have been reliably processed by the external system.
	 *
	 * This action will only have an effect on chains with a
	 * reliable-messaging-aware transport, and should not be used otherwise.
	 *
	 * A transport will still handle events that are sent to it, whether or not
	 * flushing is used. A flush request is purely a signalling mechanism.
	 *
	 * @see com.softwareag.connectivity.control.FlushAck
	 * @return The requestId of the expected FlushAck
	 */
	action flush() returns integer {
		integer rID := integer.getUnique();
		send control.Flush(rID, context.current()) to "com.softwareag.connectivity.chaincontrol." + getId();
		return rID;
	}
	
	/** @private */
	chunk chain;
}

/**
 * Utility event to provide string literals for direction.
 */
event Direction {
	/**
	 * The direction of messages flowing towards the transport (from the host).
	 */
	constant string TOWARDS_TRANSPORT := "TOWARDS_TRANSPORT";
	
	/**
	 * The direction of messages flowing towards the host (from the transport).
	 */
	constant string TOWARDS_HOST := "TOWARDS_HOST";
}

/**
 * Utilities for interacting with connectivity plug-ins.
 */
event ConnectivityPlugins
{
	/** @private */
	import "ConnectivityPlugin" as _plugin;

	/** Should be called by EPL applications after all EPL has been injected
	 * and initialized, to indicate that the application is ready to receive
	 * events from connectivity plug-ins.
	 *
	 * This will also enable reception of JMS events if correlator-integrated
	 * JMS is enabled (That is, it implicitly calls
	 * JMSPlugin.onApplicationInitialized)
	 *
	 * Invoking this action more than once is an error and will throw an
	 * exception.
	 *
	 */
	static action onApplicationInitialized()
	{
		_plugin.onApplicationInitialized();
	}
	/** 
	 * Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.
	 *
	 * This action returns a Chain that has already been created and started. It is immediately able to receive events.
	 *
	 * @deprecated [This action has been deprecated. Please use createDynamicChain instead.]
	 *
	 * @param chainInstanceId The unique identifier to use for the new chain instance. This identifier is used for logging, and for looking up existing Chain objects by id.
	 * @param channels The list of channels this chain should subscribe to
	 * @param chainDefnName The name of a chain definition listed under dynamicChains in the configuration file
	 * @param substitutions Dictionary providing values for <code>@{...}</code> dynamic substitution variables in the chain definition
	 * @return A Chain object which can be used to destroy this chain later
	 */
	static action createChain(string chainInstanceId, sequence<string> channels, string chainDefnName, dictionary<string, string> substitutions) returns Chain 
	{
		return Chain(_plugin.createChain(chainInstanceId, channels, chainDefnName, substitutions));
	}
	
	/** 
	 * Create and start a chain instance from the given chain definition listed in dynamicChains in the configuration file.
	 *
	 * This action returns a Chain that has already been created and started. It is immediately able to receive events.
	 *
	 * @param chainInstanceId The unique identifier to use for the new chain instance. This identifier is used for logging, and for looking up existing Chain objects by id.
	 * @param channels The list of channels this chain should subscribe to
	 * @param chainDefnName The name of a chain definition listed under dynamicChains in the configuration file
	 * @param substitutions Dictionary providing values for <code>@{...}</code> dynamic substitution variables in the chain definition
	 * @param defaultChannelTowardsHost Default channel to use for sending a message towards the host if no channel is specified on the message. 
	 * Use an empty string for no default channel. It is an error to specify non-empty defaultChannelTowardsHost value if defaultChannel is also
	 * specified for the host plug-in.
	 * @return A Chain object which can be used to destroy this chain later
	 */
	static action createDynamicChain(string chainInstanceId, sequence<string> channels, string chainDefnName, dictionary<string, string> substitutions, string defaultChannelTowardsHost) returns Chain 
	{
		return Chain(_plugin.createDynamicChain(chainInstanceId, channels, chainDefnName, substitutions, defaultChannelTowardsHost));
	}
	
	/**
	 * Look up a chain instance by its identifier. This can retrieve
	 * dynamically created chains, as well as statically created chains from
	 * 'startChains' in the correlator configuration.
	 *
	 * An exception is thrown if no chain exists with this identifier.
	 *
	 * @param chainInstanceId The unique identifier of the chain instance
	 * @return The chain instance
	 */
	static action getChainById(string chainInstanceId) returns Chain {
		return Chain(_plugin.getChainById(chainInstanceId));
	}
	
	/**
	 * Look up a chain instance by a channel it is subscribed to or sending to.
	 *
	 * There must be exactly one chain matching the requested combination of
	 * channel and direction, else an exception is thrown.
	 * 
	 * The direction of the channel specifies how the channel is used by the chain instance. 
	 * The TOWARDS_TRANSPORT direction means that the channel is one of the channels that 
	 * the chain instance is subscribed to to receive events from the host. The TOWARDS_HOST 
	 * direction means that the channel is used by the chain instance as the default channel 
	 * to deliver events from the transport to the host.
	 * 
	 * @param channel The channel to use for lookup. 
	 * @param direction Specifies the direction in which the channel is used by the chain instance. 
	 * Use the constants defined in the Direction event for string literals.
	 * @see com.softwareag.connectivity.Direction
	 */
	static action getChainByChannel(string channel, string direction) returns Chain {
		return Chain(_plugin.getChainByChannel(channel, direction));
	}
}

 00000037 C:\SoftwareAG101\Apama\monitors\ConnectivityPlugins.mon
MONF 0000c71d /*
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013-2014, 2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 * Event definitions for the Correlator-integrated Apama JMS adapter. 
 *
 * $Revision: 284562 $
 *
 */
package com.apama.correlator.jms;


// *****************************************************************************
// 
// Private event definitions - for internal use only. 
//

/** @private*/ event __AddSender
{
	string connectionId;
	string senderId;
	string senderReliability;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveSender
{
	string senderId;
}

/** @private*/ event __AddReceiver
{
	string connectionId;
	string receiverId;
	string destination;
	string receiverReliability;
	string durableTopicSubscriptionName;
	string messageSelector;
	boolean noLocal;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveReceiver
{
	string receiverId;
}

/** @private*/ event __JMSReceiverFlowControlWindowUpdate
{
	string receiverId;
	integer __processInstanceToken;
	integer __flowControlMarker;
	integer __flowControlWindow;
}

/** @private*/ event __ReceiverAcknowledgeAndResume
{
	string receiverId;
}

/** @private*/ event __JMSSenderFlush
{
	integer requestId;
	string channelName;
}

// *****************************************************************************
// 
// Public event API for dynamically adding/removing JMS senders and receivers
//
// To be notified about the successful addition or removal of senders and 
// receivers, applications should listen for the separate Sender/ReceiverStatus 
// events, looking for the OK or REMOVED status. 
//

/** An enumeration containing constants for the currently supported sender 
	reliability values.
*/
event JMSSenderReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection. 
	
		Events may be  duplicated or reordered if a component fails, but will 
		not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection identifiers. 
	
		Events may be reordered if a component fails, but will not be lost, 
		and will not be duplicated if the unique message ids are mapped into 
		the message and the receiving JMS client uses an appropriate duplicate 
		detection window. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
}

/** An enumeration containing constants for the message delivery modes for sender.
*/
event JMSMessageDeliveryMode
{
	/** Use PERSISTENT message delivery mode for sending messages to the broker.
	
		Reliable senders always use PERSISTENT message delivery mode.
	*/
	constant string PERSISTENT := "PERSISTENT";
	
	/** Use NON_PERSISTENT message delivery mode for sending messages to the broker.
	
		This is the default for BEST_EFFORT senders.
	*/
	constant string NON_PERSISTENT := "NON_PERSISTENT";
}

/** An event object representing an existing JMS sender. 
 *
 * A JMS sender has an associated channel to which Apama events can be "sent", 
 * which will then be mapped to JMS messages using the requested message 
 * reliability setting and delivered to a destination on the JMS message bus. 
 */
event JMSSender
{
	// Public
	
	/** Returns the unique identifier of this sender. */
	action getSenderId() returns string { return __senderId; }
	
	/** Returns the Correlator channel to use for events that should 
	 * be delivered to JMS using this sender. 
	 *
	 * Note that if this senderId does not exist or has been removed then 
	 * events sent to this channel will be lost without a warning. 
	 */
	action getChannel() returns string { return __channel; }
	
	/** Requests removal of this JMS sender. The removal will be performed 
	 * asynchronously, and completes after all events already sent by this 
	 * context have been passed to JMS, and the associated JMS producer and 
	 * session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSSenderStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the sender. The application should not 
	 * send any more events to the sender channel once this action has been 
	 * called. 
	 *
	 * It is an error to attempt to remove a JMS sender that does not exist, or 
	 * to attempt to remove a static JMS sender. Such errors will result in 
	 * the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSSenderStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveSender(__senderId).toString());
	}

	/** Returns the number of events that have been send to this sender's 
	 * channel from the application, but are still queued waiting to be sent to 
	 * JMS.
	 *
	 * This allows an EPL application to throttle or reduce the rate at which 
	 * it sends events based on the size of the backlog building up in the 
	 * Correlator's queues, to ensure that the Correlator does not run out of 
	 * memory due to a temporary peak in throughput rate or loss of the JMS 
	 * connection. 
	 *
	 * Calling this action is a slightly expensive operation, so it is best to 
	 * get the number of outstanding events once, then loop sending a batch of 
	 * events. Therefore do not call getOutstandingEvents inside a loop that is 
	 * continually sending events to JMS. 
	 *
	 * You must not call this method after calling remove().
	 */
	action getOutstandingEvents() returns integer
	{
		return __plugin.getOutstandingMessages(__senderId);
	}
	
	/** Requests a notification event after flushing all messages 
	 * already sent to the sender's channel by the current context. 
	 *
	 * A JMSSenderFlushed event will be sent to this context when all the 
	 * messages already sent to the sender channel have been processed 
	 * and passed to the JMS broker (or dropped, in the case of 
	 * non-recoverable mapping errors). 
	 *
	 * This feature is only applicable to BEST_EFFORT senders, as for 
	 * AT_LEAST_ONCE/EXACTLY_ONCE senders reliability is already taken care of 
	 * by the integration with Correlator state persistence. It is an error 
	 * to call this action from a persistent monitor. 
	 * 
	 * Applications may have multiple flush requests in flight at any one time. 
	 * Performance will be improved by sending multiple messages (e.g. 1000) 
	 * between each flush request.
	 *
	 * @returns The unique request id for flush request, which will be included 
	 * in the resulting JMSSenderFlushed event.
	 *
	 * @see JMSSenderFlushed Notification event sent in response to 
	 */
	action requestFlush() returns integer
	{
		__plugin.checkNonPersistentMonitor("requestFlush");
		integer requestId := integer.getUnique();
		string privateChannel := "com.apama.jms.backchannel." + context.current().getId().toString();
		monitor.subscribe(privateChannel);
		send __JMSSenderFlush(requestId, privateChannel) to self.getChannel();
		return requestId;
	}
	
	// Private
	
	/** @private*/ string __senderId;
	/** @private*/ string __channel;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** An event object representing the configuration of a new JMS sender, for 
 * dynamically adding JMS senders at runtime. 
 *
 * Call JMSConnection.createSenderConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createSenderConfiguration() Creates a new 
 *	JMSSenderConfiguration event object. 
 * @see JMSConnection#addSenderWithConfiguration() Uses a JMSSenderConfiguration 
 *	to add a new JMS sender. 
 */
event JMSSenderConfiguration
{
	/** The unique identifier of this sender. */
	action getSenderId() returns string
	{ return __senderId; }

	/** The identifier of the connection this sender belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** Specifies the reliability mode to use for messages from this sender. 
	 * @param value Must be one of the enumeration constants from the 
	 * JMSSenderReliability event, or "" to indicate that the connection's 
	 * defaultSenderReliability should be used. 
	 * @see JMSSenderReliability
	 */
	action setSenderReliability(string value) returns JMSSenderConfiguration
	{ __senderReliability := value; return self; }
	/** Specifies the reliability mode to use for messages from this sender. */
	action getSenderReliability() returns string
	{ return __senderReliability; }
	
	/** Specifies the message delivery mode to use for messages from this sender.
	 *
	 * This can be used only for non-reliable BEST_EFFORT senders.
	 * It is ignored for reliable senders which always use PERSISTENT message 
	 * delivery mode.
	 *
	 * @param value Must be one of the enumeration constants from the 
	 * JMSMessageDeliveryMode event, or "" to indicate that the default mode will be used
	 * @see JMSMessageDeliveryMode
	 */
	action setMessageDeliveryMode(string value) returns JMSSenderConfiguration
	{ __messageDeliveryMode := value; return self; }
	/** Specifies the message delivery mode to use for messages from this sender. */
	action getMessageDeliveryMode() returns string
	{ return __messageDeliveryMode; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __senderId;
	/** @private*/ string __senderReliability;
	/** @private*/ string __messageDeliveryMode;
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string senderId) 
	{
		self.__connectionId := connectionId;
		self.__senderId := senderId;
	}
	
	/** @private*/ 
	action __getAddSender() returns __AddSender
	{
		return __AddSender(
			getConnectionId(), 
			getSenderId(), 
			getSenderReliability(),
			{"MessageDeliveryMode":getMessageDeliveryMode()}
			);
	}
}

/** A notification event sent to an EPL application in response to a sender 
 * flush request.
 * 
 * The application context will receive this event after all the messages 
 * already sent by the application at the time of the flush request have been 
 * processed and passed to the JMS broker (or dropped, in the case of 
 * non-recoverable mapping errors). 
 *
 * This event will be sent to the context that requested message flushing.
 *
 * @see JMSSender#requestFlush()
 */
event JMSSenderFlushed
{
	/** The unique request id returned by the flush request.*/
	integer requestId;
	/** The identifier of sender. */
	string senderId;
}

/** An enumeration containing constants for the currently supported receiver 
	reliability values.
*/
event JMSReceiverReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection; events may be 
		duplicated or reordered if a component fails, but will not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection; events may be 
		reordered if a component fails, but will not be lost, and will not be 
		duplicated provided the unique message ids and duplicate detection 
		window are configured correctly. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
	/** Reliable messaging with acknowledgements controlled by the application.
	*/
	constant string APP_CONTROLLED := "APP_CONTROLLED";
}

/** An event object representing an existing JMS receiver. 
 *
 * A receiver listeners for messages on a specific JMS queue or topic, maps 
 * them to Apama events and sends them to the Correlator's public contexts. 
 */
event JMSReceiver
{
	// Public
	
	/** Returns the unique identifier of this receiver. */
	action getReceiverId() returns string { return __receiverId; }
	
	
	/** Requests removal of this JMS receiver. 
	 *
	 * The removal will be performed asynchronously, and completes after all 
	 * events already received from this JMS destination have been enqueued to 
	 * the Correlator, any persisted uniqueMessageIds no longer required for 
	 * duplicate detection have been deleted, any durable topic subscription 
	 * has been removed from the JMS broker, and the associated JMS consumer 
	 * and session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSReceiverStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the receiver. 
	 *
	 * It is an error to attempt to remove a JMS receiver that does not exist, 
	 * or to attempt to remove a static JMS receiver. Such errors will result 
	 * in the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSReceiverStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveReceiver(__receiverId).toString());
	}
	
	
	/** Signals that the application is ready for messages received 
	 * since the last appControlledAcknowledgeAndResume() call to be 
	 * acknowledged to JMS, and that message receiving can then resume. 
	 *
	 * This is used only by receivers which are running in APP_CONTROLLED 
	 * reliability mode. APP_CONTROLLED receivers should listen for the 
	 * JMSAppControlledReceivingSuspended event enqueued at the end of each 
	 * batch of incoming messages and respond by calling 
	 * appControlledAcknowledgeAndResume() once the messages or the output 
	 * events/state changes resulting from processing them have been reliably 
	 * stored in another system (e.g. sent and flushed to a downstream JMS 
	 * destination, or committed to a database or distributed MemoryStore). 
	 *
	 * To avoid race conditions, it is important to call this method only from 
	 * the context that is handling both the JMS messages from this receiver 
	 * and the JMSAppControlledReceivingSuspended event. 
	 * 
	 * Never call this method except in response to a 
	 * JMSAppControlledReceivingSuspended event, and do not call it from 
	 * a persistent monitor - both will result in an exception.
	 *
	 * @see JMSAppControlledReceivingSuspended
	 */
	action appControlledAcknowledgeAndResume() {
		__plugin.processControlEvent(__ReceiverAcknowledgeAndResume(__receiverId).toString());
	}
	
	// Private
	
	/** @private*/ string __receiverId;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** A notification event sent to an EPL application every time an APP_CONTROLLED 
 * receiver suspends, at the end of each message batch. 
 *
 * The application should respond by taking whatever action is required to 
 * ensure that the messages received since the last suspend 
 * or the output events/state changes resulting from processing them 
 * have been reliably stored in another system (e.g. sent and flushed to 
 * a downstream JMS destination, or committed to a database or distributed MemoryStore). 
 *
 * Once these operations have completed the application should call 
 * JMSReceiver.appControlledAcknowledgeAndResume() to signal that the message 
 * batch can be acknowledged to JMS (i.e. no longer needs to be retained for 
 * possible resending in the event of crash) and that receiving can resume. 
 *
 * This event will be sent to the same context(s) that are handling the 
 * messages from this receiver. 
 * The event will be sent at the end of every message 'batch' 
 * (see "maxBatchSize" in the documentation for more details). 
 * @see JMSReceiver#appControlledAcknowledgeAndResume()
 */
event JMSAppControlledReceivingSuspended
{
	/** The unique identifier of the suspended receiver. */
	string receiverId;
}


/** An event object representing the configuration of a new JMS receiver, for 
 * dynamically adding JMS receivers at runtime. 
 *
 * Call JMSConnection.createReceiverConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createReceiverConfiguration() Creates a new 
 *	JMSReceiverConfiguration event object. 
 * @see JMSConnection#addReceiverWithConfiguration() Uses a 
 *	JMSReceiverConfiguration to add a new JMS receiver. 
 */
event JMSReceiverConfiguration
{
	/** The unique identifier of this receiver. */
	action getReceiverId() returns string
	{ return __receiverId; }

	/** The identifier of the connection this receiver belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** The queue or topic this receiver will listen to. */
	action getDestination() returns string
	{ return __destination; }
	
	/** Specifies the reliability mode to use for receiving messages. 
	 * @param value Must be one of the enumeration constants from the 
	 *	JMSReceiverReliability event, or "" to indicate that the connection's 
	 *	defaultReceiverReliability should be used. 
	 * @see JMSReceiverReliability
	 */
	action setReceiverReliability(string value) returns JMSReceiverConfiguration
	{ __receiverReliability := value; return self; }
	/** Specifies the reliability mode to use for receiving messages. */
	action getReceiverReliability() returns string
	{ return __receiverReliability; }
	
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created.
	 * @param value A unique JMS subscription name if a durable topic 
	 *	subscription should be created, or "" if a non-durable topic 
	 *	subscription should be made. Only valid for topics, and only if the 
	 *	reliability is not BEST_EFFORT.
	 */
	action setDurableTopicSubscriptionName(string value) returns JMSReceiverConfiguration
	{ __durableTopicSubscriptionName := value; return self; }
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created. */
	action getDurableTopicSubscriptionName() returns string
	{ return __durableTopicSubscriptionName; }

	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. 
	 * @param value A message selector string, or "" to receive all messages. 
	 * See the JMS documentation for the javax.jms.Message interface for more 
	 * details. 
	 */
	action setMessageSelector(string value) returns JMSReceiverConfiguration
	{ __messageSelector := value; return self; }
	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. */
	action getMessageSelector() returns string
	{ return __messageSelector; }

	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. 
	 * @param value An arbitrary (but preferably short) string defined by the 
	 *	EPL application. All EXACTLY_ONCE receivers with this string will be 
	 *	grouped together to form a single duplicate detection domain. 
	 *
	 *	This is an advanced feature - by default, receivers are grouped into 
	 *	a duplicate detection domain together with other receivers in the 
	 *	same connectionId listening to the same destination, which is the 
	 *	correct setting in the majority of cases. 
	 */
	action setDupDetectionDomainId(string value) returns JMSReceiverConfiguration
	{ __dupDetectionDomainId := value; return self; }
	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. */
	action getDupDetectionDomainId() returns string
	{ return __dupDetectionDomainId; }

	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. 
	 * @param value May be set to true or false for topic destinations. If 
	 *	the destination is a queue, the behaviour of noLocal=true is not 
	 *	specified, and will not work with many providers. The default value of 
	 *	false is usually fine. 
	 */
	action setNoLocal(boolean value) returns JMSReceiverConfiguration
	{ __noLocal := value; return self; }
	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. */
	action getNoLocal() returns boolean
	{ return __noLocal; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __receiverId;
	/** @private*/ string __destination;
	/** @private*/ string __receiverReliability;
	/** @private*/ string __durableTopicSubscriptionName;
	/** @private*/ string __messageSelector;
	/** @private*/ string __dupDetectionDomainId;
	/** @private*/ boolean __noLocal;
	
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string receiverId, string destination) 
	{
		self.__connectionId := connectionId;
		self.__receiverId := receiverId;
		self.__destination := destination;
	}
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __getAddReceiver() returns __AddReceiver
	{
		__AddReceiver result := new __AddReceiver;
		result.connectionId := getConnectionId();
		result.receiverId := getReceiverId();
		result.destination := getDestination();
		result.receiverReliability := getReceiverReliability();
		result.durableTopicSubscriptionName := getDurableTopicSubscriptionName();
		result.messageSelector := getMessageSelector();
		result.noLocal := getNoLocal();
		if getDupDetectionDomainId() != "" { result.extraAddParams["dupDetectionDomainId"] := getDupDetectionDomainId(); }
		
		return result;
	}
}

/** An event object representing a JMS connection, with actions for 
 * manipulating a connection's existing senders and receivers, and also for 
 * dynamically adding senders and receivers at runtime. 
 *
 * Senders and receivers may be added dynamically either using the 
 * comprehensive JMSConnection.addReceiver/SenderWithConfiguration() actions 
 * which provide access to all configuration parameters, or one of the 
 * other addReceiver/Sender*() actions that simplify creation of 
 * senders/receivers using the more common configuration parameter sets. 
 *
 * @see JMS#getConnection() Use this method to get a JMSConnection
 */
event JMSConnection
{
	// Public
	
	/** The unique identifier of this connection. */
	action getConnectionId() returns string 
	{
		return __connectionId;
	}

	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	static action getReceiver(string receiverId) returns JMSReceiver { return JMSReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	static action getSender(string senderId) returns JMSSender { return JMSSender(senderId, "jms:"+senderId); }

	/** Get a JMSSender event object representing the default sender for this 
	 * connection (which exists automatically if no other static senders 
	 * were explicitly configured). 
	 */
	action getDefaultSender() returns JMSSender { return getSender(__connectionId+"-default-sender"); }

	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * reliability setting. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Events can be sent to the sender's channel as soon as 
	 * this action returns. 
	 *
	 * A unique senderId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param senderReliability An enumeration value from JMSSenderReliability 
	 * indicating the reliability setting to use for sending events. 
	 * Alternatively, specify an empty string "" to use the connection's 
	 * defaultSenderReliability. 
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to send events to, and an action for 
	 * removing the sender when it is no longer required. 
	 * @see JMSSenderReliability
	 */
	action addSender(string senderReliability) returns JMSSender
	{
		return addSenderWithConfiguration(createSenderConfiguration(__makeUniqueId("sender", senderReliability))
			.setSenderReliability(senderReliability));
	}
	
	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * sender configuration. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Note that no events will actually be sent into the 
	 * Correlator until JMS.onApplicationInitialized() has been called. 
 	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new sender, 
	 * constructed using JMSConnection.createSenderConfiguration and the 
	 * setter methods on JMSSenderConfiguration.
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to send events to, and an action for 
	 * removing the sender when it is no longer required. 
	 *
	 * @see JMSConnection#createSenderConfiguration()
	 */
	action addSenderWithConfiguration(JMSSenderConfiguration config) returns JMSSender
	{
		__plugin.processControlEvent(config.__getAddSender().toString());
		return getSender(config.getSenderId());
	}
	
	/** Create a JMSSenderConfiguration for this connection that can be 
	 * used to add a new sender with the specified settings. 
	 *
	 * @param senderId An application-defined unique identifier for this 
	 * sender, used to track status and removal. The senderId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the sender.
	 *
	 * Applications are encouraged to use <tt>integer.getUnique().toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the senderId. 
	 *
	 * @see JMSConnection#addSenderWithConfiguration()
	 */
	action createSenderConfiguration(string senderId) returns JMSSenderConfiguration
	{
		JMSSenderConfiguration result := new JMSSenderConfiguration;
		result.__init(__connectionId, senderId);
		return result;
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * queue/topic name and reliability setting. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use. 
	 *	Alternatively, specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 */
	action addReceiver(string destination, string receiverReliability) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("receiver", destination), destination)
			.setReceiverReliability(receiverReliability));
	}

	/** Requests the addition of a new dynamic JMS durable topic subscription. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * This durable topic subscription will remain on the JMS broker until this 
	 * dynamic receiver is removed using JMSReceiver.remove(). 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use.
	 
	 *	For a durable topic subscription, this must not be BEST_EFFORT.  
	 *	Specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @param durableTopicSubscriptionName The unique identifier used by the 
	 *	JMS broker for for this durable topic subscription. 
	 *
	 *	Must not be "", and must not match any other subscription name with the 
	 *	same connection clientID. 
	 *
	 * @param messageSelector An optional JMS message selector query string to 
	 *	select a subset of topic messages to be processed by this receiver, or 
	 *	"" to receive all messages. 
	 *
	 *	See the JMS documentation for the javax.jms.Message interface for more 
	 *	details. 

	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 * @see JMSReceiver#remove()
	 */
	action addReceiverWithDurableTopicSubscription(string destination, string receiverReliability, 
		string durableTopicSubscriptionName, string messageSelector) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("durable-subscriber", durableTopicSubscriptionName), destination)
			.setReceiverReliability(receiverReliability)
			.setMessageSelector(messageSelector)
			.setDurableTopicSubscriptionName(durableTopicSubscriptionName)
			);
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * receiver configuration. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new 
	 * receiver, constructed using JMSConnection.createReceiverConfiguration 
	 * and the setter methods on JMSReceiverConfiguration.
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 * for status monitoring, and an action for removing the receiver when it 
	 * is no longer required. 
	 *
	 * @see JMSConnection#createReceiverConfiguration()
	 */
	action addReceiverWithConfiguration(JMSReceiverConfiguration config) returns JMSReceiver
	{
		__plugin.processControlEvent(config.__getAddReceiver().toString());
		return getReceiver(config.getReceiverId());
	}
	
	/** Create a JMSReceiverConfiguration for this connection that can be 
	 * used to add a new receiver with the specified settings. 
	 *
	 * @param receiverId An application-defined unique identifier for this 
	 * receiver, used to track status and removal. The receiverId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the receiver.
	 *
	 * Applications are encouraged to use <tt>integer.getUnique().toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the receiverId. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 * prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @see JMSConnection#addReceiverWithConfiguration()
	 */
	action createReceiverConfiguration(string receiverId, string destination) returns JMSReceiverConfiguration
	{
		JMSReceiverConfiguration result := new JMSReceiverConfiguration;
		result.__init(__connectionId, receiverId, destination);
		return result;
	}
	
	// Private
	
	/** @private*/ string __connectionId;
	/** @private*/ import "JMSPlugin" as __plugin;
	
	/** @private*/ 
	action __makeUniqueId(string requiredSuffix, string optionalSuffix) returns string {
		string result := __connectionId+"-"+requiredSuffix;
		if optionalSuffix != "" {
			result := result+"-"+optionalSuffix;
		}
		result := result.replaceAll(":","-"); // ensure it's a valid identifier
		return result + "-" + integer.getUnique().toString();
	}
	
}

/** The top-level event object representing the Correlator-integrated JMS 
 * runtime.
 */
event JMS
{
	// Public
	
	/** Should be called by EPL applications after all EPL has been injected 
	 * and initialized, to indicate that the application is ready to receive 
	 * events from the JMS runtime, such as received JMS messages and 
	 * status notification events. 
	 *
	 * Invoking this action more than once will have no effect. 
	 *
	 */
	static action onApplicationInitialized() 
	{
		__plugin.onApplicationInitialized();
	}
	
	/** Get a JMSConnection event object representing a connection defined  
	 * in the XML configuration file. 
	 */
	static action getConnection(string connectionId) returns JMSConnection
	{
		return JMSConnection(connectionId);
	}
	
	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	static action getReceiver(string receiverId) returns JMSReceiver { return JMSConnection.getReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	static action getSender(string senderId) returns JMSSender { return JMSConnection.getSender(senderId); }
	
	// Private
	
	/** @private*/ import "JMSPlugin" as __plugin;
}


//*****************************************************************************
//
// Status events
//

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * connection encounters an error or changes state. 
 *
 * This event includes string constants for each supported status. 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 */
event JMSConnectionStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** An enumeration value specifying the status of the connection. The 
	 * values in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the connection is up. 
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This should 
		always be a non-empty string when the status is "ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the Correlator-JMS runtime is fully 
		connected to the JMS broker with a valid JMS Connection object. */
	constant string OK := "OK";
	
	/** The status value indicating that the Correlator-JMS runtime is trying
		to establish an initial connection.  */
	constant string CONNECTING := "CONNECTING";

	/** The status value indicating that the connection is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * sender has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this sender
 * (as specified when it was created). 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 *
 * JMSSenderStatus events are sent for both static senders in the 
 * configuration file (or the implicitly defined default sender), and 
 * dynamic senders created with JMSConnection.addSender.
 */
event JMSSenderStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** The unique identifier of this sender. 
	*/
	string senderId;

	/** An enumeration value specifying the status of the sender. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the sender is functioning correctly; if it 
	 * is REMOVED then removal of the sender has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the sender is fully connected to the 
		JMS broker with a valid JMS Producer object, and is available to send 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the sender is waiting for the 
		JMS connection or sender session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the sender is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
	
	/** The status value indicating that the sender is not available due to 
		a fatal error condition. 
		
		Senders in this state are no longer useful and should be removed by the 
		EPL application (if dynamic) or the system administrator (if statically 
		defined in the XML config file). Note that the removal of such failed 
		senders does not happen automatically. */
	constant string FATAL_ERROR := "FATAL_ERROR";
	/** The status value indicating that the removal of a dynamic sender has 
		been completed, which will be sent some time after a sender removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a sender may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	// fields specifying the sender's configuration:

	/** Sender quality of service, specifying the reliability mode of the 
		messages from this sender. 
		
		One of the enumeration constants from the JMSSenderReliability event. */
	string senderReliability;

	/** Additional sender configuration parameters specified when it was added. 
	*/
	dictionary<string,string> extraAddParams;

}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * receiver has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this receiver
 * (as specified when it was created). 
 *
 * Note that the ordering of JMSReceiverStatus events relative to received 
 * messages is not defined. Also note that notification events will be held 
 * back until JMS.onApplicationInitialized() has been called. 
 *
 * JMSReceiverStatus events are sent for both static receivers in the 
 * configuration file, and dynamic receivers created with 
 * JMSConnection.addReceiver.
 */
event JMSReceiverStatus
{
	/** The unique identifier of the JMS connection.  */
	string connectionId;
	
	/** The unique identifier of this receiver. */
	string receiverId;

	/** An enumeration value specifying the status of the receiver. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the receiver is functioning correctly; if it 
	 * is REMOVED then removal of the receiver has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;

	// enumeration constants for status field value:
	
	/** The status value indicating that the receiver is fully connected to the 
		JMS broker with a valid JMS Consumer object, and is available to receive 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the receiver is waiting for the 
		JMS connection or receiver session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the receiver is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";

	/** The status value indicating the  receiver could not be found because of 
		a problem accessing the specified destination (i.e. a JMS or JNDI 
		error). */
	constant string DESTINATION_NOT_FOUND := "DESTINATION_NOT_FOUND"; 	

	/** The status value indicating that the receiver is not available due to 
		a fatal error condition. 
		
		Receivers in this state are no longer useful and should be removed by 
		the EPL application (if dynamic) or the system administrator (if 
		statically defined in the XML config file). The removal of such failed 
		receivers does not happen automatically. 
	*/
	constant string FATAL_ERROR := "FATAL_ERROR";

	/** The status value indicating that the removal of a dynamic receiver has 
		been completed, which will be sent some time after a receiver removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a receiver may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;

	// fields specifying the receiver's configuration:
	
	/** A JMS queue name, JMS topic name, or JNDI name, prefixed by 
		<tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>. */
	string destination;
	/** Receiver quality of service, specifying the reliability mode used 
		for receiving messages. 
		
		One of the enumeration constants from the JMSReceiverReliability event*/
	string receiverReliability;
	/** A unique JMS subscription name if a durable topic subscription should 
		be created, or "" if a non-durable topic subscription should be made. */
	string durableTopicSubscriptionName;
	/** JMS message selector string, to specify a subset of messages from the 
		destination to be processed by this receiver. 
	*/
	string messageSelector;
	/** Specifies that messages sent to this destination by our own connection 
		should be ignored by the receiver. */
	boolean noLocal;
	/** Additional receiver configuration parameters. None currently supported. */
	dictionary<string,string> extraAddParams;
}

//*****************************************************************************
//
// Advanced control events
//


/** A control event periodically sent to an EPL application for each receiver 
 * with receiverFlowControl enabled, which the application uses to update 
 * the flow control window.
 *
 * This event is used as a baseline from which the EPL application specifies 
 * the size of the window of new events it is currently ready to receive, 
 * specified relative to the last event received before this marker. 
 *
 * The event is sent:
 * i) when a receiver with receiverFlowControl=true is first added 
 * (once onApplicationInitialized has been called), 
 * ii) during recovery (in a persistent correlator), and 
 * iii) also periodically as JMS messages are received and 
 * enqueued to the correlator (typically these events are sent as often as 
 * the configured maxBatchSize, e.g. at least once every 1000 events). 
 *
 * To correctly implement the receiver flow control protocol, applications must 
 * respond to this event by calling updateFlowControlWindow (see below) 
 * to indicate the maximum number of additional events that the JMS runtime 
 * should take from this receiver, using the point in the event stream at 
 * which this marker was received as the baseline. 
 *
 * Applications that wish to  use flow control to throttle message receiving 
 * based on the number of outstanding asynchronous operations from 
 * already-received messages (to put a finite bound on memory usage) should 
 * also cache the most recent JMSReceiverFlowControlMarker for each 
 * active JMSReceiver so that the flow control window can be updated 
 * (e.g. extended) as pending operations complete, since there is no guarantee 
 * another JMSReceiverFlowControlMarker event will be sent until the window 
 * is extended enough for more events to be received. 
 *
 * Note that the fields of this event (apart from receiverId) are intended as 
 * 'opaque' data for internal use only and should be ignored by customer code.
 *
 * @see JMSReceiverFlowControlMarker#updateFlowControlWindow() Set the flow 
 * control window for this receiver, relative to this marker. 
 */ 
event JMSReceiverFlowControlMarker
{
	/** The unique identifier of this receiver. */
	string receiverId;
	
	/** For internal use only, treat as opaque data. */ 
	integer __processInstanceToken;
	
	/** For internal use only, treat as opaque data. */ 
	integer __flowControlMarker;
	
	/**
	* Sets the current flow control window size for a given receiver, which 
	* indicates the number of extra Apama events that should be taken from JMS 
	* and passed to the application before blocking, relative to the last data 
	* event received before this marker. 
	*
	* @param windowSizeEvents The maximum number of new events that should be 
	* received from this JMS receiver and enqueued to the correlator, relative 
	* to the position in the event flow indicated by this marker. 
	* The window size may be a constant number (e.g. 10,000 events) for 
	* applications that immediately process received events to completion,
	* or it may have a number of 'pending' events subtracted from it to create 
	* a bound on on the number of events that may be received from the JMS 
	* broker but are not yet been fully processed by the application (e.g. if 
	* an asynchronous database operation must complete before the memory, data 
	* structures or event listeners associated with the event may be deleted).
	*
	* It is valid to supply a zero or negative number for this value, in which 
	* case the JMS runtime will attempt to pause receiving, and take no more 
	* messages from the JMS queue/topic until this action is called again 
	* with a positive window (though it is not possible to guarantee that the 
	* flow of events will stop immediately, since some events could already be 
	* queued up). To allow an unbounded number of events to be received, 
	* specify integer.MAX for windowSizeEvents.
	* 
	* It is important that the overall long-term maximum window size 
	* (i.e. the chosen constant upper bound, ignoring any currently pending 
	* operations) is greater than than the receiver's maxBatchSize 
	* (typically 1000). 
	*/
	action updateFlowControlWindow(integer windowSizeEvents)
	{
		// use 'UnlessDisabled' as this should be a no-op when JMS is disabled, to support replay log
		__plugin.processControlEventUnlessDisabled(__JMSReceiverFlowControlWindowUpdate(
			receiverId, __processInstanceToken, __flowControlMarker, windowSizeEvents).toString()
		);
	}
	
	/** @private*/ import "JMSPlugin" as __plugin;
}
 00000037 C:\SoftwareAG101\Apama\monitors\CorrelatorJMSEvents.mon
MONF 00002fdc //*****************************************************************************
// Title:       StatusSupport
// Description: Provides event definitions for generic status reporting from  
//              service monitors.
//
// Revision:    $Revision: 284562 $
//
// $Copyright(c) 2006-2007, 2008-2009, 2011-2012 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.statusreport;

/*
	The events defined in this file act as an API between applications
	or blocks and service monitors.  They provide functionality to 
	Subscribe to status messages.
	
	The aim of this API is to provide an abstraction over any adapter
	specific details - for example, some adapters may require an explicit 
	call to subscribe to such data, some may be sent it anyway.
	
	Any adapter specific information that the application needs to supply
	or be supplied can be passed in the extraParams dictionary - these 
	are free-form (though there are conventions on the keys, see below).
	
	The service monitor also needs to handle any session initiation that
	may be required.
	
	A Status event does not denote a change of state, merely what the current
	state is - in particular, one will be sent out after every 
	SubscribeStatus request.

	All operations and responses are keyed on serviceId (if non-blank), 
	object,	connection and subServiceID. Every event starts with these 4 
	fields.
	
*/


/**
 *	Sent to the SubscribeStatus chanenl to subscribe to status.
 *	
 */
event SubscribeStatus {
	constant string CHANNEL := "SubscribeStatus";
	/**
	 *	service ID to subscribe to - blank will target all services.
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}

/**
 *	Sent to the service monitor to unsubscribe from status.
 *	
 */
event UnsubscribeStatus {	 
	constant string CHANNEL := "SubscribeStatus";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}


/**
 *	Sent from the service monitor to the StatusReport channel to notify the application of status for a 
 *	subscribed item.
 *	
 */
event Status {	
	constant string CHANNEL := "StatusReport";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	A sequence of summary strings specifying information about the 
	 *	status of the specified object.  This will be a well recognized
	 *	sequence of words - for example, a financial market's
	 *	"MarketState" may be "Open", "Closed", "PreOpen", etc.  A Connection 
	 *	may be "Connected", "Disconnected", "Disconnected LoginFailed", 
	 *	"Disconnected TimedOut", etc. 
	 */
	sequence<string> summaries;

	/**
	 *	available.
	 *	True if the object is "available" - the exact meaning is adapter 
	 * 	specific; for example, connected, open for general orders, etc.
	 */
	 boolean available;
	 
	 /** 
	 *	extra parameters that do not map into any of the above.  Convention
	 *	is that keys are in TitleCase.  e.g. "Username", "CloseTime", etc.
	 */
	wildcard dictionary <string, string> extraParams;
}


event StatusError {
	constant string CHANNEL := "StatusReport";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	Whether the subscription has been terminated.  Any subscribers will 
	 *	need to send a new SubscribeStatus request after this.
	 */
	boolean failed;
}
	
//*****************************************************************************
// Title:         ParallelStatusSupport
// Description:   ParallelStatusSupport description
// Dependencies:  None
// Author:        arrustem
//
//*****************************************************************************

/*
	Event definitions for block subject event wrappers;
	These are provided for backwards compatibility.  Monitors listening to status should instead subscribe to the "StatusReport" channel.
*/
event SubscribeStatusToContext {
	context instanceContext;
	SubscribeStatus subscribe;
}

event UnsubscribeStatusToContext {
	context instanceContext;
	UnsubscribeStatus unsubscribe;
}

monitor ParallelStatusSupport {
	/*	dictionary < [serviceId] , sequence of contexts > eventRouter;
	 - eventRouter will keep track of all contexts that are listening to a particular symbol
	 - The same d.s. will be used for both, Status and StatusError
	   since they are added/removed precisely at the same time. 
	*/
	dictionary < string , sequence<context> > eventRouter;
	
	/*	dictionary < [serviceId], dictionary < [contextId], [key ctr] > > statusToContextCtr;
	 - Keeps count of number of listeners for each symbol on each context
	*/
	dictionary < string, dictionary < integer, integer > > statusToContextCtr;

	/*	dictionary < [serviceId], listener > statusListeners;
	 - keeps track of the local listeners for Status
		dictionary < [serviceId], listener > errorListeners;
	 - keeps track of the local listeners for StatusError
	*/
	dictionary < string, listener > statusListeners;
	dictionary < string, listener > errorListeners;
	
	action onload() {
		monitor.subscribe("StatusReport");
		// set up listeners for the wrapped events coming from subjects
		SubscribeStatusToContext subscribe;
		on all SubscribeStatusToContext():subscribe subscribeEventHandler(subscribe);
		
		UnsubscribeStatusToContext unsubscribe;
		on all UnsubscribeStatusToContext():unsubscribe unsubscribeEventHandler(unsubscribe);
	}
	
	action ondie() {
                // print out an error if statusToContextCtr is not empty
                if (statusToContextCtr.size() != 0) {
                        log "ParallelStatusSupport is terminating but there may still be contexts subscribed to Status events" at ERROR;
                }
                else {
                        log "ParallelStatusSupport is terminating" at INFO;
                }
	}
	
	action onunload() {
		// not doing anything here since it is assumed that only one instance of this monitor is executing 
	}
	
	action subscribeEventHandler(SubscribeStatusToContext evt) {
		
		string key := evt.subscribe.serviceID;
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if not statusToContextCtr.hasKey(key) {
			dictionary <integer, integer> entry := {cId:0};
			statusToContextCtr.add(key, entry);
		}
		else {
			if not statusToContextCtr[key].hasKey(cId) {
				statusToContextCtr[key].add(cId, 0);
				
			}
		}
		statusToContextCtr[key][cId] := statusToContextCtr[key][cId] + 1;
		
		// manage eventRouter
		if not eventRouter.hasKey(key) {
			sequence < context > entry := [];
			eventRouter.add(key, entry);
			addListener(key);
		}
		// look up context in the symbol
		if (eventRouter[key].indexOf(evt.instanceContext) = -1) {
			eventRouter[key].append(evt.instanceContext);
		}

		route evt.subscribe;
	}

	action unsubscribeEventHandler(UnsubscribeStatusToContext evt) {
		string key := evt.unsubscribe.serviceID;
		
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if ((not statusToContextCtr.hasKey(key)) or 
			(not statusToContextCtr[key].hasKey(cId))) {
			log "unsubscribeEventHandler: unexpected UnsubscribeStatusToContext received for (key=" + 
				key.toString() + ", contextId=" + cId.toString() + ")" at WARN;
		}
		else {
			statusToContextCtr[key][cId] := statusToContextCtr[key][cId] - 1;
			if (statusToContextCtr[key][cId] = 0) {
				statusToContextCtr[key].remove(cId);
				integer i := eventRouter[key].indexOf(evt.instanceContext);
				if (i != -1) {
					eventRouter[key].remove(i);
				}
			}
			if (statusToContextCtr[key].size() = 0) {
				eventRouter.remove(key);
				removeListener(key);
			}
		}

		route evt.unsubscribe;
	}
	
	action addListener(string serviceID) {
		listener dl, el;
		context c;
		Status d;
		dl := on all Status(serviceID=serviceID):d {
			//send d to eventRouter[serviceID];
			for c in eventRouter[serviceID] {
				if c.getId() != context.current().getId() {
					send d to c;
				}
			}			
		}
		if statusListeners.hasKey(serviceID) {
			log "[action addListener] statusListeners already contains a listener for entry " + serviceID at WARN;
		}
		else {
			statusListeners.add(serviceID, dl);
		}
		
		StatusError e;
		el := on all StatusError(serviceID=serviceID):e {
			//send e to eventRouter[serviceID];
			for c in eventRouter[serviceID] {
				if c.getId() != context.current().getId() {
					send e to c;
				}
			}
		}
		if errorListeners.hasKey(serviceID) {
			log "[action addListener] errorListeners already contains a listener for entry " + serviceID at WARN;
		}
		else {
			errorListeners.add(serviceID, el);
		}
	}
	
	action removeListener(string serviceID) {

		if statusListeners.hasKey(serviceID) {
			statusListeners[serviceID].quit();
			statusListeners.remove(serviceID);
		}
		else {
			log "[action removeListener] statusListeners does not contain a listener for entry " + serviceID at WARN;			
		}
		
		if errorListeners.hasKey(serviceID) {
			errorListeners[serviceID].quit();
			errorListeners.remove(serviceID);
		}
		else {
			log "[action removeListener] errorListeners does not contain a listener for entry " + serviceID at WARN;			
		}
	}
}

 00000031 C:\SoftwareAG101\Apama\monitors\StatusSupport.mon
MONF 000033e8 /*
 * Apama Correlator-integrated JMS Status Manager service.
 *
 * Implements the StatusSupport event interface to allow an EPL application to 
 * monitor status information about the status of Correlator-Integrated JMS connections, 
 * senders and receivers.
 * 
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 */
package com.apama.correlator.jms;

using com.apama.correlator.jms.JMSConnectionStatus;
using com.apama.correlator.jms.JMSSenderStatus;
using com.apama.correlator.jms.JMSReceiverStatus;
using com.apama.statusreport.Status;
using com.apama.statusreport.StatusError;
using com.apama.statusreport.SubscribeStatus;
using com.apama.statusreport.UnsubscribeStatus;


/**
 * Provides a bridge between the JMS-specific status events and the generic 
 * StatusSupport API used by some Apama applications. 
 *
 * @see com.apama.statusreport.SubscribeStatus Generic StatusSupport 
 * status subscription request that an application may send to SubscribeStatus.CHANNEL.
 * @see com.apama.statusreport.Status Generic StatusSupport 
 * status information sent to the Status channel by this monitor for subscribed 
 * objects.
 */
monitor CorrelatorJMSStatusManager 
{
	dictionary<SubscribeStatus, integer> subs;

	dictionary<string, JMSConnectionStatusPublisher> csPubs;
	dictionary<string, JMSSenderStatusPublisher> ssPubs;
	dictionary<string, JMSReceiverStatusPublisher> rsPubs;

	action onload() 
	{
		// Set up listeners for client requests
		listenForSubscribeStatus();
		listenForUnsubscribeStatus();
	
		// Set up listeners for correlator-jms status events
		listenForNewJmsEntities();
	}

	action ondie()
	{
		//Can't distinguish between abnormal termination and shutdown,
		//so just log a message to indicate termination.
		log "CORRELATOR_JMS status manager has terminated." at INFO;
	}

	action listenForSubscribeStatus()
	{
		monitor.subscribe(SubscribeStatus.CHANNEL);
		SubscribeStatus newSub;
		on all SubscribeStatus("CORRELATOR_JMS", *, *, *):newSub
		{
			if isValidSubscription(newSub) 
			{
				log "Received status subscription: " + newSub.toString() at INFO;

				if subs.hasKey(newSub) { subs.add(newSub, subs[newSub] + 1); }
				else { subs.add(newSub, 1); }

				boolean atLeastOneAckSent := false;
				
				JMSConnectionStatusPublisher csPub;
				for csPub in csPubs.values()
				{
					atLeastOneAckSent := csPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSSenderStatusPublisher ssPub;
				for ssPub in ssPubs.values()
				{
					atLeastOneAckSent := ssPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSReceiverStatusPublisher rsPub;
				for rsPub in rsPubs.values()
				{
					atLeastOneAckSent := rsPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				if not atLeastOneAckSent 
				{
					log "No status events received yet from entities matching subscription: " + newSub.toString() at INFO;
					sequence<string> summaries := [ "UNKNOWN" ];
					dictionary<string,string> extraParams := {};	
					Status status := Status("CORRELATOR_JMS", newSub.object, newSub.subServiceID, newSub.connection, "No status events received yet from entities matching subscription", summaries, false, extraParams);
					send status to Status.CHANNEL; 
				}
			}
		}
	}

	action listenForUnsubscribeStatus() 
	{
		UnsubscribeStatus unsub;
		on all UnsubscribeStatus("CORRELATOR_JMS", *, *, *):unsub
		{
			if isValidUnsubscription(unsub)
			{
				log "Received status unsubscription: " + unsub.toString() at INFO;
				SubscribeStatus key := SubscribeStatus(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection);
	
				if subs.hasKey(key)
				{
					if subs[key] <= 1
					{
						subs.remove(key);	
					}
					else { subs[key] := subs[key] - 1; }
				}
				else
				{
					log "No subscription exists that matches unsubscription: " + unsub.toString() at DEBUG;
				}
			}
		}
	}

	action listenForNewJmsEntities()
	{
		JMSConnectionStatus cs;
		on all JMSConnectionStatus():cs
		{
			if not csPubs.hasKey(cs.connectionId)
			{
				log "Received connection status from new connection: " + cs.toString() at DEBUG;
				JMSConnectionStatusPublisher csPub := new JMSConnectionStatusPublisher;
				csPub.activate(cs, subs);
				csPubs.add(cs.connectionId, csPub);
			}
		}	

		JMSSenderStatus ss;
		on all JMSSenderStatus():ss
		{
			if not ssPubs.hasKey(ss.connectionId + ":" + ss.senderId)
			{
				log "Received sender status from new sender: " + ss.toString() at DEBUG;
				JMSSenderStatusPublisher ssPub := new JMSSenderStatusPublisher;
				ssPub.activate(ss, subs);
				ssPubs.add(ss.connectionId + ":" + ss.senderId, ssPub);
			}
		}	

		JMSReceiverStatus rs;
		on all JMSReceiverStatus():rs
		{
			if not rsPubs.hasKey(rs.connectionId + ":" + rs.receiverId)
			{
				log "Received receiver status from new receiver: " + rs.toString() at DEBUG;
				JMSReceiverStatusPublisher rsPub := new JMSReceiverStatusPublisher;
				rsPub.activate(rs, subs);
				rsPubs.add(rs.connectionId + ":" + rs.receiverId, rsPub);
			}
		}	
	}

	action isValidSubscription(SubscribeStatus sub) returns boolean 
	{ 
		return isValidSubOrUnsub(sub.serviceID, sub.object, sub.subServiceID, sub.connection, "SubscribeStatus", sub.toString()); 
	}	

	action isValidUnsubscription(UnsubscribeStatus unsub) returns boolean 
	{ 
		return isValidSubOrUnsub(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection, "UnsubscribeStatus", unsub.toString()); 
	}	

	action isValidSubOrUnsub(string serviceID, string object, string subServiceID, string connection, string requestType, string asString) returns boolean
	{
		string errMsg;
		if serviceID = "CORRELATOR_JMS"
		{
			if object = ""
			{
				if not subServiceID = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else if object = "CONNECTION"
			{
				if connection = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"CONNECTION\"): " + asString;
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}

				if not subServiceID = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"CONNECTION\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else if object = "SENDER" or object = "RECEIVER"
			{
				if connection = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"" + object + "\"): " + asString;
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}

				if subServiceID = ""
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID may not be \"\" when object is \"" + object + "\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else
			{ 
				errMsg := "Invalid CORRELATOR_JMS " + requestType + " (valid values for object field are \"CONNECTION\", \"SENDER\", \"RECEIVER\" or \"\"): " + asString;
				send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
				return false; 
			} 
			
			return true;
		}
		else 
		{ 
			errMsg := "Unexpected request to validate non-CORRELATOR_JMS " + requestType + " (serviceID must be CORRELATOR_JMS): " + asString;
			send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
			return false; 
		}
	}

	event JMSConnectionStatusPublisher
	{
		JMSConnectionStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;
		
		action activate(JMSConnectionStatus cs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := cs;
			allSubs := subs;

			if existsMatchingSub() { sendStatus(); }

			JMSConnectionStatus update;
			on all JMSConnectionStatus(current.connectionId, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "CONNECTION" and sub.connection = current.connectionId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{ 
			if matches(newSub)
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSConnectionStatus.OK) { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "CONNECTION", "", current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL;
		}
	}

	event JMSSenderStatusPublisher
	{
		JMSSenderStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSSenderStatus ss, dictionary<SubscribeStatus, integer> subs) 
		{
			current := ss;
			allSubs := subs;

			if existsMatchingSub() { sendStatus(); }

			JMSSenderStatus update;
			on all JMSSenderStatus(current.connectionId, current.senderId, *, *, *, *, *):update
			{	
				current := update;	
				if existsMatchingSub() { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "SENDER" and sub.connection = current.connectionId and sub.subServiceID = current.senderId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub)
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSSenderStatus.OK) { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "SENDER", current.senderId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL; 
		}
	}

	event JMSReceiverStatusPublisher
	{
		JMSReceiverStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSReceiverStatus rs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := rs;
			allSubs := subs;

			if existsMatchingSub() { sendStatus(); }
			
			JMSReceiverStatus update;
			on all JMSReceiverStatus(current.connectionId, current.receiverId, *, *, *, *, *, *, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "RECEIVER" and sub.connection = current.connectionId and sub.subServiceID = current.receiverId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub)
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSReceiverStatus.OK) { available := true; }
			log "Sending receiver status report in response to status event: " + current.toString() at DEBUG;

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "RECEIVER", current.receiverId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL;
		}
	}
}
 0000003e C:\SoftwareAG101\Apama\monitors\CorrelatorJMSStatusManager.mon
TIME 0000000e 1522267307.3,1
MONF 0000cc2a //
// MemoryStore.mon
//
// Provide shared and (optionally) persistent storage to MonitorScripts
//
// $Copyright(c) 2009,2012-2013 Progress Software Corporation (PSC). All rights reserved.\$
// $Copyright (c) 2013-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.\$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

package com.apama.memorystore;

using com.apama.exceptions.Exception;

/** Sent to the application when an asynchronous activity has finished. 
*/
event Finished {
	/** A unique identifier for the operation that has completed, 
		which will have been returned by the action that initiated the 
		operation. */
	integer id;
	/** True if the operation succeeded. */
	boolean success;
	/** An optional status or error message providing more detail 
		about why the operation succeeded or failed. */
	string status;
}

/** Represents the schema for a table in the store, specifying the field 
	names, types, and other behavioural information about the table. 

	The fields and types sequences must be the same length as one another, 
	specifying the names of fields and their corresponding types.
	
	Never construct a Schema using a "Schema(...)" expression. 
	Instead, always create a variable initialized to "new Schema", and then set 
	parameters individually with separate statements. This ensures that your 
	code will continue to work without modification if a subsequent version 
	of the MemoryStore adds more parameters to the Schema event.
	
	@see Store#prepare() The schema for a table is specified when it is 
		prepared. 
*/
event Schema {
	/** A sequence specifying the name of each field in this table. 

		For looking up the index of a specific field name (e.g. while 
		processing RowChanged events), use Table.getFieldIndex() which is 
		more efficient than using indexOf() on the fields sequence.
		
		@see Table#getFieldIndex() for efficiently obtaining the index of 
		a field.
	**/
	wildcard sequence<string> fields;
	
	/** A sequence specifying the type of each field in this table. 
	
		Permitted types are currently: 'integer', 'boolean', 'float', 'string'
		and 'decimal'.
		
		This sequence must have the same length as the fields sequence. 
	*/
	wildcard sequence<string> types;
	
	/** When this field is true, the MemoryStore makes the rows in the 
		in-memory table associated with this schema available to the 
		scenario service, so they can be used by external clients and 
		dashboards. 
		
		That is, the MemoryStore creates DataViews that contain the state of 
		this table that has been committed (but not necessarily persisted) to 
		the shared in-memory representation of the table.
		
		Committing changes to the in-memory row in a table that is exposing 
		its in-memory state causes events to be sent to the main context. 
	 */
	boolean exposeMemoryView;
	/** When this field is true, the MemoryStore makes the rows in the 
		on-disk table associated with this schema available to the 
		scenario service, so they can be used by external clients and 
		dashboards.  
		
		That is, the MemoryStore creates DataViews that contain data from this 
		table that has been persisted to disk. 
		
		You cannot expose a persistent view of a table in a 
		correlator-persistent store.
 	*/
	boolean exposePersistentView;
	
	/** Specifies the display name for an in-memory table. */
	string memoryViewDisplayName;
	/** Describes an in-memory table. */
	string memoryViewDescription;
	/** Specifies the display name for an on-disk table. */
	string persistentViewDisplayName;
	/** Describes an on-disk table. */
	string persistentViewDescription;
	
	/** Convert the supplied types into a valid MemoryStore table Schema.
	 *
	 *  Field types that are not supported by MemoryStore are converted to strings.
	 *
	 *  @param type to turn into a MemoryStore table Schema.
	 *  @returns The MemoryStore table Schema.
	 *  @since 10.1
	 */
	static action schemaFromAny(any prototype) returns Schema {
		Schema schema := new Schema;

		sequence<any> keys := prototype.getKeys();
		schema.types := normalizeTypes(prototype.getFieldTypes());
		
		integer i := 0;
		while (i < schema.types.size()) {
			// Create the field names from the string version of keys
			schema.fields.append(keys[i].valueToString());
			i := i+1;
		}
		
		return schema;
	}
	
	/** Normalize a sequence of types to those accepted by Memory Store.
	 *
	 *  Converts anything other than integer, float, boolean and decimal to string.
	 *
	 *  @param types Type string sequence to normalize
	 *  @returns Sequence of normalized string types
	 *  @since 10.1
	 */
	static action normalizeTypes(sequence<string> types) returns sequence<string> {
		dictionary<string, boolean> validTypes := {"integer":true, "float":true, "boolean":true, "string":true, "decimal":true};
		
		sequence<string> result := types.clone();
		
		integer i := 0;
		while (i < result.size()) {
			// Normalise the type
			if (not validTypes.hasKey(result[i]))
			{	
				result[i] := "string";
			}
			i := i+1;
		}
		
		return result;
	}
}

/** Represents an ordered and typed set of named fields in a table, with a 
	key that uniquely identifies the row within the table. 

	A Row is an atomic snapshot of the data in the
	table and once returned, a Row's contents are guaranteed to be consistent 
	and unchanging.

	Any changes the user makes to a Row are local until commit is called.
	
	@see Table A table holds a collection of rows. 
*/
event Row {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;

	/** Update the local Row event to reflect the current state of the shared
		MemoryStore table, losing any local modifications.
	
		row.update() has a very similar effect to r := t.get(r.getKey()),
		but is more efficient and doesn't require access to the table.
	*/
	action update() {
		plugin.RowChunk_update(c);
	}

	/** Copy the contents of the specified other Row into this one.
	
		The two rows that these Row events represent must have the same schema 
		but they need not be in the same table.

		r1.copy(r2) is a more efficient equivalent to
		r1.setX("a", r2.getX("a")) for every field. 
		
		You cannot copy a row between a correlator-persistent store and an 
		in-memory, on-disk or distributed store.
	*/
	action copy(Row other) {
		plugin.RowChunk_copy(c, other.c);
	}

	/** Mark the row for deletion when the table is committed.
	
		Fields cannot be accessed after this call, until the removal is
		successfully committed (or reverted using update).
	*/
	action remove() {
		plugin.RowChunk_remove(c);
	}
	
	/** Try to commit changes from this Row back to the table, returning false 
		if the Row is not up to date.
	
		If nothing else has modified the row in the table since this
		Row was created, the changes are committed so other users can
		see them and true is returned.
	
		Otherwise, false is returned and the table is left unchanged. 
		Do not repeatedly call tryCommit() without also calling update(), 
		or use the more efficient Row.tryCommitOrUpdate(). 
		
		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist). 

		@returns true if the table was modified; false if an error occurred and 
		the table was not changed. 
		
		@see Row#tryCommitOrUpdate()
	*/
	action tryCommit() returns boolean {
		return plugin.RowChunk_tryCommit(c,currentTime);
	}


	/** Try to commit changes from this Row back to the table, which could 
		result in an exception being thrown if the Row is not up to date.
	
		If nothing else has modified the row in the table since this
		Row was created, the changes are committed so other users can
		see them.
	
		Otherwise, an exception is thrown and the table is left unchanged.
		
		If there is any chance that the same row may be written to 
		concurrently - for example by multiple correlator contexts, and/or if 
		using a distributed MemoryStore - use Row.tryCommit() instead of 
		Row.commit() so that it is possible to recover from this situation 
		when it occurs or use Row.forceCommit() to commit the changes 
		forcefully.

		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist). 

		@see Row#tryCommit()
		@see Row#tryCommitOrUpdate()
	*/
	action commit() {
		plugin.RowChunk_commit(c,currentTime);
	}

	/** Try to commit, or update (losing local modifications) if not. 
	
		This is a more efficient equivalent to calling tryCommit then
		calling update if the commit fails. Typical usage would be to have a 
		loop that makes some modifications to a row, calls tryCommitOrUpdate, 
		and continues to loop (re-instating the local modifications and calling 
		tryCommitOrUpdate again) until it returns true. 
	
		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist). 
		
		@returns true if the commit succeeded, false if the commit failed but 
		the row has been updated ready for a retry attempt. 
		
	*/
	action tryCommitOrUpdate() returns boolean {
		return plugin.RowChunk_tryCommitOrUpdate(c,currentTime);
	}
	
	/** Commit this Row back to the table even if the Row is not up to date.
		
		If this Row is marked for deletion using Row.remove() then forceCommit 
		will unconditionally remove the Row from the table.
		
		Note that a MemoryStore commit operation synchronously writes changes 
		made to the local Row instance back to the table which is shared by all 
		monitors inside the Correlator (or the distributed store), but does not 
		cause a persistent write to disk (see Table#persist).
	 */
	action forceCommit() {
		plugin.RowChunk_forceCommit(c,currentTime);
	}

	/** Get the key for this Row. 
	
		It cannot be changed.
	*/
	action getKey() returns string {
		return plugin.RowChunk_getKey(c);
	}

	/** Indicate whether this row was in the table when the Row
		was created or updated. 
		
		It is possible to construct a Row that has no corresponding entry in 
		the table, in which case all fields have default values. 
		
		Calling commit on a Row for which inTable()=false will create the row.
	*/
	action inTable() returns boolean {
		return plugin.RowChunk_inTable(c);
	}
	
	/** Get the row as an any using the type the Store was created with
		(using prepareFromAny() or prepareFromTypeName()).
		
		This is equivalent to calling getAll(any.newInstance(getTableName())). 
		This action can be used only if the table name is a valid Apama type. 
		Use getAll() instead if the store was not created from an Apama type.

		@see Store#prepareFromAny()
		@see Store#prepareFromTypeName()
		@see #getAll()
	*/
	action toAny() returns any {
		return getAll(any.newInstance(getTableName()));
	}

	// Get the value
	//
	// The correct variant must be called for the type of the column
	// in the table.

	/** Get the value of the specified field in this row 
		(must only be used on boolean fields).
	*/
	action getBoolean(string name) returns boolean {
		return plugin.RowChunk_getBoolean(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on integer fields).
	*/
	action getInteger(string name) returns integer {
		return plugin.RowChunk_getInteger(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on float fields).
	*/
	action getFloat(string name) returns float {
		return plugin.RowChunk_getFloat(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on string fields).
	*/
	action getString(string name) returns string {
		return plugin.RowChunk_getString(c,name);
	}

	/** Get the value of the specified field in this row 
		(must only be used on decimal fields).
	*/
	action getDecimal(string name) returns decimal {
		return plugin.RowChunk_getDecimal(c,name);
	}
	
	/** Get the value of the specified field in this row 
		(can be used on all types).
		This will return a string for types that cannot be stored. Use getParsed() to parse to a type.
		@see #getParsed()
		@since 10.1
	*/
	action get(string name) returns any {
		string typeName := plugin.RowChunk_getFieldType(c,name);
		
		if (typeName = "boolean") {
			return getBoolean(name);
		} else if (typeName = "integer") {
			return getInteger(name);
		} else if (typeName = "float") {
			return getFloat(name);
		} else if (typeName = "string") {
			return getString(name);
		} else if (typeName = "decimal") {
			return getDecimal(name);
		}
		
		// Shouldn't get here
		throw com.apama.exceptions.Exception("Unknown type "+typeName+" in get()", "IllegalArgumentException");
	}
	
	/** Get the value of the specified field in this row parsed to the specified typeName.
		@since 10.1
	*/
	action getParsed(string name, string typeName) returns any {
	
		// If stored in the correct type, return it
		if (typeName = plugin.RowChunk_getFieldType(c,name)) {
			return get(name);
		}
		
		return any.parseType(typeName, get(name).valueToString());
	}

	// Set the value
	//
	// The correct variant must be called for the type of the column
	// in the table.

	/** Set the value of the specified field in this row 
		(must only be used on boolean fields). 
	*/
	action setBoolean(string name, boolean b) {
		plugin.RowChunk_setBoolean(c,name,b);
	}

	/** Set the value of the specified field in this row 
		(must only be used on integer fields). 
	*/
	action setInteger(string name, integer i) {
		plugin.RowChunk_setInteger(c,name,i);
	}

	/** Set the value of the specified field in this row 
		(must only be used on float fields). 
	*/
	action setFloat(string name, float f) {
		plugin.RowChunk_setFloat(c,name,f);
	}

	/** Set the value of the specified field in this row 
		(must only be used on string fields). 
	*/
	action setString(string name, string s) {
		plugin.RowChunk_setString(c,name,s);
	}

	/** Set the value of the specified field in this row 
		(must only be used on decimal fields). 
	*/
	action setDecimal(string name, decimal d) {
		plugin.RowChunk_setDecimal(c,name,d);
	}
	
	/** Set the value of the specified field in this row 
		(can be used with all types).
		Will use the string form if needed.
		@since 10.1
	*/
	action set(string name, any value) {
		try {
			string type := plugin.RowChunk_getFieldType(c,name);
		
			//  If the schema type is string, we toString the any value ignoring the underlying type (which could be wrong)
			if ("string" = type) {
				setString(name, value.valueToString());
				return;
			}
		} catch(Exception e) {
			// ignore - it may be an extraField entry.
		}
		
		switch (value) {
			case boolean: {
				setBoolean(name, value);
			}
			case integer: {
				setInteger(name, value);
			}
			case float: {
				setFloat(name, value);
			}
			case string: {
				setString(name, value);
			}
			case decimal: {
				setDecimal(name, value);
			}
			default: {
				setString(name, value.valueToString());
			}
		}
	}
	
	/** Set all values in this row from all available fields in the supplied any type.
		@param value Any type value (event or dictionary) to take the field values from
		@since 10.1
	*/
	action setAll(any value) {

		sequence<any> keys := value.getKeys();
		sequence<any> entries := value.getEntries();
		sequence<string> stringKeys := new sequence<string>;
		
		integer i := 0;
		while (i < keys.size()) {
			stringKeys.append(keys[i].valueToString());
			i := i+1;
		}
		
		// This throws if schema is invalid
		plugin.RowChunk_validateSchema(c, stringKeys, Schema.normalizeTypes(value.getTypes()));
		
		i := 0;
		while (i < stringKeys.size()) {
			set(stringKeys[i], entries[i]);
			i := i+1;
		}
	}

	/** Fill in value of all keys in the supplied 'any' with values from the row.
	
		@param prototype Any type value (an event or non-empty dictionary) 
		which will be modified in-place with the current values from this row.
		@returns The same instance passed in as prototype, filled in with 
		values from this row.
		
		@since 10.1
	*/
	action getAll(any prototype) returns any {
		
		sequence<any> keys := prototype.getKeys();
		
		any key;
		for key in keys {
			any prototypeEntry := prototype.getEntry(key);
			any rowField := get(key.valueToString());
			
			// If types don't match, and row is a string, attempt to parse it to correct type
			if ((prototypeEntry.getTypeName() != rowField.getTypeName()) and ("string" = rowField.getTypeName())) {

				prototype.setEntry(key, any.parseType(prototypeEntry.getTypeName(), rowField.valueToString()));
			} else {
				prototype.setEntry(key, rowField);
			}
		}
		
		return prototype;
	}

	/** Get all of the field names held in this Row.
	 * These are all of the valid values that can be passed to get(). Will include all Schema field names followed
	 * by any extra fields if the driver supports them.
	 * @since 10.1
	 */
	action getKeys() returns sequence<string>  {
		sequence<string> keys := [];
		keys.setSize(plugin.RowChunk_getKeys(c, keys));
		integer i := plugin.RowChunk_getKeys(c, keys);
		return keys;
	}

	/** Get a dictionary copy of the Row.
	 * @since 10.1
	 */
	action toDictionary() returns dictionary<string, any> {
		dictionary<string,any> d := {};
		string k;
		for k in getKeys() {
			try {
				d[k] := get(k);
			} catch(Exception e) { // ignore
				log "Ignoring key '"+k+"' in Row.toDictionary(); presumably an unsupported type." at DEBUG;
			}
		}
		return d;
	}

	/** Get the name of the Table that contains this Row. */
	action getTableName() returns string {
		return plugin.RowChunk_getTableName(c);
	}

	/** Get the name of the Store that contains this Row's Table. */
	action getStoreName() returns string {
		return plugin.RowChunk_getStoreName(c);
	}
}


/**
 * Sent to the application on every successful row commit in tables
 * the application has subscribed to.
 *
 * Supported in distributed stores only, and only for fields named in the 
 * schema (extra fields are not supported).
 *
 * Events are sent for every change, whether from the local or a
 * remote node, for tables where the subscribe method has been called.
 *
 * The old and new values are provided as sequences.  Access to previous
 * and new values are thus available if the driver and distmemstore
 * support it (and note the setting of rowChangedOldValueRequired); for
 * example:
 <pre>
<br/>	integer positionRowId := tbl.getFieldIndex("position");
<br/>	RowChanged rowChanged;
<br/>	on all RowChanged(storeName = STORE, 
<br/>	                  tableName = TABLE):rowChanged {
<br/>		// we handle things simply by treating an update as a remove followed by an insert:
<br/>		if (rowChanged.changeType = RowChanged.REMOVE or
<br/>		    rowChanged.changeType = RowChanged.UPDATE) {
<br/>			position := position - float.parse(rowChanged.oldFieldValues[positionRowId]);
<br/>		}
<br/>		if rowChanged.changeType = RowChanged.INSERT or
<br/>		   rowChanged.changeType = RowChanged.UPDATE {
<br/>			position := position + float.parse(rowChanged.newFieldValues[positionRowId]);
<br/>		}
<br/>		log "Position is now "+position.toString();
<br/>	}
 </pre>
 * @see Table#subscribeRowChanged() for subscribing to RowChanged events
 */
event RowChanged {
	/** Value for changeType when a row is added to a table. */
	constant integer INSERT := 1;

	/** Value for changeType when a row is removed from a table. */
	constant integer REMOVE := 2;

	/** Value for changeType when a row is modified in a table. */
	constant integer UPDATE := 3;

	/**
	 * One of INSERT, REMOVE, UPDATE for
	 * rows being added, removed, updated.
	 */
	integer changeType;

	/**
	 * Name of the store that the table is in.
	 */
	string storeName;

	/**
	 * Name of the table that the row is in.
	 */
	string tableName;

	/**
	 * The key value for the changed row.
	 */
	string key;

	/**
	 * Old values of the row, if available.
	 *
 	 * The old values of the row, in toString() format, in the
	 * order defined by the table's Schema.  For UPDATE
	 * changeTypes, this is only populated if the storeFactory
	 * bean property rowChangedOldValueRequired is true (the
	 * default value is provider-specific).
	 *
	 * For INSERT (or UPDATE if rowChangedOldValueRequired is
	 * false), this will be an empty sequence, otherwise it will
	 * have as many entries as there are fields in the schema.
	 *
	 * The field values can be recovered by using the parse method
	 * on the field's type
	 * (e.g. <tt>integer.parse(rc.oldFieldValues[i])</tt>),except
	 * for strings which are inserted without any escaping, so do
	 * not need to be parsed. 
	 *
	 * Use Table.getFieldIndex() to efficiently map a field name
	 * to an index in this sequence (although consider caching the
	 * index in a variable to avoid unnecessary lookups).
	 *
	 * @see Table#getFieldIndex() for mapping from field name to
	 * index.
	 */
	sequence<string> oldFieldValues;

	/**
	 * New values of the row.
	 *
 	 * The new values of the row, in toString() format, in the order defined 
	 * by the table's Schema.
	 *
	 * For REMOVE, this will be an empty sequence, otherwise it 
	 * will have as many entries as there are fields in the schema.
	 *
	 * The field values can be recovered by using the parse method
	 * on the field's type (e.g. <tt>integer.parse(rc.newFieldValues[i])</tt>), 
	 * except for strings which are inserted without any escaping, so do not 
	 * need to be parsed. 
	 *
	 * Use Table.getFieldIndex() to efficiently map a field name to an index 
	 * in this sequence (although consider caching the index in a 
	 * variable to avoid unnecessary lookups).
	 *
	 * @see Table#getFieldIndex() for mapping from field name to index. 
	 */
	sequence<string> newFieldValues;
	
	/** 
	 * Get a display string representing this event's change type. 
	 *
	 * @returns "INSERT", "REMOVE" or "UPDATE". 
	 */
	action getChangeTypeString() returns string {
		if changeType = INSERT {
			return "INSERT";
		} else if changeType = REMOVE {
			return "REMOVE";
		} else if changeType = UPDATE {
			return "UPDATE";
		} else {
			return "UNKNOWN:"+changeType.toString();
		}
	}
}

/**
 * Optionally sent to the application if the driver has detected that some of the RowChanged events may have been
 * dropped for a table the application has subscribed to.
 *
 * Supported in distributed stores only.
 *
 * @see Table#subscribeRowChanged() for subscribing to RowChanged and MissedRowChanges events
 */
event MissedRowChanges {
	/**
	 * Name of the store that the table is in.
	 */
	string storeName;

	/**
	 * Name of the table that has received a disconnection.
	 */
	string tableName;
}



/** Represents an iterator that can be used to step through each 
	Row of a Table in turn, making changes or reading data from the row. 
	
	@see Table#begin() Gets an iterator, beginning from the start of the table.
*/
event Iterator {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;

	/** Checks whether this Iterator has now reached the end of
		the Table. 
	
		You should check done() is not true before you call other Iterator 
		actions (except for appendKeys() and getKeys()).
	*/
	action done() returns boolean {
		return plugin.IteratorChunk_done(c);
	}

	/** Step this Iterator to the next row in the table.
	
		If there are no more rows the Iterator becomes done. 
		
		To avoid an error that will terminate the monitor instance, always 
		use done() to check that the iterator has not reached the end of the 
		table before calling this action. 		
	*/
	action step() {
		plugin.IteratorChunk_step(c);
	}
	
	/** Get the key for the row this Iterator is pointing at.
	
		To avoid an error that will terminate the monitor instance, always 
		use done() to check that the iterator has not reached the end of the 
		table before calling this action. 
	*/
	action getKey() returns string {
		return plugin.IteratorChunk_getKey(c);
	}

	/** Get the Row this Iterator is pointing at.
	
		It is possible that the row the iterator is pointing at is no longer 
		present. This can happen if another monitor deleted the row or table, 
		or cleared the table while the iterator was pointing at that row.

		If the requested row is no longer there, you receive a Row event that 
		represents a row in which all fields have default values and for which 
		Row.inTable() is false. This is the same result as if you call 
		Table.get() on a key that does not exist yet.
	
		To avoid an error that will terminate the monitor instance, always 
		use done() to check that the iterator has not reached the end of the 
		table before calling this action. 
	*/
	action getRow() returns Row {
		return Row(plugin.IteratorChunk_getRow(c));
	}

	/** Append to the specified sequence, keys for up to n consecutive
		rows of the Table, beginning where this Iterator is pointing.
	
		The iterator will be advanced. If it becomes
		done then fewer than n keys will be appended.
		
		@param seq The sequence which is to be updated with the keys from the 
		following n table rows. 
		@param n The number of keys to get and append to the sequence. 
	*/
	action appendKeys(sequence<string> seq, integer n) {
		integer start := seq.size();
		seq.setSize(start+n);
		seq.setSize(plugin.IteratorChunk_appendKeysImpl(c, seq, start));
	}

	/** Get the keys for up to n consecutive rows of the Table beginning
		where this Iterator is pointing.
	
		The iterator will be advanced. If it becomes
		done, a sequence of fewer than n keys will be returned.

		The first key in the returned sequence is the key of the row that the 
		iterator is pointing at when the action is called. When this action is 
		finished, the iterator is pointing at the row immediately beyond that 
		of the last key that was returned. 
		
		@param n The number of keys to get and append to the sequence. 
	*/
	action getKeys(integer n) returns sequence<string> {
		sequence<string> result := new sequence<string>;
		appendKeys(result, n);
		return result;
	}
}

/** Represents a collection of rows in a store, with a defined schema.
	
	A table consists of a series of rows, each identified by a key and
	containing other values with names and types according to the
	table's Schema.
	
	A table typically resides in memory, you can also store it on 
	disk if you want to, or a table can be stored on a distributed cache.
	
	@see Store#open() Tables exist within a named Store, which is used to 
		create and open tables. 
*/
event Table {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;


	/** Add the table Row with the specified key.
	
		On distributed stores, for performance reasons this action doesn't
		check if there is a Row already present in the the table with the
		specified key. To check if the Row is present in the store, use the
		Table.get() action.
		
		@param key The name/key uniquely identifying the row. 
		@returns An empty Row event.
	*/
	action add(string key) returns Row {
		return Row(plugin.TableChunk_add(c, key));
	}

	/** Get the table Row with the specified key. 
	
		If there is no row with the specified key, this action returns 
		without error, with a Row event that contains default values for the 
		fields in the row. A call to the Row.inTable() action returns false.
		
		@param key The name/key uniquely identifying the row. 
		@returns A Row event representing an atomic snapshot of the committed 
			data in the table when the action was called. 		
	*/
	action get(string key) returns Row {
		return Row(plugin.TableChunk_get(c,key));
	}
	
	/** Remove the specified row from the table. 
	
		If the row does not exist, this action does nothing.

		@param key The name/key uniquely identifying the row. 
	*/
	action remove(string key) {
		plugin.TableChunk_remove(c,key);
	}

	/** Change the row with the specified key by applying an action to it.
	
		It is possible for another context to commit changes to this row 
		between the time mutate() obtains a Row event to represent the row and 
		the time mutate() tries to commit the changes that result from 
		executing the specified action. In this situation, the MemoryStore 
		automatically calls the specified action again on the most recently 
		committed row content; therefore mutation actions must be designed to 
		cope with being called repeatedly without causing unwanted side 
		effects.
	
		@param name The name/key uniquely identifying the row. 
		@param a An action that (idempotently) performs the desired change to 
			the row. 
	*/
	action mutate(string key, action<Row> a) {
		Row row := get(key);
		boolean done := false;
		while not done { a(row); done := row.tryCommitOrUpdate(); }
	}

	/** Mutate all rows in the Table by applying the specified action.
	
		This can temporarily consume a lot of memory when called on a 
		relatively large table because the Correlator does no garbage 
		collection until action execution is complete. A few thousand rows are 
		unlikely to present a problem. Beyond that, it depends on how many 
		fields are in each row, how many rows are in the table, and how much 
		RAM is available.

		@param a An action that performs the desired change to 
			each row in the table. 
	*/
	action mutateAll(action<Row> a) {
		Iterator i := begin();
		while not i.done() {
			Row row := i.getRow();
			boolean done := false;
			while row.inTable() and not done {
				a(row); done := row.tryCommitOrUpdate();
			}
			i.step();
		}
	}

	/** Remove all rows from the table. */
	action clear() {
		plugin.TableChunk_clear(c);
	}

	/** Indicate whether or not a row with the specified key is present
		in the table.
	
		t.hasKey("foo") is a more efficient alternative to
		t.get("foo").inTable()
		
		@param key The name/key uniquely identifying the row. 
	*/
	action hasKey(string key) returns boolean {
		return plugin.TableChunk_hasKey(c,key);
	}

	/** Return an iterator to the beginning of the Table.
	*/
	action begin() returns Iterator {
		return Iterator(plugin.TableChunk_begin(c));
	}

	/** Returns a sequence that contains the keys for all the rows in this 
		table. 
		
		The keys are in an arbitrary order.
 	*/
	action getKeys() returns sequence<string> {
		Iterator i := begin();
		sequence<string> result := i.getKeys(plugin.TableChunk_size(c));
		// Clean up any residue if a race means we didn't get everything
		while not i.done() { i.appendKeys(result, 16); }
		return result;
	}

	/** Persist this table's committed changes back to stable storage, asynchronously.
	
		Note that any local changes to a Row that were not committed will not 
		be written to disk (see Row#commit()). 

		Only on-disk persistent stores can be persisted using this action. 
		It is not possible to call this method on Correlator-persistent tables 
		since all changes committed to such tables will be written to disk 
		automatically in the same transaction as changes to the state of 
		persistent EPL monitors. 
		
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action persist() returns integer {
		return plugin.TableChunk_persist(c,currentTime);
	}

	/** Enqueue an event for each row in the table, taken by parsing the string 
		data in the specified table field/column as an event string.
		
		The field must be of string type, and its value for every row should be 
		an Apama event string, in the same form that you would send to the 
		Correlator (e.g. "mypackage.MyEvent(123, [false,true])")

	
		This action is most likely to be useful when you are migrating from the 
		StateStore Correlator plug-in to the MemoryStore. In the StateStore 
		plug-in, persistent data re-entered the Correlator as sent events.
		
		This is only supported for non-distributed stores.
	
		@param fieldName The name of the table field whose values are event 
			strings that should be sent. 
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the column data for 
			the last row has been sent. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action enqueueColumn(string fieldName) returns integer {
		return plugin.TableChunk_enqueueColumn(c, fieldName);
	}

	/** Get the name of this Table. */
	action getTableName() returns string {
		return plugin.TableChunk_getTableName(c);
	}

	/** Get the name of the Store that contains this table. */
	action getStoreName() returns string {
		return plugin.TableChunk_getStoreName(c);
	}

	/**
	 * Subscribe to be notified of all successful commits in
	 * this table.
	 *
 	 * This is only supported for tables in a distributed store, 
	 * and only if the underlying provider supports this feature. 
	 *
	 * The monitor instance will be terminated with an error if this 
	 * action is called on a store that does not support it. 
	 *
	 * It is important to note that (due to the nature of distributed store 
	 * technology) there is no way to atomically subscribe to notifications 
	 * and get an initial snapshot of the table's contents, so 
	 * applications that perform an initial iteration over the table's contents 
	 * to initialize some state before subscribing are at risk of 
	 * double-counting any keys that are mutated after the subscription 
	 * and during the iteration/initialization process. 
	 *
	 * For tables that are relatively small (and fit entirely inside the 
	 * memory of a single Correlator), a common pattern for addressing the need 
	 * for a table snapshot to initialize state before subscribing is to 
	 * maintain a per-key dictionary of last-seen values, updated by both the 
	 * initial iteration and the RowChanged notification events; any RowChanged 
	 * event whose old value does not match the last-seen dictionary must be 
	 * ignored, to avoid double-counting changes. To save memory, entries from 
	 * the last-seen dictionary can be removed after the first RowChanged event 
	 * for that key. 
	 *
	 * For distributed stores and drivers that support it, the application
	 * may also receive MissedRowChanges events to signify that some unknown number
	 * of updates have been missed (typically due to a network disconnection
	 * between the client and the store)
	 *
	 * @returns A unique subscriptionId that can be passed to any instance of 
	 * this Table to unsubscribe.
	 * @see RowChanged The event sent whenever a row is modified.
	 * @see MissedRowChanges The event sent whenever a row is modified.
	 * @see Table#unsubscribe() Unsubscribe using this action. 
	 */
	action subscribeRowChanged() returns integer 
	{
		integer subscriptionId := integer.getUnique(); 
		plugin.TableChunk_subscribeRowChanged(c, subscriptionId);
		return subscriptionId;
	}
	
	/**
	 * Cancel a previous subscription.
	 *
	 * This is only supported for tables in a distributed store.
	 *
	 * If other monitors in this context have also subscribed,
	 * events will still be delivered until they have all unsubscribed.
	 * subscriptionId must be a value returned from a subscribeRowChanged() on 
	 * this table.
	 *
	 * @param subscriptionId Identifier for the subscription to remove, 
	 * returned by subscribeRowChanged().
	 */
	action unsubscribe(integer subscriptionId) 
	{ 
		plugin.TableChunk_unsubscribe(c, subscriptionId);
	}

	/**
	 * Return the index of a field.
	 *
	 * Returns what position in the Schema the specified field
	 * appears at. If a name that is not in Schema fieldName
	 * is passed in, the monitor instance will be terminated with an error.
	 *
	 * Using this action is more efficient that getting the same information 
	 * by using indexOf on the Schema.fields sequence. 
	 *
	 * @param fieldName A field name that exists in this table's Schema. 
	 */
	action getFieldIndex(string fieldName) returns integer 
	{ 
		return plugin.TableChunk_getFieldIndex(c, fieldName);
	}
}

/** Represents a store, which is a container for a uniquely named collection of 
	tables. 
	
	@see Storage Provides actions to prepare and open a Store. 
	@see Table Represents the tables in a Store. 
*/
event Store {
	/** @private*/ import "MemoryStorePlugin" as plugin;
	/** @private*/ wildcard chunk c;
	

	/** Prepare a table so that subsequent open calls for it will succeed.
	
		If the table already exists, the Schema provided to the prepare
		function must completely match the existing schema. If it does 
		not already exist, the Schema will be used to create the table.
	
		The function returns an id; once preparation is complete a
		Finished event with that id will be sent.
		
		This call is idempotent - if the table was already successfully 
		prepared, it will return success immediately.
		
		@param name A unique name that will be used to identify the new table.
		@param schema The schema identifying the fields of the new table.
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action prepare(string name, Schema schema) returns integer {
		return plugin.StoreChunk_prepare3(c, name, schema.fields.toString() + " " + schema.types.toString(), schema.fields, schema.types, schema.exposeMemoryView, schema.exposePersistentView, schema.memoryViewDisplayName, schema.memoryViewDescription, schema.persistentViewDisplayName, schema.persistentViewDescription, currentTime);
	}
	
	/** Prepare a table from a supplied type (a users Event) using the type name
		as the table name and the fields and field types as the schema.
		
		<code>
		integer id := Schema.prepareFromAny(new MyEventType);
		</code>
	 
		@param prototype Any type value to use as the table name and schema
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed.
		@see #prepare()
		@since 10.1
	*/
	action prepareFromAny(any prototype) returns integer {
		return prepare(prototype.getTypeName(), Schema.schemaFromAny(prototype));
	}

	/** Prepare a table from a type identified from the supplied type name.
		The type name should identify a users Event.

		<code>
		integer id := Schema.prepareFromTypeName("MyEventType");
		</code>
  	 
  		@param typeName The type name to use as the table name and schema.
  		@returns The unique identifier for this operation, which will be 
  			included in the Finished event sent after the operation is 
  			complete. 
  		@see Finished A Finished event will be sent when this asynchronous 
  			operation has completed.
  		@see #prepareFromAny()
  		@since 10.1
  	*/
	action prepareFromTypeName(string typeName) returns integer {
		return prepareFromAny(any.newInstance(typeName));
	}
	
	/** Indicate whether or not a Table with the specified name is
		present in the Store.
	
		@param name The unique table name to check for. 
		@returns True if it is safe to call open() on the specified table; false 
			if preparation failed or is still in progress. 
	*/
	action hasTable(string name) returns boolean {
		return plugin.StoreChunk_hasTable(c, name);
	}

	/** Open the specified table, once it has been prepared.
	
		It is an error to call this before a prepare call for the table
		has finished without error.
		
		@param name The name of the table to be opened, which must be the same 
			as the name used when the table was first prepared. 
		@see #prepare() This action must not be called until prepare has 
			completed successfully. 
	*/
	action open(string name) returns Table {
		return Table(plugin.StoreChunk_open(c,name));
	}

	/** Persist committed changes back to stable storage, asynchronously.
	
		Only on-disk persistent stores can be persisted using this action. 
		It is not possible to call this method on Correlator-persistent tables 
		since all changes committed to such tables will be 
		written to disk automatically in the same transaction as changes to 
		the state of persistent EPL monitors. 
		
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action persist() returns integer {
		return plugin.StoreChunk_persist(c,currentTime);
	}

	/** Create a backup of the Store.
	
		The backup is created in the specified file, which is
		overwritten if it already exists.
	
		Only persistent (on-disk) stores can be backed up. 
		
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	action backup(string filename) returns integer {
		return plugin.StoreChunk_backup(c, filename);
	}

	/** Get the name of this Store. */
	action getStoreName() returns string {
		return plugin.StoreChunk_getStoreName(c);
	}
}

/** MemoryStore factory interface for creating Store event objects. 

	There are several different types of Store supported by MemoryStore:
	<ul>
	<li>In-memory only (no persistence)</li>
	<li>Persistent (using a specified database file on disk; 
		committed changes go to disk when the persist() action is called)</li>
	<li>Correlator-persistent (using the Correlator's integrated data store; 
		committed changes go to disk periodically when the Correlator takes a 
		snapshot of persistent monitor state and persists the results). </li>
	<li>Distributed (Using a distributed cache technology to share and access
		data across multiple distributed nodes). </li>
	</ul>
	Correlator-persistent stores are only available if Correlator persistence 
	has been enabled. Non-persistent monitors may use any type of store, but 
	a monitor marked as 'persistent' may ONLY access Correlator-persistent 
	stores.

	To use the MemoryStore, create a monitor field (or variable) to hold the 
	Storage factory event, and use one of the prepare* actions to 
	asynchronously get a Store of the desired type ready for use, and give it 
	a unique name. Once the store has been prepared, use the open(name) action 
	to get a Store event that can be used to interact with the store. 
	
	e.g.<pre>
	<br/>using com.apama.memorystore.Storage; 
	<br/>using com.apama.memorystore.Store; 
	<br/>using com.apama.memorystore.Finished; 
	<br/>
	<br/>monitor Test { 
	<br/>	Storage storage; 
	<br/>	Store store; 
	<br/>
	<br/>	action onload() { 
	<br/>		integer id := storage.prepareOrCreate("storename", "/tmp/example.dat"); 
	<br/>		Finished f; 
	<br/>		on Finished(id=id):f
	<br/>		{
	<br/>			if not f.success { log "Store creation failed: "+f.status at ERROR; die; } 
	<br/>			store := storage.open("storename");
	<br/>			...
	<br/>		}
	<br/>	} 
	<br/>}
	</pre>

	@see Store The purpose of the Storage event is to prepare and open stores. 
	@see #prepareOrCreate() The most commonly used action for preparing a 
		persistent Store. 
	@see #open() Once a store has been prepared it can be opened. 
*/
event Storage {
	/** @private*/ import "MemoryStorePlugin" as plugin;

	/** Prepare an in-memory read-write Store 
		to be opened and used by the application.
	
		@param name A unique name identifying this Store. 
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	static action prepareInMemory(string name) returns integer {
		return plugin.prepareInMemory(name);
	}

	/** Prepare a distributed store (e.g. distributed cache) 
		to be opened and used by the application.
	
		@param name A unique name identifying this Store, 
			which also specifies the id of its configuration bean in the XML 
			configuration file. This name should not contain spaces.
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 

	*/
	static action prepareDistributed(string name) returns integer {
		return plugin.prepareDistributed(name);
	}

	/** Indicates whether configuration for the given distributed
	 	store name exists. 

		Returning false indicates that a prepareDistributed of
		the store name will definitely fail.  True indicates
		it may succeed, but is not a guarantee of success.
		Does not actually connect to the distributed store.

		@returns false if prepareDistributed for the given
			store name will definitely fail
	*/
	static action hasDistributedStore(string name) returns boolean {
		return plugin.hasDistributedStore(name);
	}


	/** Prepare a Correlator-persistent read-write Store 
		to be opened and used by the application.
		
		All committed changes made to a Correlator-persistent store are 
		persisted to disk automatically whenever the Correlator takes a 
		snapshot of the Correlator persistent application state. 
		Because the Correlator determines when to persist its state, you 
		cannot explicitly request persistence for a Correlator-persistent 
		store or any tables it contains.

		Attempts to create a Correlator-persistent store in a Correlator that 
		does not have persistence enabled will result in an error that will 
		terminate the monitor instance. 
	
		@param name A unique name identifying this Store. 
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/
	static action prepareCorrelatorPersistent(string name) returns integer {
		return plugin.prepareCorrelatorPersistent(name);
	}

	/** Prepare a persistent read-write Store associated with an existing 
		database file on disk. 
	
		The specified file must exist and must have been created by the 
		MemoryStore. If the specified file does not exist, or cannot be opened 
		for read-write, the Finished event will indicate failure. 
		
		@param name A unique name identifying this Store. 
		@param filename The path of the database file holding the persistent 
			store. If a relative path is specified, it is relative to the 
			directory that contains the associated Apama Studio project
			(i.e. the Correlator working directory). 
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/			
	static action prepare(string name, string filename) returns integer {
		return plugin.prepare(name, filename);
	}

	/** Prepare a persistent read-write Store associated with a 
		database file on disk, which will be created if it does not exist 
		already. 
	
		@param name A unique name identifying this Store. 
		@param filename The path of the database file holding the persistent 
			store. If a relative path is specified, it is relative to the 
			directory that contains the associated Apama Studio project
			(i.e. the Correlator working directory). 
			The parent directory of the specified file must already exist. 
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/			
	static action prepareOrCreate(string name, string filename) returns integer {
		return plugin.prepareOrCreate(name, filename);
	}

	/** Prepare a persistent read-only Store associated with an existing 
		database file on disk. 
	
		@param name A unique name identifying this Store. 
		@param filename The path of the database file holding the persistent 
			store. If a relative path is specified, it is relative to the 
			directory that contains the associated Apama Studio project
			(i.e. the Correlator working directory). 
		@returns The unique identifier for this operation, which will be 
			included in the Finished event sent after the operation is 
			complete and it becomes safe to call open() on this store. 
		@see Finished A Finished event will be sent when this asynchronous 
			operation has completed. 
	*/			
	static action prepareReadOnly(string name, string filename) returns integer {
		return plugin.prepareReadOnly(name, filename);
	}

	/** Indicate whether or not a Store with the specified name has been 
		prepared already. 
	
		@param name A unique name identifying this Store. 
		@returns True if it is safe to call open() on the specified store; 
			false if preparation failed or is still in progress.
	*/
	static action hasStore(string name) returns boolean {
		return plugin.hasStore(name);
	}

	/** Open a named Store that has already been prepared, ready for use by 
		this monitor instance.
	
		Every monitor instance should prepare and open the stores it needs. 
		Multiple monitor instances can have the same table open at the same 
		time.

		It is an error to call open() before a prepare call for the table
		has finished without error.
		
		Note that opening a store will not immediately bring all that store's 
		tables into memory, this only happens when each individual table is 
		itself prepared and opened. 
		
		A persistent monitor can access only Correlator-persistent stores. 
		If a persistent monitor tries to open any other type of store 
		(e.g. in-memory, on-disk or distributed) the monitor instance 
		will terminate with an error.
		
		@param name A unique name identifying this Store. 
	*/
	static action open(string name) returns Store {
		return Store(plugin.open(name));
	}
}
 0000003c C:\SoftwareAG101\Apama\monitors\data_storage\MemoryStore.mon
MONF 00012475 package com.apama.scenario;

/**
 * This file contains the shared event definitions that are generic across 
 * all Scenarios.  
 *
 * WARNING: 
 *    The event definitions contained in this file form an internal protocol 
 *    and may change between software releases.
 *
 * Notes:
 * 1) The Event definitions contained in this file MUST be considered
 *    as an internal implementation of the communications protocol
 *    between the Apama client API and an Apama server.  As such
 *    these event definitions MUST NOT be considered "stable" and are 
 *    subject to change in any future software release.
 *
 *    The ONLY supported public APIs to the Scenario Service are the 
 *    Java client API (in the com.apama.services.scenario package) and the 
 *    .NET client API (in the Apama.Services.Scenario namespace).  
 *    Customers should not attempt to interface at the event or 
 *    EPL layer. Some events have been changed over time (as 
 *    noted here).
 *
 * 2) Most events now contain an initial field called "scenarioId". This string 
 *    uniquely identifies a scenario inside the correlator, and is used as 
 *    the package name, in several events, and for making up a part of the 
 *    data and control channel names.
 *
 * 3) Events that are intended to be used in a request-response pattern contain
 *    a "messageId" field.  The value of this field must be copied from the 
 *    request event into the response event. The mechanism allows clients to 
 *    match up request-response pairs.
 *
 *
 * $Copyright(c) 2005-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013-2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 *
 * $Revision: 284562 $
 */

/**
 * Request that a new instance of a specific scenario is created.
 *
 * See also: Created(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Create {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	string owner;                        // the owner (user) of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}

/**
 * Notifies all interested clients that a new instance of a specific 
 * scenario has been created. 
 * The event provides the owner (user), initial state, and initial values for 
 * all input fields and all output fields.
 *
 * See also: Create()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Created { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Notifies the interested clients of child scenarios created from
 * a parent scenario.
 *
 * Direction: Internal in the correlator
 *
 * Channel: <none>
 */
event ParentChildRelationship {
	string parentScenarioId;
	integer parentScenarioInstanceId;
	string childScenarioId;
	integer childScenarioInstanceId;
}


/**
 * Request that a specific instance of a specific scenario is edited (the input 
 * field values are changed).
 *
 * See also: Edited(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Edit { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been edited (the input field values have changed).
 *
 * See also: Edit()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Edited { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Request that a specific instance of a specific scenario is deleted.
 *
 * See also: Deleted(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Delete {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been deleted.
 *
 * See also: Delete()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Deleted {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Indicates that a specific instance of a specific scenario has died.
 * This is sent as a result of a scenario instance use of MonitorScript ondie.
 * This occurs for any of deleting a running scenario, a scenario failing, or 
 * entering the end state.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event InstanceDied {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Contains updated scenario instance output fields.
 * Note that this is the ONLY event type that is sent on the 
 * "<scenarioId>.Data" channel.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Update { 
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	float timeStamp;                     // the time of the update (seconds since epoch)
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * A general Acknowledgement event that is the "response" to various "request"
 * events such as Create, Edit, Delete.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event Acknowledge { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the id of the scenario instance
	boolean success;                     // boolean indication of success
	sequence<string> outputFieldValues;  // sequence of the OUTPUT field values in string form, 
	                                     //   or an empty sequence if success = false
}


/**
 * Indicates that a specific instance of a specific scenario has changed 
 * state, where valid states include "ENDED", "FAILED", "RUNNING".
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event StateChange { 
	string scenarioId;                   // the unique name of the scenario.
	integer scenarioInstanceId;          // the ID of the scenario instance.
	string state;                        // the new state.
}


/**
 * Request that each scenario loaded in the correlator send its meta
 * information out on the supplied channel. When all scenarios have
 * sent out this information, a final RequestScenariosDone event will
 * be sent on the same channel.
 *
 * As soon as this event is received, a RequestScenariosAck will be
 * sent on the same channel so client can stop resending the RequestScenarios
 * event.
 *
 * See also: Scenario, RequestScenariosDone, RequestScenariosAck
 *
 * Direction: From the client to the correlator.
 *
 * Response: Scenario() from each loaded scenario.
 */
event RequestScenarios { 
	// renamed for clarity - was Request
	string channel;                      // Name of the private response channel.
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Scenario events in response
 * to a RequestScenarios event.
 * 
 * See also: RequestScenarios, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosDone {}

/* This is a simple ack event that is sent by the correlator to indicate the
 * RequestScenarios event is received and the request is being processed
 *
 * See also: RequestScenarios
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosAck {}

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the supplied channel. When all instances for the scenario have been 
 * sent out, a final RequestInstancesDone event will be sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannel { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
}

/**
 * Request that each instance for the specified user of the specified scenario
 * send an Instance event out on the supplied channel. When all instances for
 * the scenario have been sent out, a final RequestInstancesDone event will be 
 * sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannelByUser { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	string owner;                        // the username to filter by
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Instance events in response
 * to a RequestInstancesInternal event.
 * 
 * See also: RequestInstancesInternal, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event RequestInstancesDone {
	string scenarioId;                   // Identifier of the scenario for instances were returned. 	
	integer messageId;                   // the unique message ID (for request-response matching)
}


/**
 * Describes the meta-information about a scenario that is loaded in the 
 * correlator.
 * 
 * See also: RequestScenarios, RequestScenariosDone, ScenarioUnloaded
 * 
 * Direction: From correlator to client.
 *
 * Channel:   1) com.apama.scenario to broadcast when loaded.
 *            2) A unique private channel as specified by the client in a 
 *               RequestScenarios event.
 *
 * This event has gained the executionMode field in Apama 4.2
 */
event Scenario {
	string scenarioId;                   // unique identifier for Scenario, e.g. Scenario_statistical$002darbitrage
	string displayName;                  // user-specified name for Scenario, e.g. statistical-arbitrage
	string description;                  // description of the Scenario
	sequence<string> inputNames;         // input parameter names
	sequence<string> inputTypes;         // input parameter types
	sequence<string> inputConstraints;   // input parameter contraints
	sequence<string> inputDefaults;      // input parameter default values
	sequence<string> outputNames;        // output parameter names
	sequence<string> outputTypes;        // output parameter types
	integer executionMode;               // 0 = serial, 1 = parallel, 2 = parallel child. New as of 4.2
	dictionary<string, string> extraParams; // Additional parameters
}



/**
 * Indicates that a specific Scenario definition is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event ScenarioUnloaded { 
	string scenarioId;                   // the unique name of the scenario
}

/**
 * Provides a dump of the current state of a scenario instance.
 * The event definition is identical to the Created event, and includes the 
 * owner (user), initial state, and current values for all input fields and 
 * all output fields.
 *
 * Instance events are sent in response to RequestInstancesOnChannel event 
 * and the deprecated RequestInstancesInternal event; 
 *
 * See also: RequestInstancesOnChannel, RequestInstancesDone, RequestInstancesInternal
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event Instance {
	string scenarioId;                   // the unique name of the scenario. 
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}


/**
 * Indicates this shared MonitorScript has been loaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when loaded.
 */
event ScenarioServiceLoaded { 
}

/**
 * Indicates this shared MonitorScript is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when unloaded.
 */
event ScenarioServiceUnloaded { 
}


/**
 * Set the period over which updates will be queued and coalesced before being
 * sent out on the data channel. Defaults to zero, which means they won't be
 * queued. If it is negative then we won't send any updates on the data channel.
 * This event is deprecated and the ConfigureUpdates event should be used 
 * instead (see below)
 */
event SetThrottlingPeriod {
	float period;   // The period in seconds. Default zero.
}


/**
 * Configures how updates are sent from scenarios.
 * Each scenario is controlled by two configurations - a global default,
 * and an optional per scenario configuration.  The per scenario
 * configuration takes precedence over the global default.
 * The configuration is made up of a number of entries in 
 * the configuration dictionary. The ConfigureUpdate event 
 * is merged into any previous configuration.
 *
 * Global configuration can be modified by specifying an empty string 
 * for scenarioId, and empty values remove values.
 */
event ConfigureUpdates {
	/** Specifies the scenario the configuratio will apply to, or use 
		empty string "" to specify a global default. 
	*/
	string scenarioId;
	/** 
	 * A set of the configurations modified by this event
	 * the key and meaning is one of:
	 * sendThrottled - boolean - whether to send Updates to the 
	 *                           Throttled (.Data) channel (default=true)
	 * throttlePeriod - float - period with which to send Updates. 
	 *                          0.0 means updates are not throttled - 
	 *                          every update is sent on the Throttled 
	 *                          channel. (default=0.0)
	 * sendRaw - boolean - whether to send Updates on the Raw channel 
	 *                     (.Raw) (default=true)
 	 * sendThrottledUser - boolean - whether to send Updates to the 
	 *                     throttled filtered (.Data:username) channel
	 *                     (default=false)
 	 * sendRawUser - boolean - whether to send Updates to the Raw 
	 *                     channel (.Raw:username) (default=false)
	 * routeUpdate - boolean - whether to route Update (and Edited, Deleted) events.
	 * An empty value removes that entry from the configuration
	 */
	dictionary<string,string> configuration;
}

/**
 * Immediately flushes to receivers any scenario Update events that were 
 * waiting for the next throttling period before being sent. 
 * 
 */
event SendQueuedUpdatesNow {
	
}

/* ==========================================================================
 * The following describes INTERNAL event definitions that should not be sent 
 * into the correlator, nor relied upon.
 * ==========================================================================
 */

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the scenario Data or Raw channel. When all instances for the scenario
 * have been sent out, a final RequestInstancesDone event will be sent on the 
 * same channel.
 *
 * See also: Instance, RequestInstancesDone, RequestInstancesOnChannel, RequestInstancesOnChannelByUser
 *
 * Direction: From the ScenarioService to the scenario
 *
 * Response: Instance() from each scenario instance, RequestInstancesDone when finished.
 */
event RequestInstancesInternal { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	boolean internal;                    // if true, events should be routed/ send-to'd the main context
	string owner;                        // owner filter (optional)
	boolean ownerFilter;                 // whether to filter by owner
}

/**
 * A scenario has finished running, but is still discoverable.
 * (i.e. entered end state or failed - but not deleted).
 * Note that this event contains the state as of the last
 * Update/ Edited event - i.e. if an action modified an output variable 
 * and then caused the scenario to fail, the prior modification
 * would not be reflected in this event.
 *
 * This event contains sufficient information for discovery of the
 * scenario instance later
 * 
 * Direction: from scenarios to the ScenarioService sub-monitor (spawned per scenario)
 */
event ScenarioFinished {
	string scenarioId;                   // Identifier of the scenario which has failed. 
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}
/**
 * Only used internally to tell all the scenarios to start routing their
 * meta data (Scenario). It is followed by a sweeper FinishedScenarioRecovery
 * event which indicates that all the scenarios have reported in.
 */
event StartScenarioRecovery {}

/**
 * Sweeper event to indicate that scenario recovery is done. Only used internally.
 */
event FinishedScenarioRecovery {}

/**
 * Trigger discovery of a parallel scenario. Sent from a sub-monitor of
 * ScenarioService to RequestInstancesHandler to create a new sub-monitor.
 */
event RequestInstancesParallel {
	RequestInstancesInternal request;          // the original request event
	dictionary<integer, context> instances;    // all scenario instances and their running context
	integer highestInstanceId;                 // the highest scenarioInstanceId listed in instances (or more accurately, the highest when discovery started)
}

/**
 * Discovery protocol of a parallel scenario. Sent from a scenario instance
 * to RequestInstancesHandler.
 */
event RequestInstancesParallelDone {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}

/**
 * Notification of a new scenario instance
 */
event ParallelStarting {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner of the scenario instance
	context runningCtx;                  // the context the scenario is running in
}

/**
 * Get the current configuration for a given scenario and the default configuration
 */
event GetConfiguration {
	string scenarioId;                   // the unique name of the scenario
}

/**
 * The current configuration for a given scenario and the default configuration
 * @see ConfigureUpdates
 */
event Configuration {
	string scenarioId;                        // the unique name of the scenario
	dictionary<string, string> defaults;      // the global defaults
	dictionary<string, string> configuration; // the scenario configuration (takes precedence)
}


/**
 * An operation has completed. Sent from parallel scenarios to the main context.
 */
event OperationCompleted {
	string scenarioId;
	integer scenarioInstanceId;
	integer messageId;
}

/**
 * Notification that a scenario has loaded a ConfigureUpdates event
 */
event ScenarioProcessedUpdates {
	string scenarioId;
}

/**
 * Request all configuration
 */
event GetAllConfiguration {
	integer requestId;
}

/** 
 * Response all configuration
 */
event AllConfiguration {
	integer requestId;
	dictionary<string, string> defaultConfig;
	dictionary<string, dictionary<string, string> > configurations;
}


/**
 * Library of utility actions
 */
event ScenarioServiceLibrary {

	/**
	 * Get the control channel for a scenario Id. This channel
	 * is always enabled (uses an event set scenario ID)
	 */
	static action getControlChannel(string scenarioId) returns string
	{
		return scenarioId+".Control";
	}
	/**
	 * Get the data channel for a scenario ID. This channel 
	 * is enabled by the sendThrottled configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	static action getDataChannel(string scenarioId) returns string
	{
		return scenarioId+".Data";
	}
	/**
	 * Get the raw channel for a scenario ID. This channel
	 * is enabled by the sendRaw configuration key.
	 */
	static action getRawChannel(string scenarioId) returns string
	{
		return scenarioId+".Data.Raw";
	}
	/**
	 * Get the data channel for a scenario Id. This channel 
	 * is enabled by the sendThrottledUser configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	static action getDataUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	/**
	 * Get the raw channel for a scenario Id. This channel
	 * is enabled by the sendRawUser configuration key.
	 */
	static action getRawUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	
	/**
	 * Merge configuration. Any entries in updates overwrite entries in configuration.
	 * An empty string value removes the value.
	 * @see ConfigureUpdates
	 */
	static action mergeConfiguration(dictionary<string, string> updates, dictionary<string, string> configuration) {
		string k;
		for k in updates.keys() {
			configuration[k]:=updates[k];
			if updates[k]="" {
				configuration.remove(k);
			}
		}
	}
	
	// implementation note: the defaults for sendThrottled, sendRaw, throttlePeriod, etc are in the following actions:
	/**
	 * Get the sendThrottled value from the given configuration
	 * @see ConfigureUpdates
	 */
	static action getSendThrottled(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottled", "true");
		return c = "true";
	}

	/**
	 * Get the sendThrottledUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	static action getSendThrottledUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottledUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the sendRaw value from the given configuration
	 * @see ConfigureUpdates
	 */
	static action getSendRaw(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRaw", "true");
		return c = "true";
	}
	
	/**
	 * Get the sendRawUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	static action getSendRawUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRawUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the throttlePeriod value from the given configuration
	 * @see ConfigureUpdates
	 */
	static action getThrottlePeriod(dictionary<string,string> defaults, dictionary<string,string> config) returns float {
		string c:=getConfig(defaults, config, "throttlePeriod", "0.0");
		return float.parse(c);
	}
	
	/**
	 * Get the routeUpdate value from the given configuration
	 * @see ConfigureUpdates
	 */
	static action getRouteUpdate(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "routeUpdate", "false");
		return c = "true";
	}
	

	/**
	 * Get the specified key from the configuration dictionaries, reverting to the default 
	 * if none specified.
	 */
	static action getConfig(dictionary<string,string> defaults,
	                 dictionary<string,string> config, 
	                 string key, string _default) returns string {
		if config.hasKey(key) {
			return config[key];
		}
		if defaults.hasKey(key) {
			return defaults[key];
		}
		return _default;
	}

	static action configurationManager(dictionary<string, string> defaultConfig, dictionary<string, dictionary<string, string> > configurations) {
		// the recognised ConfigureUpdates configuration keys, as above:
		dictionary<string,boolean> KNOWN_CONFIG_KEYS := {"sendThrottled":true, "throttlePeriod":false,
		 "sendRaw":true, "sendThrottledUser":true, "sendRawUser":true, "routeUpdate":true};

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		ConfigureUpdates cu;
		on all ConfigureUpdates():cu {
			string key;
			for key in cu.configuration.keys() {
				if not KNOWN_CONFIG_KEYS.hasKey(key) {
					log "Unrecognized configuration property "+key+" in event "+cu.toString() at WARN;
				}
			}
			if cu.scenarioId = "" {
				mergeConfiguration(cu.configuration, defaultConfig);
				log "Received "+cu.toString()+" : defaults applicable to all scenarios" at INFO;
			} else {
				if not configurations.hasKey(cu.scenarioId) {
					configurations.add(cu.scenarioId, new dictionary<string,string>);
				}
				mergeConfiguration(cu.configuration, configurations[cu.scenarioId]);
				on ScenarioProcessedUpdates(cu.scenarioId) -> completed ConfigureUpdates(scenarioId=cu.scenarioId) {
					log "Received "+cu.toString()+" : applied to scenario" at INFO;
				}
				on completed ConfigureUpdates(scenarioId=cu.scenarioId) and not ScenarioProcessedUpdates(cu.scenarioId) {
					log "Received "+cu.toString()+" : for scenario that is not yet defined" at INFO;
				}
			}
		}

		GetConfiguration getConfig;
		on all GetConfiguration():getConfig {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(getConfig.scenarioId) {
				config:=configurations[getConfig.scenarioId];
			}
			route Configuration(getConfig.scenarioId, defaultConfig, config);
		}	
		GetAllConfiguration gac;
		on all GetAllConfiguration():gac {
			route AllConfiguration(gac.requestId, defaultConfig, configurations);
		}
	}
		
}

event CallbackHelper {
	sequence<action<> > callbacks;
	action callback() {
		action<> c;
		for c in callbacks {
			c();
		}
	}
}



/**
 * Base event for tracking configuration for a given scenario
 */
event ScenarioServiceUpdaterBase {
	// these are internal and should not be set by users
	string scenarioId;
	dictionary<string,string> defaultConfig;
	dictionary<string,string> config;
	boolean sendThrottled;
	boolean sendRaw;
	boolean sendAny;
	boolean emitAny;
	boolean sendThrottledUser;
	boolean sendRawUser;
	boolean routeUpdate;
	float throttlePeriod;
	float throttleStart;
	sequence<listener> listeners;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 * @param sId the scenarioId
	 */
	action init(string sId, action<> cb_onUpdate) {
		scenarioId:=sId;
		controlChannel := ScenarioServiceLibrary.getControlChannel(scenarioId);
		rawChannel := ScenarioServiceLibrary.getRawChannel(scenarioId);
		dataChannel := ScenarioServiceLibrary.getDataChannel(scenarioId);
		route GetConfiguration(scenarioId);
		Configuration c;
		listener l:=on Configuration(scenarioId=scenarioId):c {
			config := c.configuration;
			defaultConfig := c.defaults;
			configurationUpdated();
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Listen for further configuration changes.
	 * @param cb_onUpdate callback upon configuration having been updated
	 */	
	action listenToConfigureUpdates(action<> cb_onUpdate) {
		ConfigureUpdates cu;
		listener l:=on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenarioId):cu {
			if(cu.scenarioId != "") {
				route ScenarioProcessedUpdates(cu.scenarioId);
			}
			onConfigureUpdates(cu);
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Called when new ConfigureUpdates event available
	 * @param sId the scenarioId
	 */
	action onConfigureUpdates(ConfigureUpdates cu) {
		if cu.scenarioId = "" {
			ScenarioServiceLibrary.mergeConfiguration(cu.configuration, defaultConfig);
		} else {
			ScenarioServiceLibrary.mergeConfiguration(cu.configuration, config);
		}
		configurationUpdated();
	}
	
	/**
	 * Called when the configuration should be re-parsed.
	 * @param sId the scenarioId
	 */
	action configurationUpdated() {
		sendThrottled:=ScenarioServiceLibrary.getSendThrottled(defaultConfig, config);
		sendThrottledUser:=ScenarioServiceLibrary.getSendThrottledUser(defaultConfig, config);
		if sendThrottled or sendThrottledUser {
			throttlePeriod:=ScenarioServiceLibrary.getThrottlePeriod(defaultConfig, config);
			if(throttlePeriod < 0.0) {
				sendThrottled:=false;
				sendThrottledUser:=false;
			}
			throttleStart:=currentTime;
		}
		sendRaw:=ScenarioServiceLibrary.getSendRaw(defaultConfig, config);
		sendRawUser:=ScenarioServiceLibrary.getSendRawUser(defaultConfig, config);
		routeUpdate:=ScenarioServiceLibrary.getRouteUpdate(defaultConfig, config);
		sendAny:= sendRaw or sendThrottled or routeUpdate or sendRawUser or sendThrottledUser;
		emitAny:= sendRaw or sendThrottled or sendRawUser or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the throttled (Data) channel
	 */
	action isSendThrottled() returns boolean {
		return sendThrottled or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the raw channel
	 */
	action isSendRaw() returns boolean {
		return sendRaw or sendRawUser;
	}

	action doEmit(string emitted, string owner) {
		if sendRaw {
			emit emitted to rawChannel;
		}
		if sendThrottled {
			emit emitted to dataChannel;
		}
		if sendRawUser {
			emit emitted to ScenarioServiceLibrary.getRawUserChannel(rawChannel, owner);
		}
		if sendThrottledUser {
			emit emitted to ScenarioServiceLibrary.getDataUserChannel(dataChannel, owner);
		}
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		listener l;
		for l in listeners {
			l.quit();
		}
	}
}


/**
 * Utility event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per instance
 * (e.g. Scenarios)
 * 
 * This event also uses a callback to get the updates (supplied in
 * instanceInit). If the scenario is configured to only send throttled 
 * updates, the callback is only called when the throttling period 
 * determines an update should be sent - thus, the scenario does not
 * need to generate the output sequence<string> except when needed,
 * which can improve performance in such a configuration.
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 */
event ScenarioServiceUpdaterSingleInstance {
	// these are internal and should not be set by users
	string scenarioId;
	integer scenarioInstanceId;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean havePending;
	float latestUpdate;
	action<> returns sequence<string> getUpdate;
	Update update;
	boolean needUpdate;
	context mainContext;
	string owner;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 */
	action init(string sId) {
		init_cb(sId, _noopAction);
	}
	
	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario.
	 * cb_init is called when initialisation is complete
	 */
	action init_cb(string sId, action<> cb_init) {
		base.init(sId, cb_init);
		scenarioId:=sId;
		controlChannel := ScenarioServiceLibrary.getControlChannel(scenarioId);
		rawChannel := ScenarioServiceLibrary.getRawChannel(scenarioId);
		dataChannel := ScenarioServiceLibrary.getDataChannel(scenarioId);
		base.listenToConfigureUpdates(_noopAction);
		mainContext:=context.current();
	}

	action _noopAction() {
	}
	

	/**
	 * Called by monitor after spawn
	 * Will maintain configuration for this scenario, and update listeners appropriately.
	 * @param getUpdateCallback a callback to get the latest outputFieldValues - may be called at any time, must 
	 *        always return a consistent set of outputs
	 */
	action instanceInit(integer id, action<> returns sequence<string> getUpdateCallback, string _owner) {
		scenarioInstanceId:=id;
		owner:=_owner;
		getUpdate:=getUpdateCallback;
		update.scenarioId:=scenarioId;
		update.scenarioInstanceId:=scenarioInstanceId;
		base.listenToConfigureUpdates(_configurationUpdated);
		_configurationUpdated();
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdate();
		}
		base.listeners.append(l);
	}

	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  
	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated() {
		if base.isSendThrottled() {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) {
				if havePending {
					_setupThrottleListener();
				}
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener() {
		if base.throttlePeriod > 0.0 {
			float offset:=currentTime-base.throttleStart;
			float t:=((offset/base.throttlePeriod).floor()+1).toFloat();
			throttlingListener:=on wait((t*base.throttlePeriod)-offset) {
				_sendThrottledUpdate();
			}
		} else {
			_sendThrottledUpdate();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdate() {
		if not havePending {
			return;
		}
		if needUpdate {
			update.outputFieldValues:=getUpdate();
			update.timeStamp:=latestUpdate;
			needUpdate:=false;
		}
		if base.sendThrottled {
			send update to dataChannel;
		}
		if base.sendThrottledUser {
			send update to ScenarioServiceLibrary.getDataUserChannel(dataChannel, owner);
		}
		havePending:=false;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		if havePending {
			_sendThrottledUpdate();
			throttlingListener.quit();
		}
	}	

	/**
 	 * Called when a new update is available.
	 */
	action newUpdateAvailable() {
		needUpdate:=true;
		latestUpdate:=currentTime;
 		if base.sendRaw or base.routeUpdate {
			if needUpdate {
				update.outputFieldValues:=getUpdate();
				update.timeStamp:=currentTime;
				needUpdate:=false;
			}
			if base.sendRaw {
				send update to rawChannel;
			}
			if base.sendRawUser {
				send update to ScenarioServiceLibrary.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate {
				route update;
			}
		}
		if base.isSendThrottled() and not havePending {
			havePending:=true;
			_setupThrottleListener();
		}
	}
	
	/**
 	 * Called to send a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, getUpdate());
		if base.routeUpdate {
			route ack;
		}
		if base.emitAny {
			send ack to controlChannel;
		}
	}
				
	/**
 	 * Called to send a new Nak event.
	 */
	action emitNack(integer messageId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate {
			route nack;
		}
		if base.emitAny {
			send nack to controlChannel;
		}
	}
	
	/**
 	 * Called to send a new Created event.
	 */
	action emitCreated(integer messageId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny {
				base.doEmit(created.toString(), owner);
			}
		}
	}
	
	/**
 	 * Called to send a new Edited event.
	 */
	action emitEdited(integer messageId, sequence<string> inputVariables) {
		flushPending();
		if base.sendAny {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, getUpdate());
			if base.routeUpdate {
				route edited;
			}
			if base.emitAny {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId) {
		if(context.current().getId()!=mainContext.getId()) {
			send OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to send a new Deleted event.
	 */
	action emitDeleted(integer messageId) {
		flushPending();
		if base.sendAny {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate {
				route deleted;
			}
			if base.emitAny {
				base.doEmit(deleted.toString(), owner);
			}
		}
		throttlingListener.quit();
		notifyInstanceDied();
	}

	/**
 	 * Called to send an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied() {
		flushPending();
		if base.sendAny {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() {
				route iDied;
			}
		}
		throttlingListener.quit();
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied() {
		if mainContext.getId()!=context.current().getId() {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			
			// give a chance for anyone monitoring this from its own context 
			// to handle the InstanceDied before the main context
			if base.routeUpdate {
				route InstanceDied(scenarioId, scenarioInstanceId);
			}

			send iDied to mainContext;
		}
	}
	
	/**
 	 * Called to send a new StateChange event.
	 */
	action emitStateChange(string state) {
		flushPending();
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() {
			send stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to send an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal {
			if mainContext.getId() != context.current().getId() {
				send instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) {
				send instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() {
			send RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}

	/**
 	 * Called when the instance has failed.  input and output are the input
 	 * and output variables as at the last Update/ Edited point.
	 */
	action finished(string state, string owner, sequence<string> input, sequence<string> output) {
		ScenarioFinished scenFinished:=ScenarioFinished(scenarioId, scenarioInstanceId, owner, state, input, output);
		if mainContext.getId() != context.current().getId() {
			send scenFinished to mainContext;
		} else {
			route scenFinished;
		}
	}
	
}


/**
 * Utility event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per scenario,
 * but not per instance. (e.g. ScenarioService, DataViewService)
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 * 
 * Note that this updater only honours sendThrottledUser changes at the next throttling period
 * (it does not record the owner if sendThrottledUser is not true)
 */
event ScenarioServiceUpdaterMultipleInstances {
	// these are internal and should not be set by users
	string scenarioId;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean currentlySendingThrottledUser;
	dictionary<integer, Update> updates;
	dictionary<integer, string> owners;
	context mainContext;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init(string sId, context mainCtx) {
		_init(sId, mainCtx, _configurationUpdated);
	}
	
	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init_cb(string sId, context mainCtx, action<> cb_initComplete) {
		CallbackHelper callbackHelper:=new CallbackHelper;
		callbackHelper.callbacks.append(cb_initComplete);
		callbackHelper.callbacks.append(_configurationUpdated);
		_init(sId, mainCtx, callbackHelper.callback);
	}

	/**
	 * Implementation of init and init_cb
	 */
	action _init(string sId, context mainCtx, action<> cb_initComplete) {
		base.init(sId, cb_initComplete);
		mainContext:=mainCtx;
		scenarioId:=sId;
		controlChannel := ScenarioServiceLibrary.getControlChannel(scenarioId);
		rawChannel := ScenarioServiceLibrary.getRawChannel(scenarioId);
		dataChannel := ScenarioServiceLibrary.getDataChannel(scenarioId);
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdates();
		}
		base.listeners.append(l);
		base.listenToConfigureUpdates(_configurationUpdated);
	}
	
	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  

	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated() {
		if base.isSendThrottled() {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) {
				_setupThrottleListener();
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener() {
		if base.throttlePeriod > 0.0 {
			throttlingListener:=on all wait(base.throttlePeriod) {
				_sendThrottledUpdates();
			}
		} else {
			_sendThrottledUpdates();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdates() {
		integer instance;
		if base.sendThrottled {
			for instance in updates.keys() {
				send updates[instance] to dataChannel;
			}
		}
		if currentlySendingThrottledUser {
			for instance in updates.keys() {
				send updates[instance] to ScenarioServiceLibrary.getDataUserChannel(dataChannel, owners[instance]);
			}
		}
		owners.clear();
		updates.clear();
		currentlySendingThrottledUser := base.sendThrottledUser;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		_sendThrottledUpdates();
	}	

	/**
 	 * Flush pending throttled data for one instance
	 */
	action flushPendingInstance(integer scenarioInstanceId) {
		if updates.hasKey(scenarioInstanceId) {
			if base.sendThrottled {
				send updates[scenarioInstanceId] to dataChannel;
			}
			if currentlySendingThrottledUser {
				send updates[scenarioInstanceId] to ScenarioServiceLibrary.getDataUserChannel(dataChannel, owners[scenarioInstanceId]);
			}
			updates.remove(scenarioInstanceId);
			if owners.hasKey(scenarioInstanceId) {
				owners.remove(scenarioInstanceId);
			}
		}
	}	

	/**
 	 * Called when a new update is available. (This variant allows setting of the time parameter)
	 */
	action emitUpdate_time(integer scenarioInstanceId, float time, sequence<string> output, string owner) {
		if base.sendAny {
			Update update:=Update(scenarioId, scenarioInstanceId, time, output);
			if base.sendRaw {
				send update to rawChannel;
			}
			if base.sendRawUser {
				send update to ScenarioServiceLibrary.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate {
				route update;
			}
			if base.isSendThrottled() {
				if base.throttlePeriod > 0.0 {
					updates.add(scenarioInstanceId, update);
					if currentlySendingThrottledUser {
						owners.add(scenarioInstanceId, owner);
					}
				} else {
					send update to dataChannel;
				}
			}
		}
	}
	
	/**
 	 * Called when a new update is available.
	 */
	action emitUpdate(integer scenarioInstanceId, sequence<string> output, string owner) {
		emitUpdate_time(scenarioInstanceId, currentTime, output, owner);
	}

	/**
 	 * Called to send a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId, integer scenarioInstanceId, sequence<string> output) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, output);
		if base.routeUpdate {
			route ack;
		}
		if base.emitAny {
			send ack to controlChannel;
		}
	}
				
	/**
 	 * Called to send a new Nak event.
	 */
	action emitNack(integer messageId, integer scenarioInstanceId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate {
			route nack;
		}
		if base.emitAny {
			send nack to controlChannel;
		}
	}
	
	/**
 	 * Called to send a new Created event.
	 */
	action emitCreated(integer messageId, integer scenarioInstanceId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny {
				string sCreated:=created.toString();
				base.doEmit(sCreated, owner);
			}
		}
	}

	/**
 	 * Called to send any received events (except for instance) for this scenario.
	 */
	action emitReceivedEvents() {
		dictionary<integer, string> instanceOwners:=new dictionary<integer, string>;
		{
			Update update;
			listener l:=on all Update(scenarioId = scenarioId):update {
				if base.sendRaw {
					send update to rawChannel;
				}
				if base.sendRawUser and instanceOwners.hasKey(update.scenarioInstanceId) {	
					send update to ScenarioServiceLibrary.getRawUserChannel(rawChannel, instanceOwners[update.scenarioInstanceId]);
				}
				if base.isSendThrottled() {
					if base.throttlePeriod > 0.0 {
						updates.add(update.scenarioInstanceId, update);
						string owner:="*";
						if instanceOwners.hasKey(update.scenarioInstanceId) {
							owner:=instanceOwners[update.scenarioInstanceId];
						}
						if currentlySendingThrottledUser {
							owners.add(update.scenarioInstanceId, owner);
						}
					} else {
						send update to dataChannel;
					}
				}
			}
			base.listeners.append(l);
		}
		{
			Created created;
			listener l:=on all Created(scenarioId = scenarioId):created {
				if(created.owner != "*") {
					instanceOwners.add(created.scenarioInstanceId, created.owner);
				}
				base.doEmit(created.toString(), created.owner);				
			}
			base.listeners.append(l);
		}
		{
			Deleted deleted;
			listener l:=on all Deleted(scenarioId = scenarioId):deleted {
				flushPendingInstance(deleted.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(deleted.scenarioInstanceId) {
					owner:=instanceOwners[deleted.scenarioInstanceId];
					instanceOwners.remove(deleted.scenarioInstanceId);
				}
				base.doEmit(deleted.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			Edited edited;
			listener l:=on all Edited(scenarioId = scenarioId):edited {
				flushPendingInstance(edited.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(edited.scenarioInstanceId) {
					owner:=instanceOwners[edited.scenarioInstanceId];
				}
				base.doEmit(edited.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			InstanceDied instanceDied;
			listener l:=on all InstanceDied(scenarioId = scenarioId):instanceDied {
				flushPendingInstance(instanceDied.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(instanceDied.scenarioInstanceId) {
					owner:=instanceOwners[instanceDied.scenarioInstanceId];
				}
				base.doEmit(instanceDied.toString(), owner);		
			}
			base.listeners.append(l);
		}
	}
	
	/**
 	 * Called to send a new Edited event.
	 */
	action emitEdited(integer messageId, integer scenarioInstanceId, sequence<string> inputVariables, sequence<string> outputVariables, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, outputVariables);
			if base.routeUpdate {
				route edited;
			}
			if base.emitAny {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId, scenarioInstanceId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId, integer scenarioInstanceId) {
		if(context.current().getId()!=mainContext.getId()) {
			send OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to send a new Deleted event.
	 */
	action emitDeleted(integer messageId, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate {
				route deleted;
			}
			if base.emitAny {
				base.doEmit(deleted.toString(), owner);
			}
		}
		notifyInstanceDied(scenarioInstanceId);
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied(integer scenarioInstanceId) {
		if mainContext.getId()!=context.current().getId() {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			send iDied to mainContext;
		}
	}
	

	
	/**
 	 * Called to send an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied(integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() {
				route iDied;
			}
		}
	}
	
	/**
 	 * Called to send a new StateChange event.
	 */
	action emitStateChange(string state, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() {
			send stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to send an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, integer scenarioInstanceId, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal {
			if mainContext.getId() != context.current().getId() {
				send instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) {
				send instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() {
				send RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}
	/**
 	 * Called to send an instance that has already been seen in the current context
	 */
	action emitReceivedInstance(RequestInstancesInternal request, Instance instance) {
		if request.internal {
			if mainContext.getId() != context.current().getId() {
				send instance to mainContext;
			}
		} else {
			if(base.emitAny) {
				send instance to request.channel;
			}
		}
	}
	
}


/*
 * Monitor that performs the following tasks:
 *   - routing/emitting ScenarioServiceLoaded when the service is loaded
 *   - routing/emitting ScenarioServiceUnloaded when the service is unloaded
 *   - routing/emitting a nack if a Create request is ignored
 *   - maintains latest configuration
 *   - tracks state of ended/ failed scenarios
 *   - forwards Edit, Delete events to scenarios in other contexts
 *
 */
monitor ScenarioService {

	event PendingOperation {
		integer messageId;
		integer type; // 0 = delete, 1 = edit
	}

	listener throttledSenderListener;
	RequestScenarios requestScenarios;
	boolean requestingScenarios;
	
	// MetaData relating to the interface
	dictionary<string,string> interfaceMetaData := {
		"interface.package"     :"com.apama.scenario",
		"interface.name"        :"ScenarioService",
		"interface.fileName"    :"ScenarioService.mon",
		"interface.vendor"      :"Apama",
		"interface.version"     :"10.1.0.4.324292",
		"interface.fullVersion" :"rel/10.1.0.x@324292",
		"interface.language"    :"MonitorScript"
	};
	
	// Channel names	
	string scenarioServiceChannel := "com.apama.scenario";
	integer highestInstanceId;


	// the first mThread handles scenario discovery and maps some events to internal events
	action onload() {
		// print version
		log "ScenarioService interface loaded. MetaData: "+interfaceMetaData.toString() at INFO;
		
		// generate the ScenarioServiceLoaded event
		route ScenarioServiceLoaded();
		send ScenarioServiceLoaded() to scenarioServiceChannel;

		dictionary <string,string> defaultConfig:=new dictionary<string,string>;
		dictionary <string, dictionary<string,string> > configurations:=new dictionary<string, dictionary<string,string> >;
		ScenarioServiceLibrary.configurationManager(defaultConfig, configurations);
		RequestInstancesOnChannel requestInstancesOnChannel;
		on all RequestInstancesOnChannel():requestInstancesOnChannel {
			route RequestInstancesInternal(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId, requestInstancesOnChannel.channel, false, "", false);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannel.scenarioId, messageId=requestInstancesOnChannel.messageId) {
				send RequestInstancesDone(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId) to requestInstancesOnChannel.channel;
			}
		}

		RequestInstancesOnChannelByUser requestInstancesOnChannelByUser;
		on all RequestInstancesOnChannelByUser():requestInstancesOnChannelByUser {
			route RequestInstancesInternal(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId, requestInstancesOnChannelByUser.channel, false, requestInstancesOnChannelByUser.owner, true);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannelByUser.scenarioId, messageId=requestInstancesOnChannelByUser.messageId) {
				send RequestInstancesDone(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId) to requestInstancesOnChannelByUser.channel;
			}
		}
		Scenario scenario;
		on all Scenario():scenario {
			if requestingScenarios {
				send scenario to requestScenarios.channel;
			} else {
				spawn trackScenario(scenario);
			}
		}
		
		ScenarioUnloaded scenarioUnloaded;
		on all ScenarioUnloaded(): scenarioUnloaded {
			send scenarioUnloaded to scenarioServiceChannel;
		}

		
		on all RequestScenarios():requestScenarios {
			send RequestScenariosAck() to requestScenarios.channel;
			route StartScenarioRecovery();
			route FinishedScenarioRecovery();
			requestingScenarios:=true;
			on FinishedScenarioRecovery() {
				requestingScenarios:=false;
				send RequestScenariosDone() to requestScenarios.channel;
			}
		}

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		// Pick up any requests for operations on invalid scenarioIds
		Create create;
		on all unmatched Create(): create {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(create.scenarioId) {
				config:=configurations[create.scenarioId];
			}
			Acknowledge nack := new Acknowledge;
			nack.scenarioId := create.scenarioId;
			nack.messageId := create.messageId;
			nack.success := false;
			log create.scenarioId+": Scenario create ignored - unknown scenarioId." at WARN;
			send nack to ScenarioServiceLibrary.getControlChannel(create.scenarioId);
			if ScenarioServiceLibrary.getRouteUpdate(defaultConfig, config) {
				route nack;
			}
		}

		// The old SetThrottlingPeriod is mapped to a ConfigureUpdates event
		SetThrottlingPeriod setThrottlingPeriod;		
		on all SetThrottlingPeriod():setThrottlingPeriod {
			dictionary<string, string> configChanges:=new dictionary<string,string>;
			if setThrottlingPeriod.period >= 0.0 {
				configChanges["sendThrottled"]:="true";
				configChanges["throttlePeriod"]:=setThrottlingPeriod.period.toString();
			} else {
				configChanges["sendThrottled"]:="false";
			}
			ConfigureUpdates cu:=ConfigureUpdates("", configChanges);
			log "Received deprecated event "+setThrottlingPeriod.toString()+", will re-route as "+cu.toString() at WARN;
			route cu;
		}
	}		
				
	
	action onunload() {
		// generate the ScenarioServiceUnloaded event
		ScenarioServiceUnloaded unloaded := new ScenarioServiceUnloaded;
		route unloaded;
		send unloaded to scenarioServiceChannel;
	}
	
	/**
	 * spawned per scenario, and handles any finished scenario instances.
	 * For parallel scenarios, it also tracks which instance runs in 
	 * which context and forwards Edit and Delete events.
	 */
	action trackScenario(Scenario scenario) {
		on ScenarioUnloaded(scenarioId=scenario.scenarioId) {
			die;
		}
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(scenario.scenarioId, context.current());
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=scenario.scenarioId):finished {
			// Finished scenarios can be deleted (which terminates all listeners for this instance), 
			// discovered, and edits are Nacked 
			Delete delete;
			on Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId):delete {
				updater.emitAcknowledgement(delete.messageId, finished.scenarioInstanceId, finished.outputFieldValues);
				updater.emitDeleted(delete.messageId, finished.scenarioInstanceId, finished.owner);
			}
			Edit edit;
			on all Edit(scenarioId=scenario.scenarioId, scenarioInstanceId=finished.scenarioInstanceId):edit and not 
			            Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
				updater.emitNack(edit.messageId, finished.scenarioInstanceId);
				log scenario.displayName+"("+finished.scenarioInstanceId.toString()+ "): Scenario edit ignored - Scenario is in "+finished.state+" state." at WARN;
			}
			RequestInstancesInternal requestInstances;
			if finished.owner = "*" {
				on all RequestInstancesInternal(scenarioId=scenario.scenarioId):requestInstances and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			} else {
				on all (RequestInstancesInternal(scenarioId=scenario.scenarioId, ownerFilter=false):requestInstances or
					RequestInstancesInternal(scenarioId=scenario.scenarioId, owner=finished.owner, ownerFilter=true):requestInstances) and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			}
		}
		if scenario.executionMode > 0 {
			// for parallel scenarios, we keep track of instance to context mapping:
			dictionary<integer, context> runningCtxs := new dictionary<integer, context>;
			// and to owner mapping:
			dictionary<integer, string> ownerCtxs := new dictionary<integer, string>;
			// and by user:
			dictionary<string, dictionary<integer, context> > runningCtxsByOwner := new dictionary<string, dictionary<integer, context> >;
			// maps from instanceId to sequence<messageId>
			dictionary<integer, sequence<PendingOperation> > pendingOperations := new dictionary<integer, sequence<PendingOperation> >;
			ParallelStarting starting;
			on all ParallelStarting(scenarioId = scenario.scenarioId):starting {
				runningCtxs.add(starting.scenarioInstanceId, starting.runningCtx);
				ownerCtxs.add(starting.scenarioInstanceId, starting.owner);
				if not runningCtxsByOwner.hasKey(starting.owner) {
					runningCtxsByOwner.add(starting.owner, new dictionary<integer, context>);
				}
				runningCtxsByOwner[starting.owner].add(starting.scenarioInstanceId, starting.runningCtx);
				highestInstanceId := starting.scenarioInstanceId;
			}
			
			InstanceDied died;
			on all InstanceDied(scenarioId = scenario.scenarioId):died {
				if runningCtxs.hasKey(died.scenarioInstanceId) {
					runningCtxs.remove(died.scenarioInstanceId);
				}
				if ownerCtxs.hasKey(died.scenarioInstanceId) {
					string owner:=ownerCtxs[died.scenarioInstanceId];
					ownerCtxs.remove(died.scenarioInstanceId);
					if runningCtxsByOwner.hasKey(owner) {
						if runningCtxsByOwner[owner].hasKey(died.scenarioInstanceId) {
							runningCtxsByOwner[owner].remove(died.scenarioInstanceId);
						}
						if runningCtxsByOwner[owner].size()=0 {
							runningCtxsByOwner.remove(owner);
						}
					}
				}
				if pendingOperations.hasKey(died.scenarioInstanceId) {
					PendingOperation pending;
					for pending in pendingOperations[died.scenarioInstanceId] {
						if pending.type = 0 {
							route Delete(scenario.scenarioId, pending.messageId, died.scenarioInstanceId);
						} else {
							if pending.type = 1 {
								route Edit(scenario.scenarioId, pending.messageId, died.scenarioInstanceId, new sequence<string>);
							} else {
								log "error: unknown pending operation type "+pending.toString() at ERROR;
							}
						}
					}
					pendingOperations.remove(died.scenarioInstanceId);
				}
			}
			
			// and forward edits, deletes:
			Edit edit;
			on all unmatched Edit(scenarioId = scenario.scenarioId):edit {
				if runningCtxs.hasKey(edit.scenarioInstanceId) {
					send edit to runningCtxs[edit.scenarioInstanceId];
					addPendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId, 1);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId, messageId = edit.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId){
						removePendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId);
					}
				} else {
					log scenario.displayName+"("+edit.scenarioInstanceId.toString()+"): Scenario edit ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(edit.messageId, edit.scenarioInstanceId);
				}
			}
			Delete delete;
			on all unmatched Delete(scenarioId = scenario.scenarioId):delete {
				if runningCtxs.hasKey(delete.scenarioInstanceId) {
					send delete to runningCtxs[delete.scenarioInstanceId];
					addPendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId, 0);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId, messageId = delete.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId){
						removePendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId);
					}
				} else {
					log scenario.displayName+"("+delete.scenarioInstanceId.toString()+"): Scenario delete ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(delete.messageId, delete.scenarioInstanceId);
				}
			}
			
			// and request instances is handled by a separate monitor. Note that 
			// Finished scenarios are not in the dictionary, but are handled by the finished
			// listener above.
			RequestInstancesInternal reqInstances;
			on all RequestInstancesInternal(scenarioId=scenario.scenarioId):reqInstances {
				if reqInstances.ownerFilter {
					if runningCtxsByOwner.hasKey(reqInstances.owner) {
						dictionary<integer, context> rCtxs:=runningCtxsByOwner[reqInstances.owner];
						if runningCtxsByOwner.hasKey("*") {
							rCtxs:=rCtxs.clone();
							integer i;
							dictionary<integer, context> wildcards:=runningCtxsByOwner["*"];
							for i in wildcards.keys() {
								rCtxs.add(i, wildcards[i]);
							}
						}
						route RequestInstancesParallel(reqInstances, rCtxs, highestInstanceId);
					} else {
						if runningCtxsByOwner.hasKey("*") {
							route RequestInstancesParallel(reqInstances, runningCtxsByOwner["*"], highestInstanceId);
						} else {
							route RequestInstancesParallel(reqInstances, new dictionary<integer,context>, highestInstanceId);
						}
					}
				} else {
					route RequestInstancesParallel(reqInstances, runningCtxs, highestInstanceId);
				}
			}
			ConfigureUpdates cu;
			on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenario.scenarioId):cu {
				integer inst;
				for inst in runningCtxs.keys() {
					send cu to runningCtxs[inst];
				}
			}
			on all SendQueuedUpdatesNow() {
				SendQueuedUpdatesNow snow:=SendQueuedUpdatesNow();
				integer inst;
				for inst in runningCtxs.keys() {
					send snow to runningCtxs[inst];
				}
			}
		}
	}
	
	action addPendingOperation(dictionary<integer,  sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId, integer type) {
		if not pendingOperations.hasKey(scenarioInstanceId) {
			pendingOperations.add(scenarioInstanceId, new sequence<PendingOperation>);
		}
		pendingOperations[scenarioInstanceId].append(PendingOperation(messageId, type));
	}
	
	action removePendingOperation(dictionary<integer, sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId) {
		if not pendingOperations.hasKey(scenarioInstanceId) {
			return;
		}
		integer idx:=-1, i:=0;
		while(i < pendingOperations[scenarioInstanceId].size()) {
			if pendingOperations[scenarioInstanceId][i].messageId = messageId {
				idx:=i;
				break;
			}
			i:=i+1;
		}
		if(idx>=0) {
			pendingOperations[scenarioInstanceId].remove(idx);
		}
		if pendingOperations[scenarioInstanceId].size() = 0 {
			pendingOperations.remove(scenarioInstanceId);
		}
	}	
}

/*
 * Monitor that handles request instances for parallel scenarios:
 * - on a RequestInstancesOnChannel for a parallel scenario, the ScenarioService 
 *   routes a RequestInstancesParallel which triggers this monitor to spawn.
 * - this waits for a response (be it to say the request instances has been 
 *   handled or that the scenario has finished) before sending the 
 *   RequestInstancesDone event 
 *
 * Note that this monitor assumes scenarioInstancesIds always increase over time.
 */
monitor RequestInstancesHandler {
	RequestInstancesParallel req;
	action onload() {
		on all RequestInstancesParallel():req {
			spawn handleRequest();
		}
	}
	
	/**
	 * Forward the request to every context and await responses. We remove 
	 * instances from the dictionary upon receiving an update for them. 
	 */
	action handleRequest() {
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(req.request.scenarioId, context.current());
		integer k;
		for k in req.instances.keys() {
			send req.request to req.instances[k];
		}
		// if a scenario dies, it will send events in the order ScenarioFinished, InstanceDied:
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):finished {
			// if a scenario dies after it has sent the Instance, do not send another 
			// (the StateChange/ InstanceDied events are sufficient)
			if(req.instances.hasKey(finished.scenarioInstanceId)) {
				updater.emitInstance(req.request, finished.scenarioInstanceId,
					finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
			}
		}
		// A finished scenario should not be counted
		InstanceDied died;
		on all InstanceDied(scenarioId = req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):died {
			if(req.instances.hasKey(died.scenarioInstanceId)) {
				req.instances.remove(died.scenarioInstanceId);
				checkFinished();
			}
		}
		RequestInstancesParallelDone pdone;
		on all RequestInstancesParallelDone(scenarioId = req.request.scenarioId, messageId = req.request.messageId):pdone {
			if(req.instances.hasKey(pdone.scenarioInstanceId)) {
				req.instances.remove(pdone.scenarioInstanceId);
				checkFinished();
			}
		}
		checkFinished();
	}
	
	/**
	 * Check whether we are finished.
	 * We are finished if we have no instances left in our dictionary, in which 
	 * case we route a RequestInstancesDone (handled by the ScenarioService monitor)
	 * and terminate.
	 */
	action checkFinished() {
		if req.instances.size()=0 {
			route RequestInstancesDone(req.request.scenarioId, req.request.messageId);
			die;
		}
	}
}

 00000033 C:\SoftwareAG101\Apama\monitors\ScenarioService.mon
TIME 0000000e 1522267307.4,1
MONF 0000299b // 
// Bridges between the MemoryStore and ScenarioService event APIs. 
//
// Requires: ScenarioService.mon. 
//
// $Copyright(c) 2009-2012 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG

package com.apama.memorystore;

using com.apama.scenario.Update;
using com.apama.scenario.Create;
using com.apama.scenario.Delete;
using com.apama.scenario.Edit;
using com.apama.scenario.Created;
using com.apama.scenario.Deleted;
using com.apama.scenario.Edited;
using com.apama.scenario.InstanceDied;
using com.apama.scenario.Instance;
using com.apama.scenario.RequestInstancesDone;
using com.apama.scenario.RequestInstancesInternal;
using com.apama.scenario.Scenario;
using com.apama.scenario.ScenarioServiceUpdaterMultipleInstances;
using com.apama.scenario.ScenarioServiceLibrary;
using com.apama.scenario.StartScenarioRecovery;
using com.apama.scenario.ConfigureUpdates;
using com.apama.scenario.GetAllConfiguration;
using com.apama.scenario.AllConfiguration;

/**
	Requests Scenario Service updates for an exposed MemoryStore to be 
	forwarded to the specified Correlator context. 
	
	Note that this is inefficient and does not implement proper flow
	control. Only use for testing or debugging. 
	
	@see Schema#exposeMemoryView Only tables that are configured to expose 
		their contents will be affected by this event. 
*/
event ForwardMemoryStoreUpdatesTo {
	/** The context to which events should be forwarded. */
	context ctx;
}

/** Makes data in MemoryStore available for viewing by 
	any dashboard client that uses the Scenario Service, or as a 
	DataView. 
	
	@private
*/
monitor MemoryStoreScenarioImpl
{
	import "MemoryStorePlugin" as plugin;

	string MEMORYSTORE_SCENARIO_PREFIX := "DV_MEMST_";
	string PREFIX_UPPER := "DV_MEMST`";
	Scenario recoveryResponse;
	boolean doingRecovery;
	// a private context that sends events out.  Should never block on something 
	// that may be blocking on the memory store plugin. That means no 
	// calling into the plugin and no direct send-to to any other 
	// context that may call the plugin.
	// Deadlocks can be avoided using the asyncEnqueuTo method on the
	// plugin, but must only do so if there can only be a bounded 
	// number of such events queued; we use it for scenario discovery only.
	context emitterContext := context("MemoryStore_emitter");
	context asyncForwarding := context("MemoryStore_forwarder");
	context mainContext := context.current();

	action onload()
	{
		spawn asyncForwarder() to asyncForwarding;
		integer id:=integer.getUnique();
		route GetAllConfiguration(id);
		AllConfiguration allConfig;
		on AllConfiguration(requestId = id):allConfig {
			startup(allConfig.defaultConfig, allConfig.configurations);
		}
	}

	event RequestInstancesHandler {
		import "MemoryStorePlugin" as plugin;
		RequestInstancesInternal scenRequestInstances;
		ScenarioServiceUpdaterMultipleInstances updater;
		action<string, RequestInstancesInternal, ScenarioServiceUpdaterMultipleInstances> handleRequestInstances;
		context emitterContext;

		action onConfig() {
			sequence<string> names := ["", ""];
			plugin.decodeScenarioName(scenRequestInstances.scenarioId, names);
			string storeName := names[0], tableName := names[1];

			Storage storage := new Storage;
			if storage.hasStore(storeName)
			{
				Store store := storage.open(storeName);
				if store.hasTable(tableName)
				{
					if updater.base.sendAny
					{
						if plugin.exposingViews(tableName,storeName,isMemory(scenRequestInstances.scenarioId)) {
							spawn spawnTarget() to emitterContext;
							plugin.sendScenarioInstancesFor(tableName,storeName,isMemory(scenRequestInstances.scenarioId),scenRequestInstances.messageId);
						} else {
							route com.apama.scenario.RequestInstancesDone(scenRequestInstances.scenarioId, scenRequestInstances.messageId);
						}
					} else {
						route com.apama.scenario.RequestInstancesDone(scenRequestInstances.scenarioId, scenRequestInstances.messageId);
					}
				}
			}
			updater.destroy();
		}
		action spawnTarget() {
			handleRequestInstances(scenRequestInstances.scenarioId, scenRequestInstances, updater);
		}

		action isMemory(string name) returns boolean
		{
			string MEMORYSTORE_SCENARIO_MEMORY_SUFFIX := "_memory";
			integer index := name.find(MEMORYSTORE_SCENARIO_MEMORY_SUFFIX);
			return index > 0;
		}
	}

	event InvalidRequestHandler {
		ScenarioServiceUpdaterMultipleInstances updater;
		integer messageId;
		integer scenarioInstanceId;

		action handle(string scenarioId, integer messageId, integer scenarioInstanceId) {
			self.messageId := messageId;
			self.scenarioInstanceId := scenarioInstanceId;
			updater.init_cb(scenarioId, context.current(), onConfig);
		}

		action onConfig() {
			updater.emitNack(messageId, scenarioInstanceId);
			updater.destroy();
		}
	}
	
	action startup(dictionary<string, string> defaultConfig, dictionary<string, dictionary<string, string> > configurations) {
		spawn handleNewScenarios(defaultConfig, configurations) to emitterContext;

		//setup listener to listen for discovery
		on all StartScenarioRecovery()
		{
			doingRecovery := true;
			chunk c := plugin.prepareScenariosSnapshot2();
			integer count := plugin.ScenarioChunk_count(c);
			integer i := 0;		
			while i < count
			{
				recoveryResponse.scenarioId := plugin.ScenarioChunk_getId(c,i);
				recoveryResponse.displayName := plugin.ScenarioChunk_getName(c,i);
				recoveryResponse.description := plugin.ScenarioChunk_getDescription(c,i);
				recoveryResponse.outputNames := [];
				integer numFields := plugin.ScenarioChunk_getFieldsLength(c,i);
				integer j := 0;
				while j < numFields
				{
					recoveryResponse.outputNames.append(plugin.ScenarioChunk_getField(c,i,j));
					j := j + 1;
				}
				recoveryResponse.outputTypes := [];
				integer numTypes := plugin.ScenarioChunk_getTypesLength(c,i);
				j := 0;
				while j < numTypes
				{
					recoveryResponse.outputTypes.append(plugin.ScenarioChunk_getType(c,i,j));
					j := j + 1;
				}
				i := i + 1;
				recoveryResponse.extraParams := {"isReadOnly":"true", "type":"dataview"};
				route recoveryResponse;
			}

		}
		on all completed StartScenarioRecovery() {
			doingRecovery := false;
		}

		// initialisation - send all scenarios to the emitter context, spawn for each scenario

		plugin.setEmitContext(emitterContext.getId());

		{
			chunk c := plugin.prepareScenariosSnapshot2();
			integer count := plugin.ScenarioChunk_count(c);
			integer i := 0;		

			while i < count
			{
				spawn handleScenario(plugin.ScenarioChunk_getId(c,i)) to emitterContext;
				i := i + 1;
			}
		}

		// forward scenario service requests:
		ConfigureUpdates configUpdate;
		on all ConfigureUpdates():configUpdate {
			send configUpdate to emitterContext;
		}
		RequestInstancesInternal scenRequestInstances;
		on all RequestInstancesInternal(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenRequestInstances
		{
			ScenarioServiceUpdaterMultipleInstances updater := new ScenarioServiceUpdaterMultipleInstances;
			RequestInstancesHandler handler := RequestInstancesHandler(scenRequestInstances, updater, handleRequestInstances, emitterContext);
			updater.init_cb(scenRequestInstances.scenarioId, context.current(), handler.onConfig);
		}
		Create scenCreate;
		on all Create(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenCreate
		{
			InvalidRequestHandler handler:=new InvalidRequestHandler;
			handler.handle(scenCreate.scenarioId, scenCreate.messageId, -1);
		}

		Delete scenDel;
		on all Delete(scenarioId  in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenDel
		{
			InvalidRequestHandler handler:=new InvalidRequestHandler;
			handler.handle(scenDel.scenarioId, scenDel.messageId, scenDel.scenarioInstanceId);
		}

		Edit scenEdit;
		on all Edit(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenEdit
		{
			InvalidRequestHandler handler:=new InvalidRequestHandler;
			handler.handle(scenEdit.scenarioId, scenEdit.messageId, scenEdit.scenarioInstanceId);
		}
		ForwardMemoryStoreUpdatesTo f;
		on all ForwardMemoryStoreUpdatesTo():f {
			spawn forwardUpdatesTo(f.ctx) to emitterContext;
		}
	}

	action handleNewScenarios(dictionary <string,string> defaultConfig, dictionary <string, dictionary<string,string> > configurations) {

		Scenario scenario;
		on all unmatched Scenario(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):scenario
		{
			send scenario to "com.apama.scenario";
			spawn handleScenario(scenario.scenarioId);
		}
		ScenarioServiceLibrary.configurationManager(defaultConfig, configurations);
	}
	


	action handleScenario(string scenarioId) {
		on all Scenario(scenarioId = scenarioId) {}

		ScenarioServiceUpdaterMultipleInstances updater := new ScenarioServiceUpdaterMultipleInstances;
		updater.init(scenarioId, asyncForwarding);
		updater.emitReceivedEvents();
	}

	action handleRequestInstances(string scenarioId, RequestInstancesInternal scenRequestInstances, ScenarioServiceUpdaterMultipleInstances updater) {
		Instance scenInstance;
		on all Instance(scenarioId = scenarioId, messageId = scenRequestInstances.messageId):scenInstance and 
			not RequestInstancesDone(scenarioId = scenarioId, messageId = scenRequestInstances.messageId) {
			updater.emitReceivedInstance(scenRequestInstances, scenInstance);
		}
		RequestInstancesDone rid;
		on all RequestInstancesDone(scenarioId = scenarioId, messageId = scenRequestInstances.messageId):rid {
			integer _ := plugin.asyncEnqueueTo(rid.toString(), mainContext.getId()); // doesn't matter when it completes
			die;
		}
	}

	action asyncForwarder() {
		Instance i;
		on all Instance():i {
			integer _:=plugin.asyncEnqueueTo(i.toString(), mainContext.getId());
		}
		RequestInstancesDone rid;
		on all RequestInstancesDone():rid {
			integer _:=plugin.asyncEnqueueTo(rid.toString(), mainContext.getId());
		}
	}

	action forwardUpdatesTo(context ctx) {
		Update u;
		on all Update(scenarioId in (MEMORYSTORE_SCENARIO_PREFIX : PREFIX_UPPER)):u {
			integer _:=plugin.asyncEnqueueTo(u.toString(), ctx.getId());
		}
	}
}

 00000048 C:\SoftwareAG101\Apama\monitors\data_storage\MemoryStoreScenarioImpl.mon
MONF 0000057f /**
 * $Copyright (c) 2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */

package com.apama.eventscheduler;

/**
 * An event object providing function to schedule sending of an event to a channel 
 * in future. It is useful for externally-clocked correlator where correlator time 
 * travels differently than real time and timer based on real time is required. 
 * The "on wait()" listener is the standard way for creating a timer and should
 * be used in most cases.
 */
event EventScheduler {
	/** @private */
	import "EventSchedulerPlugin" as _plugin;

	/** Schedule an event to be sent in future after the specified time. The event is
	 * sent to the specified channel.
	 *
	 * @param eventString String that specifies the event to be sent.
	 * @param channel String that specifies the channel to be which event should be sent.
	 * @param duration Float that specifies time duration after which event should be sent. 
	 * The duration is specified in seconds.
	 *
	 */
	static action scheduleEvent(string eventString, string channel, float duration) {
		_plugin.scheduleEvent(eventString, channel, duration);
	}
}
 00000032 C:\SoftwareAG101\Apama\monitors\EventScheduler.mon
MONF 0000022b /*
	$Copyright(c) 2011 Progress Software Corporation (PSC). All rights reserved.$ 
	$Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
	Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
*/

package com.apama.correlator;

/** For internal use only. 

@private*/
event ManagementAck {
	string response;
	integer uid;
}
 00000032 C:\SoftwareAG101\Apama\monitors\ManagementImpl.mon
MONF 000042b2 /*
	$Copyright(c) 2011-2013 Progress Software Corporation (PSC). All rights reserved.$ 
	$Copyright (c) 2013-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
	Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
	
	Requires ManagementImpl.mon
*/

package com.apama.correlator;

/**
 * EPL representation of the correlator status.
 */
event EngineStatus {
	/** 
	* @private
	*
	* Identifer prepended to user status keys to differentiate from standard keys.
	*/
	constant string userPrefix := "user-";

	/** @private*/
	dictionary<string,string> values;

	/**
	 * The time in milliseconds since the correlator was started.
	 */
	action getUptime() returns integer {
		return values["uptime"].toInteger();
	}

	/**
	 * The number of contexts in the correlator, including the main context.
	 */
	action getNumContexts() returns integer {
		return values["numContexts"].toInteger();
	}

	/**
	 * The number of EPL monitor definitions injected into the correlator. 
	 */
	action getNumMonitors() returns integer {
		return values["numMonitors"].toInteger();
	}
	
	/**
	 * The number of monitor instances, also known as sub-monitors.
	 */
	action getNumProcesses() returns integer {
		return values["numProcesses"].toInteger();
	}
	
	/**
	 * The number of Java applications and Java EPL plug-ins loaded in the correlator. 
	 */
	action getNumJavaApplications() returns integer {
		return values["numJavaApplications"].toInteger();
	}
	
	/**
	 * The number of listeners in all contexts. 
	 */
	action getNumListeners() returns integer {
		return values["numListeners"].toInteger();
	}
	
	/**
	 * The number of event types defined within the correlator. 
	 */
	action getNumEventTypes() returns integer {
		return values["numEventTypes"].toInteger();
	}
	
	/**
	 * The sum of routed events on the route queues of all contexts.
	 */
	action getNumQueuedFastTrack() returns integer {
		return values["numQueuedFastTrack"].toInteger();
	}
	
	/**
	 * The number of executors on the input queues of all contexts. 
	 * As well as events, this can include clock ticks, spawns, injections and other operations. 
	 */
	action getNumQueuedInput() returns integer {
		return values["numQueuedInput"].toInteger();
	}
	
	/**
	 * The number of events that the correlator has received from external sources since the correlator started. 
	 */
	action getNumReceived() returns integer {
		return values["numReceived"].toInteger();
	}
	
	/**
	 * The number of events that have been routed across all contexts since the correlator was started.
	 */
	action getNumFastTracked() returns integer {
		return values["numFastTracked"].toInteger();
	}
	
	/**
	 * The number of external consumers/receivers connected to receive emitted events.
	 */
	action getNumConsumers() returns integer {
		return values["numConsumers"].toInteger();
	}
	
	/**
	 * The number of events waiting on output queues to be dispatched to any connected external consumers/receivers.
	 */
	action getNumOutEventsQueued() returns integer {
		return values["numOutEventsQueued"].toInteger();
	}

	/**
	 * The number of events that have been sent or emitted to channels which 
	 * have at least one external consumer/receiver subscribed.
	 */
	action getNumOutEventsCreated() returns integer {
		return values["numEmits"].toInteger();
	}
	
	/**
	 * The number of events that have been delivered to external consumers/receivers. 
	 * This counts for each external consumer/receiver an event is sent to. 
	 */
	action getNumOutEventsSent() returns integer {
		return values["numOutEventsSent"].toInteger();
	}
	
	/**
	 * The number of events on the slowest context's queue, as identified by the name of the slowest context.
	*/
	action getMostBackedUpQueueSize() returns integer {
		return values["mostBackedUpICQueueSize"].toInteger();
	}
	
	/**
	 * The number of sub-event-listeners that are active across all contexts. 
	 */
	action getNumSubListeners() returns integer {
		return values["numSubListeners"].toInteger();
	}
	
	/**
	 * The number of events processed by the correlator in all contexts.
	 */

	action getNumProcessed() returns integer {
		return values["numProcessed"].toInteger();
	}

	/**
	 * The name of the slowest context.
	 */
	action getMostBackedUpInput() returns string {
		return values["mostBackedUpInputContext"];
	}

	/**
	 * The name of the consumer/receiver with the largest number of incoming events waiting to be processed.
	 */
	action getSlowestReceiver() returns string {
		return values["slowestReceiver"];
	}

	/**
	 * The number of events on the slowest consumer's/receiver's queue, as identified by the name of the slowest consumer/receiver.
	 */
	action getSlowestReceiverQueueSize() returns integer {
		return values["slowestReceiverQueueSize"].toInteger();
	}

	/** @private */
	action prep(string input) returns string {
		return userPrefix + input;
	}

	/**
	 * Get a user-set status value of type float OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type float or the alternate value if the key does not exist.
	 */
	action getUserFloatOr(string key, float alt) returns float {
		key := prep(key);
		if(values.hasKey(key)) {
			return float.parse(values[key]);
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type integer OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type integer or the alternate value if the key does not exist.
	 */
	action getUserIntegerOr(string key, integer alt) returns integer {
		key := prep(key);
		if(values.hasKey(key)) {
			return integer.parse(values[key]);
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type boolean OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type boolean or the alternate value if the key does not exist.
	 */
	action getUserBooleanOr(string key, boolean alt) returns boolean {
		key := prep(key);
		if(values.hasKey(key)) {
			return boolean.parse(values[key]);
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type string OR the alternative value specified if the key does not exist.
	 *
	 * @param key The name of the value to get.
	 * @param alt The alternative value to return if the key does not exist.
	 * @return The user status of type string or the alternate value if the key does not exist.
	 */
	action getUserStringOr(string key, string alt) returns string {
		key := prep(key);
		if(values.hasKey(key)) {
			return values[key];
		} else {
			return alt;
		}
	}

	/**
	 * Get a user-set status value of type float.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type float.
	 */
	action getUserFloat(string key) returns float {
		return float.parse(values[prep(key)]);
	}

	/**
	 * Get a user-set status value of type integer.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type integer.
	 */
	action getUserInteger(string key) returns integer {
		return integer.parse(values[prep(key)]);
	}

	/**
	 * Get a user-set status value of type boolean.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type boolean.
	 */
	action getUserBoolean(string key) returns boolean {
		return boolean.parse(values[prep(key)]);
	}

	/**
	 * Get a user-set status value of type string.
	 *
	 * @param key The name of the value to get.
	 * @return The user status of type string.
	 */
	action getUserString(string key) returns string {
		return values[prep(key)];
	}

	/** Get the full correlator status value dictionary .
	 *
	 * @return The full correlator status value dictionary.
	 */
	action getValues() returns dictionary<string,string> {
		return values;
	}
}


/**
 * EPL interface to the persistence functionality of the correlator.
 */
event Persistence {
	/**
	 * Asynchronously request a Correlator state persistence operation.
	 *
	 * At some point after this action is called, the correlator will commit its persistent state to storage. Once the commit has completed
	 * successfully, the provided callback will be invoked.
	 */
	static action persist(action<> callback) {
		integer uid := integer.getUnique();
		management.asyncRequestSeq("doPersistNow", new sequence<string>, uid);
		on ManagementAck(uid = uid) {
			callback();
		}
	}

	/** @private*/
	import "ManagementPlugin" as management;
}

/**
 * EPL interface to the generic component management functionality of the correlator.
 */
event Component {

	/**
	 * Argument for attach/detachAsEventConsumer - use legacy mode.
	 * In this mode, all events are delivered in serial to the receiver on the default channel.
	 */
	constant integer CONNECT_LEGACY := 0;
	/**
	 * Argument for attach/detachAsEventConsumer - use parallel mode.
	 * In this mode, all events are delivered in parallel per channel.
	 */
	constant integer CONNECT_PARALLEL := 1;

	/** @private*/
	import "ManagementPlugin" as management;
	/**
	 * Get the hostname of the server the correlator is running on.
 	 */
	static action getHostname() returns string {
		return management.getHostname();
	}
	/**
	 * Get the component name of the correlator.
	 */
	static action getComponentName() returns string {
		return management.getComponentName();
	}
	/**
	 * Get the port the correlator is running on.  This is the
	 * main port number; extra ports specified via the config file
	 * are not accessible.
	 */
	static action getComponentPort() returns integer {
		return management.getComponentPort();
	}
	/** 
	 * Get the correlator's logical ID.  This is a unique ID assigned to every correlator process at startup.
	 */
	static action getComponentLogicalId() returns string {
		return management.getComponentLogicalId();
	}
	/** 
	 * Get the correlator's physical ID.  This is a unique ID generated for a component.
	 */
	static action getComponentPhysicalId() returns string {
		return management.getComponentPhysicalId();
	}
	/**
	 * Get the number of CPUs the correlator has available to it.
	 */
	static action getNumberCPUs() returns integer {
		return management.getNumberCPUs();
	}
	/**
	 * Get whether or not correlator is running with external clocking on.
	 */
	static action isExternallyClocked() returns boolean {
		return management.isExternallyClocked();
	}

	/** Get the current license mode of the correlator - either "nolicensefile" or "licensefilesupplied". */
	static action getLicenseMode() returns string {
		return management.getLicenseMode();
	}

	/**
	* Get the correlator status, internal values and user added stats.
	*
	* @return EngineStatus a representation of all status values 
	* including user added values.
	*/
	static action getStatus() returns EngineStatus {
		dictionary<string, string> statusString := management.getStatus();
		return EngineStatus(statusString);
	}

	/**
	* Set a specific value on a user added status, If the status
	* doesn't already exist this will add it.
	*
	* Note the value must be in string format.
	*
	* @param name The name of the user status to add.
	* @param value The value associated with the user Status value.
	*/
	static action setUserStatus(string name, string value) {
		management.setUserStatus(name, value);
	}

	/**
	* Delete a specific user added status.
	*
	* @param name The name of the user status value to delete.
	*/
	static action deleteUserStatus(string name) {
		management.deleteUserStatus(name);
	}

	/** @private*/
	static action _escapeChannel(string c) returns string {
		if c.find(" ")=-1 and c.find("\n")=-1 and c.find("\\")=-1 {
			return c;
		}
		return c.replaceAll("\\", "\\\\").replaceAll(" ", "\\x20").replaceAll("\n","\\n");
	}


	/**
	 * Connect to another Apama component to receive events on the specified channels.
	 * connectMode should be one of CONNECT_LEGACY or CONNECT_PARALLEL.
	 */
	static action attachAsEventConsumerTo(string host, integer port, sequence<string> channels, boolean disconnectSlow, integer connectMode) {
		string channel;
		string parallel:="";
		if connectMode = CONNECT_PARALLEL {
			parallel := "parallel ";
		}
		string disconnectSlowStr := "";
		if disconnectSlow {
			disconnectSlowStr := "disconnectSlow ";
		}
		for channel in channels {
			management.asyncRequestSeq("addReceiveConnection",
			                           [host + " "+disconnectSlowStr + parallel + port.toString() + " " + _escapeChannel(channel)], -1);
		}
	}
	/**
	 * Disconnect from another Apama component to receive events on the specified channels.
	 * connectMode should be one of CONNECT_LEGACY or CONNECT_PARALLEL.
	 */
	static action detachAsEventConsumerFrom(string host, integer port, sequence<string> channels, integer connectMode) {
		string channel;
		string parallel:="";
		if connectMode = CONNECT_PARALLEL {
			parallel := "parallel ";
		}
		for channel in channels {
			management.asyncRequestSeq("removeReceiveConnection", 
			                           [host + " "+ parallel + port.toString() + " " + _escapeChannel(channel)], -1);
		}
	}
}

/**
 * EPL interface to correlator logging functionality. All methods on this interface are identical to the equivalent engine_management
 * requests, which are described in more detail in the user documentation.
 */
event Logging {
	/** @private*/
	import "ManagementPlugin" as management;

	/**
	 * Schedule simultaneous rotation of all correlator logs, including application logs and the input log. The rotation will happen shortly
	 * after this call.
	 */
	static action rotateLogs() {
		management.asyncRequestSeq("rotateLogs", new sequence<string>, -1);
	}

	/** Change the file that the correlator logs to. */
	static action setLogFile(string filename) {
		string ignore := management.syncRequestSeq("setLogFile", [filename]);
	}

	/** Set the destination of EPL log messages from the given package. A blank package is the root package. */
	static action setApplicationLogFile(string pkg, string filename) {
		if(pkg = "") {
			string ignore := management.syncRequestSeq("setApplicationLogFile", [filename]);
		} else {
			string ignore := management.syncRequestSeq("setApplicationLogFile", [filename, pkg]);
		}
	}

	/** Set the log level threshold of EPL log messages from the given package. A blank package is the root package. */
	static action setApplicationLogLevel(string pkg, string level) {
		if(pkg = "") {
			string ignore := management.syncRequestSeq("setApplicationLogLevel", [level]);
		} else {
			string ignore := management.syncRequestSeq("setApplicationLogLevel", [level, pkg]);
		}
	}

	/** Return the destination file for EPL log messages from the given package. A blank package is the root package. */
	static action getApplicationLogFile(string pkg) returns string {
		if(pkg = "") {
			return management.syncRequestSeq("getApplicationLogFile", new sequence<string>);
		} else {
			return management.syncRequestSeq("getApplicationLogFile", [pkg]);
		}
	}

	/** Return the log level threshold of EPL log messages from the given package. A blank package is the root package. */
	static action getApplicationLogLevel(string pkg) returns string {
		if(pkg = "") {
			return management.syncRequestSeq("getApplicationLogLevel", new sequence<string>);
		} else {
			return management.syncRequestSeq("getApplicationLogLevel", [pkg]);
		}
	}

	/** Reset logging for the given package to the default. A blank package is the root package. */
	static action unsetApplicationLogFile(string pkg) {
		if(pkg = "") {
			string ignore := management.syncRequestSeq("unsetApplicationLogFile", new sequence<string>);
		} else {
			string ignore := management.syncRequestSeq("unsetApplicationLogFile", [pkg]);
		}
	}

	/** Remove the log level from the given package, returning it to default. A blank package is the root package. */
	static action unsetApplicationLogLevel(string pkg) {
		if(pkg = "") {
			string ignore := management.syncRequestSeq("unsetApplicationLogLevel", new sequence<string>);
		} else {
			string ignore := management.syncRequestSeq("unsetApplicationLogLevel", [pkg]);
		}
	}
}

 0000002e C:\SoftwareAG101\Apama\monitors\Management.mon
MONF 00004929 /*
 * $Copyright (c) 2015-2017 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 * Event definitions for providing a set of functions to assist with date and time formatting.
 * 
 */

package com.apama.correlator.timeformat;

/** 
 * An event providing a time-parser object that you can then use 
 * to make multiple calls using its <tt>parseTime()</tt> function, specifying
 * the date/time string to be parsed. 
 * 
 * Reusing a <tt>CompiledPattern</tt> object is significantly more efficient than 
 * providing the same time pattern (<tt>format</tt>) in multiple calls to parse 
 * functions defined on the <tt>TimeFormat</tt> event object.
 */
event CompiledPattern {
	/** @private*/ import "TimeFormatPlugin" as __plugin;
	/** @private*/ wildcard chunk __c;
	
	/**
	 * Parses the <tt>timeDate</tt> string according to the format provided
	 * by this time/date parser event object returning the result 
	 * as a <tt>float</tt> of seconds since the epoch, or <tt>NaN</tt> 
	 * if it cannot parse the specified string. 
	 *
	 * For more information about the return value, see the description of 
	 * "Time Format plug-in parse functions" in "Developing Apama Applications."
	 *
	 * @param timeDate String that represents a time and/or a date.
	 * @returns The resulting value of seconds since the epoch.
	 */
	action parseTime(string timeDate) returns float 
	{
		return __plugin.parseTimeFromPattern(__c, timeDate);
	}	
}

/** 
 * An event object providing a set of functions to assist with date and 
 * time formatting.
 */
event TimeFormat
{
	// Public
	
	/** 
	 * Converts the <tt>time</tt> parameter to the local time and returns 
	 * that time in the format specified.
	 *
	 * @param time Float that indicates the time you want to format. 
	 * This value is the number of seconds since the epoch in UTC.
	 * This is the same format used by the <tt>currentTime</tt> variable. 
	 * For information about the <tt>currentTime</tt> variable, see
	 * "Getting the current time" in "Developing Apama Applications".
	 * @param format String that specifies the format that you want 
	 * the returned time to have. For details about what you can specify 
	 * for the <tt>format</tt> string, see "Format specification for the TimeFormat 
	 * functions" in the documentation for "Developing Apama Applications".
	 * @returns A string representing the local time in the specified
	 * format.
	 */
	static action format(float time, string format) returns string 
	{
		return __plugin.format(time, format);
	}
	
	/** 
	 * Converts the <tt>time</tt> parameter to the local time and returns 
	 * that time in the format specified. 
	 *
	 * The <tt>formatUTC()</tt> function always returns UTC (GMT no matter 
	 * what the local time is).
	 *
	 * @param time Float that indicates the time you want to format. 
	 * This value is the number of seconds since the epoch in UTC.
	 * This is the same format used by the <tt>currentTime</tt> variable. 
	 * For information about the <tt>currentTime</tt> variable, see
	 * "Getting the current time" in "Developing Apama Applications".
	 * @param format String that specifies the format that you want 
	 * the returned time to have. For details about what you can specify 
	 * for the <tt>format</tt> string, see "Format specification for the TimeFormat 
	 * functions" in the documentation for "Developing Apama Applications".
	 * @returns A string representing the local time in the specified
	 * format.
	 */
	static action formatUTC(float time, string format) returns string 
	{
		return __plugin.formatUTC(time, format);
	}
	
	/** 
	 * Converts the <tt>time</tt> parameter, which is UTC, to the time in the time
	 * zone you specify and returns that time in the format you specify.
	 *
	 * @param time Float that indicates the time you want to format. 
	 * This value is the number of seconds since the epoch in UTC.
	 * This is the same format used by the <tt>currentTime</tt> variable. 
	 * For information about the <tt>currentTime</tt> variable, see
	 * "Getting the current time" in "Developing Apama Applications".
	 * @param format String that specifies the format that you want 
	 * the returned time to have. For details about what you can specify 
	 * for the <tt>format</tt> string, see "Format specification for the TimeFormat 
	 * functions" in the documentation for "Developing Apama Applications".
	 * @param tzName String that specifies the name of a time zone.
	 * @returns A string representing the local time in the specified
	 * format.
	 */
	static action formatWithTimeZone(float time, string format, string tzName) returns string 
	{
		return __plugin.formatWithTimeZone(time, format, tzName);
	}

	/**
	 * Returns the local time as a float of seconds since the epoch (UTC).
	 * 
	 * This value has the same format as the <tt>currentTime</tt> variable. However, 
	 * the <tt>getTime()</tt> function returns the actual local time whereas the <tt>currentTime</tt> 
	 * variable contains the time that the event being processed was received by the 
	 * correlator. The time returned by the <tt>getTime()</tt> function is accurate to the
	 * millisecond except on Windows. On Windows, it returns a time that is accurate to 
	 * within 10 or 16 milliseconds depending on the machine configuration and Windows 
	 * version it is running on. 
	 * 
	 * <i>The Windows and UNIX versions of the Time Format plug-in are not guaranteed to return 
	 * the same time all the time. This is because the underlying system libraries that the plug-in 
	 * relies on have different interpretations of what constitutes local time in certain country 
	 * locales, in particular during summer time. This discrepancy is caused by the fact that at the 
	 * epoch, January 1st 1970, Great Britain was temporarily one hour ahead of UTC. Some UNIX system 
	 * libraries, like those on Solaris, account for this, others, like that on Windows, do not.</i>
	 *
	 * @returns The local time as a float of seconds since the epoch (UTC).
	 */
	static action getSystemTime() returns float 
	{
		return __plugin.getTime();	
	}
		
	/**
	 * Parses the value contained by the <tt>timeDate</tt> parameter
	 * according to the format you specify in the <tt>format</tt> parameter, 
	 * interpreting it as a date and time in the local timezone. 
	 *
	 * The function returns the resulting value as a <tt>float</tt> of 
	 * seconds since the epoch, or <tt>NaN</tt> if it cannot parse the 
	 * specified string.
	 *
	 * e.g. <tt>float secsSinceEpoc := timeMgr.parseTime("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies the format of the value in the 
	 * <tt>timeDate</tt> parameter. For details about what you can specify here, 
	 * see "Format specification for the Time Format plug-in functions"
	 * in "Developing Apama Applications."
	 * @param timeDate String that contains the time you want to parse.
	 * @returns The resulting value of seconds since the epoch.
	 */
	static action parseTime(string format, string timeDate) returns float 
	{
		return __plugin.parseTime(format, timeDate);
	}
	
	/**
	 * Parses the value contained by the <tt>timeDate</tt> parameter
	 * according to the format you specify in the <tt>format</tt> parameter, 
	 * interpreting the <tt>timeDate</tt> as a UTC date and time. 
	 * 
	 * The returned value is a <tt>float</tt> of seconds since the epoch, or 
	 * <tt>NaN</tt> if it cannot parse the specified string.
	 *
	 * e.g. <tt>float secsSinceEpoc := timeMgr.parseTimeUTC("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies the format of the value in the 
	 * <tt>timeDate</tt> parameter. For details about what you can specify here, 
	 * see "Format specification for the Time Format plug-in functions"
	 * in "Developing Apama Applications."
	 * @param timeDate String that contains the time you want to parse.
	 * @returns The resulting value of seconds since the epoch.
	 */	
	static action parseTimeUTC(string format, string timeDate) returns float 
	{
		return __plugin.parseTimeUTC(format, timeDate);
	}	
	
	/**
	 * Parses the value contained by the <tt>timeDate</tt> parameter
	 * according to the format you specify in the <tt>format</tt> parameter, 
	 * interpreting it as a date and time in the named timezone specified
	 * by the <tt>tzName</tt> parameter. 
	 *
	 * The function returns the resulting value as a <tt>float</tt> of seconds 
	 * since the epoch, or <tt>NaN</tt> if it cannot parse the specified string.
	 *
	 * e.g. <tt>float secsSinceEpoc := timeMgr.parseTimeWithTimeZone("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56", "Europe/London");</tt>
	 *
	 * @param format String that specifies the format of the value in the 
	 * <tt>timeDate</tt> parameter. For details about what you can specify here, 
	 * see "Format specification for the Time Format plug-in functions"
	 * in "Developing Apama Applications."
	 * @param timeDate String that contains the time you want to parse.
	 * @param tzName String that specifies the name of a time zone.
	 * @returns The resulting value of seconds since the epoch.
	 */
	static action parseTimeWithTimeZone(string format, string timeDate, string tzName) returns float 
	{
		return __plugin.parseTimeWithTimeZone(format, timeDate, tzName);
	}	
	
	/**
	 * Returns a <tt>CompiledPattern</tt> object that can generate the time as a <tt>float</tt> 
	 * value that corresponds to the local date/time string to be parsed. 
	 *
	 * You can use the <tt>CompiledPattern</tt> object to make multiple calls using its <tt>parseTime()</tt> 
	 * function, specifying the date/time string to be parsed. Reusing a <tt>CompiledPattern</tt> object is 
	 * significantly more efficient than providing the same time pattern (<tt>format</tt>) in multiple calls to 
	 * the parse functions defined on the <tt>TimeFormat</tt> event object.
	 * 
	 * Example:
	 *
	 * The following example shows how you can use the <tt>CompiledPattern</tt> object 
	 * returned by the <tt>compilePattern()</tt> function to make multiple calls using its 
	 * <tt>parseTime()</tt> function:
	 *
	 * <tt>TimeFormat timeFormat := new TimeFormat;</tt><br />
	 * <tt>CompiledPattern timePattern := timeFormat.compilePattern(pattern);</tt><br />
	 * <tt>t1:=timePattern.parseTime(time1);</tt><br />
	 * <tt>t2:=timePattern.parseTime(time2);</tt><br />
	 * <tt>t3:=timePattern.parseTime(time3);</tt>
	 *
	 * When you call the <tt>compilePattern()</tt> function and then the <tt>CompiledPattern</tt> object's
	 * <tt>parseTime()</tt> function, the result is the same as calling one of the parse functions defined on the 
	 * <tt>TimeFormat</tt> object itself. The advantage of calling the <tt>compilePattern()</tt> function
	 * and then the <tt>CompiledPattern</tt> object's <tt>parseTime()</tt> function is that it is faster. 
	 * For example:
	 * 
	 * <tt>timeFormat.parseTime("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56")</tt>
	 *
	 * If you use this pattern many times, it is faster to call <tt>compilePattern()</tt> once at startup, and
	 * then use it to perform the parseTime operation, as follows:
	 *
	 * <tt>action onload() {
	 *	...
	 *	timePattern := timeFormat.compilePattern("yyyy.MM.dd G 'at' HH:mm:ss");
	 * }</tt><br />
	 * ...
	 * <tt>timePattern.parseTime(c,"1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies a set of instructions for parsing a time/date 
	 * object.
	 * @returns A CompiledPattern object that can generate the time as a <tt>float</tt> value
   * that corresponds to the local date/time string to be parsed.
	 */
	static action compilePattern(string format) returns CompiledPattern {
		return CompiledPattern(__plugin.compilePattern(format));
	}
	
	/**
	 * Returns a <tt>CompiledPattern</tt> object that can generate the time as a <tt>float</tt> 
	 * value that corresponds to the UTC date/time string to be parsed. 
	 *
	 * You can use the <tt>CompiledPattern</tt> object to make multiple calls using its <tt>parseTime()</tt> 
	 * function, specifying the date/time string to be parsed. Reusing a <tt>CompiledPattern</tt> object is 
	 * significantly more efficient than providing the same time pattern (<tt>format</tt>) in multiple calls to 
	 * the parse functions defined on the <tt>TimeFormat</tt> event object.
	 * 
	 * Example:
	 *
	 * The following example shows how you can use the <tt>CompiledPattern</tt> object  
	 * returned by the <tt>compilePatternUTC()</tt> function to make multiple calls using its 
	 * <tt>parseTime()</tt> function:
	 *
	 * <tt>TimeFormat timeFormat := new TimeFormat;</tt><br />
	 * <tt>CompiledPattern timePattern := timeFormat.compilePatternUTC(pattern);</tt><br />
	 * <tt>t1:=timePattern.parseTime(time1);</tt><br />
	 * <tt>t2:=timePattern.parseTime(time2);</tt><br />
	 * <tt>t3:=timePattern.parseTime(time3);</tt>
	 *
	 * When you call the <tt>compilePatternUTC()</tt> function and then the <tt>CompiledPattern</tt> object's
	 * <tt>parseTime()</tt> function, the result is the same as calling one of the parse functions defined on the 
	 * <tt>TimeFormat</tt> object itself. The advantage of calling the <tt>compilePatternUTC()</tt> function
	 * and then the <tt>CompiledPattern</tt> object's <tt>parseTime()</tt> function is that it is faster. 
	 * For example:
	 * 
	 * <tt>timeFormat.parseTimeUTC("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56")</tt>
	 *
	 * If you use this pattern many times, it is faster to call <tt>compilePatternUTC()</tt> once at startup, and
	 * then use it to perform the parseTime operation, as follows:
	 *
	 * <tt>action onload() {
	 *	...
	 *	timePattern := timeFormat.compilePatternUTC("yyyy.MM.dd G 'at' HH:mm:ss");
	 * }</tt><br />
	 * ...
	 * <tt>timePattern.parseTime(c,"1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies a set of instructions for parsing a time/date 
	 * object.
	 * @returns A CompiledPattern object that can generate the time as a <tt>float</tt> value
	 * that corresponds to the UTC date/time string to be parsed.
	 */
	static action compilePatternUTC(string format) returns CompiledPattern
	{
		return CompiledPattern(__plugin.compilePatternUTC(format));
	}
	 
	/**
	 * Returns a <tt>CompiledPattern</tt> object that can generate the time as a <tt>float</tt> 
	 * value that corresponds to the date/time string to be parsed, in the specified timezone. 
	 *
	 * You can then use the <tt>CompiledPattern</tt> object to make multiple calls using its <tt>parseTime()</tt> 
	 * function, specifying the date/time string to be parsed. Reusing a <tt>CompiledPattern</tt> object is 
	 * significantly more efficient than providing the same time pattern (<tt>format</tt>) in multiple calls to 
	 * the parse functions defined on the <tt>TimeFormat</tt> event object.
	 * 
	 * Example:
	 *
	 * The following example shows how you can use the <tt>CompiledPattern</tt> object 
	 * returned by the <tt>compilePatternWithTimeZone()</tt> function to make multiple calls 
	 * using its <tt>parseTime()</tt> function:
	 *
	 * <tt>TimeFormat timeFormat := new TimeFormat;</tt><br />
	 * <tt>CompiledPattern timePattern := timeFormat.compilePatternWithTimeZone(pattern, tzone);</tt><br />
	 * <tt>t1:=timePattern.parseTime(time1);</tt><br />
	 * <tt>t2:=timePattern.parseTime(time2);</tt><br />
	 * <tt>t3:=timePattern.parseTime(time3);</tt>
	 *
	 * When you call the <tt>compilePatternWithTimeZone()</tt> function and then the <tt>CompiledPattern</tt> object's 
	 * <tt>parseTime()</tt> function, the result is the same as calling one of the parse functions defined on the 
	 * <tt>TimeFormat</tt> object itself. The advantage of calling the <tt>compilePatternWithTimeZone()</tt> function
	 * and then the <tt>CompiledPattern</tt> object's <tt>parseTime()</tt> function is that it is faster. 
	 * For example:
	 * 
	 * <tt>timeFormat.parseTimeWithTimeZone("yyyy.MM.dd G 'at' HH:mm:ss", "1996.07.10 AD at 15:08:56", "Europe/London");</tt>
	 *
	 * If you use this pattern many times, it is faster to call <tt>compilePatternWithTimeZone()</tt> once at startup, and
	 * then use it to perform the parseTime operation, as follows:
	 *
	 * <tt>action onload() {
	 *	...
	 *	timePattern := timeFormat.compilePatternWithTimeZone("yyyy.MM.dd G 'at' HH:mm:ss", "Europe/London");
	 * }</tt><br />
	 * ...
	 * <tt>timePattern.parseTime(c,"1996.07.10 AD at 15:08:56");</tt>
	 *
	 * @param format String that specifies a set of instructions for parsing a time/date 
	 * object.
	 * @param name String that specifies the name of a time zone.
	 * @returns A CompiledPattern object that can generate the time as a <tt>float</tt> value
	 * that corresponds to the date/time string to be parsed, in the specified timezone.
	 */
	static action compilePatternWithTimeZone(string format, string name) returns CompiledPattern
	{
		return CompiledPattern(__plugin.compilePatternWithTimeZone(format, name));
	}
	
	/**
	 * Returns a floating point (<tt>float</tt>) timestamp that represents the 
	 * number of seconds since an unspecified epoch (a zero point).
	 *
	 * The timestamp is accurate to one microsecond or better. The return value has no 
	 * necessary relationship to wall time or correlator time and should be used only 
	 * to compare similar timestamps. 
	 *
	 * Because the epoch is unspecified, you should use these timestamps in calculations 
	 * only with other timestamps generated by the <tt>getMicroTime()</tt> function or 
	 * with equivalent high-resolution timestamps generated by an Apama adapter.
	 * 
	 * For example, you might want to use high-resolution timestamps for calculating 
	 * event processing latency in an Apama application. You can compare the timestamps 
	 * across processes on the same machine. The timestamps are not comparable between 
	 * different machines.
	 * 
	 * @returns A floating point (<tt>float</tt>) timestamp that represents the 
	 * number of seconds since an unspecified epoch (a zero point). 
	 */
	static action getMicroTime() returns float 
	{
		return __plugin.getMicroTime();
	}
	
	// Private
	
	/** @private*/ import "TimeFormatPlugin" as __plugin;
}
 00000034 C:\SoftwareAG101\Apama\monitors\TimeFormatEvents.mon
CDPF 0001689c 4170616d61434450310087251342048824376ed78380aa3136007f1a21a26c9cf549986c44446d1aa272db844b4e9ab86dcc36c82878f8dddef6ceb68fff2f4d1d1c000254a888a8c8e5db1a2ec38d8818633bdd2f17b88a8a8a4214789aa12271151a9daea9325cc01d504c4305af730cc5626a0c000a150a360e06142c4c7c2c1cc81800142ea84002b20daa0d40f0353a92aaa3a2c8b680c3b74181031b88240f800065636a6832b2a91a3601749e8d67aa4c4536d932cf866ea84c9381649b0c365c4d2d326d489804360e8363f16c2c43913506cf062c01ef60f1b2145d566c8586aee86cdd54754329304c34349da59b728425a318ba6ab39efe0c4553150b802c73202906cf560dbaaab1691c593f9e65d564286886cab3e934f497601e1cfb8567eb0a87a529b467a0aed80f368a8eaecb06db36c0710cba6c9bcf62bac1d1d11e64160be9a483d7d90f01edd8cab091349a6a435bf63ff55055c3601a0cd946d66594428d63e8321203e579fea7e8f283f0341e9efe9dba7c5cc99a6dd2e986b982e0e341569663da0bf2409e4a36476332690f0a926db0f5a53b4753558365be80c436c0011c5b330105c3d021102850905e3840714c2648868c4ae3400050035d45d2000ee08ee570810464bac98160a2ae7896493799a605fc1ffcbf83084840a6293a03b5429ea73f9f8a859b0173cbc44731190c83e5861c1967e16b4cbac6f8e7529129eb4ce369c134650be30183b180b9c1661a4c4d45faa3550d0b86ced01514834d59268e6ca8c7396599581a3205e9471b544adc6172500ca64951ee03c09337f952294ac630d1594ec9ca9fd6e355ed099f81a6a3d254539cdca23cd5781c49553aee9f1e55087806cba022fc486753958d65fc9129320ee3d733e3772a0ee3498f61b2100d32dedf225509980d38d9927b9741a2b3ffc52ae64b6119995fb24180c46069269b0a653065539533f858064703ff2bc589c9c03fa655fe3ed93496a15ab8070c3303a3823901c5542c00858a896930d8e4c97a861b3a78c40a04834513c76ca2a03f35649a8278f0b18c47ead11f959791104b75c4f39bc14614af0474fae34959d5582c833d623fd898b447ac196cf25efde2330c8e38aeaa32a09a8c5fe08702137020bc2c2001192ea88316436d0459efe3b219dacbe43c988f10129f6c5252a8a6f24743fa00923c1af3a89a72682ed37c8498e981818ca273501e79d395476a0e556c341685864ec2791a19e0647b845a00ed43516cb661b2468a7dc832922dc847612b8361f92f19ed97c7a2944bd54316961a0a2f104f7f26d0d8f775e530f6014ea3db9e7836c9b27478ac8230f7adaa158a06d2a30a27453594475f157d88c6d6d06c548371c8f9f19db106f7077f708fa659199d20250da122f99ff3dea7d04d64c62008e597328a29ef186d28875502ca445a27915d8f4a90a4fff19e3712f9fd14767c4afc90f9ab7ba92115f4ffec12710efd2ff4674f039cc1a12d1837522bcda05d08212127905cc48c33e4acdf2a40335fea01953238fc75209240e19345283da0724c075dd441aa3d62d66c644d85f064520f1ec4853df895c002bc456065b970072092cc42c5a27ad58f495b429fb614d7670c673e000644af385e330292f5edbbcffbf95ee7c9fecba699ac9b7a9e11bb705fea20bc568f68bb82e192900de0c9b30958acdfb50c9219316c549686fedc8f60b6c0046feaac9b95efbf43e9fc59264d916d74e3d9fc3804dc5fea32cdb4d91aed24ac18b443db955f6b0bc28f034748b49fea8eca4c1b4dd598379da824bbdd6f08388e6c19896e28436b72e84c1e8036240c1c68381838b8983682898410ac820b979a8836e0a69b2781c2f82e17927cd77ccd24c82c8d03c1062da140936d36eedcf4931bdb563496f1cc4547aa27d0e7ccb333d1a0187fef8a76dde15f3a43936dce4e44b3a14da631e7ffe8f4a3e68d470135e84e3cf56f890e8d67cd8afd61cb16d0551dfc8bccef0b6a74c706c9607d63d8477aada289fa1d1deaa28ddfa47168ac9d3816fbda00d6622f9e1db0b95c9c3f1c703658200199f4f8fccd66eb37be57a0e01e1898ccdf3464df46a0269eee027e077d4bc638a4c3786a3deedd2edede26fe5aaeff3d1be964a10f7a6e6b3f53ff4305ba655809d487d0fbbf29c6a7ce8ccc742923129b5abab20bf811b9dbd6b3596d81b7edf8bc219a43c37e27b00c3bf6574f86aa7660d0e4133d3dc746a3310689a4ce32ace6246459f38513b0e89bad87c1a4dfc37ec72ac7e7ced372fc0afaadac1de4d8f9eaea4429c272682bf01eccb23af367ff8c3f5be1441d29ac9f2423d7c8a692893a72b617602df7a468df87cb5176a23951e57928baef1118fa9289a2d1d4438812241d2d57ba0d36cfd64e2eb2ae0c2e960861833759b43dd2138a1f327a4429ec4ebff939e89e204fed3bf271b3d6cfe747d4c1eb1a0d4ea788193f78b88569fee8f11ffd11599dcaf29d3763de065fa9dcefe0b9b89ea3a1327440de90ab3c811da278985793a279919c5adca11ca7696f0f9da063116043824680858301689b98d08663c181037bc70ad29d2a48ed61567d4c62553e07b68ef653fdc3bebae7b35646368c1f97682c59a73fb6d7d4471433eaa90cbd51ae5acb6844aea78a5d90912d91376b586e58a8960db26daaffa6dfaf3a93f9e3e373f7abca44fbf56d13d845d80406efd615c816aa211f6909f836e1cfc011283cfbd14290b17009008f8b650fafeecf56c9f9b370e6add223af0b2b971ebf07e240a08a335ade8aaedc751f8e605eb1cb16c6de15328b86aa3384470e4c1f1e11295cb8b06c64e31609eb7fff67cdd6ffa8e57bb172d0d91a03fee3a9631fddd08e9cd174363b4daecfc80790b402f8c8f6fd0c1732341b593d0255a70385f038f9b186be5334ed86de1f9196bbaee1b944fde1e45aaa278d275bf3ea76fca7dc5d265c1b030a1e14e24749af25ffcefc0561de94b1a3aff28d1ef22274064b31001cc00b29e77d079500305cc041c2c50234170f17060ef68fce50b031b9f850a04285f4c001cdc5c55bb8478e4020a2223e0e36260601363e2ee8810199000b831a0f7088862a497045568ff4a552b8d80450710f6c21884fc487889b5daa31e631c11211b6402f96fc23d574b2cfbe3d57d5bc111daac6be83508def4e1ea945d77edc360799261d788f50fa977a18bb8f6cc0b07eae660b840cad197dac16f26d988fdbf9c77a3015bf63d29f54589a46b7d14d25358d8bcf159661d0b76744350fc5fc0b47a7a1dae8349dc5b66caaeb0befe4611e188d8604d459710483996efdf387823a9a00ed9bad0cacf7029adaa0fe67044d6696fa172300029cdbf30f0096acc13849ff47500f2bc026b2abf8db162cc2f7c2c75acfbd1213e9db31e62c67a205fb11b627498120900855e7a85a6f5d92281edf86650b66972496f1331348bb13b53834f516d19334926eb0d8995b300700600a9103830308eeef7ca0f2f0014c5103ff1b8b3fdaa60350ae09ff59f7c6cfe9c1bb803fe56f69b36da586fdf10d346da79a8c20b034d4d91db73ed9a6ba69d8bf989bf962b5146e6a12588f8958d4d1c04d0536e7835d76db01df70b01fc920129d80b29c0caf4ac8fbf15984a79ba80ced7b138e5220eb0a64537d293fc3dfbc9a26611bef0737f67f599b813dd3f0fffa0c98d9d9d8cfff74ae5c36d594670ca5ff58f6b28f7a0765a831f37a6f65b6f6ac1344e6e7e222cfae0c22502a737819717fe85015d4020cda09d0ab3ec3faad00d277b45beeb83d5839ef0d1e65df2675bf9114cca2492e191e5193ee7e5e7e3d76b840a840e1d942625b780057708512b1966af6217b0458d8c22c9486ea12747e7be47d520a957d3171b061402143cc93425d4c5c2c2c28586408b932a88b08830083001a1922ae0cea22e2ff884086902785ba9878b82043824e86902b83a8a2b78d3bff7aedcb3648cb1e8b9973a92ce34fc5b58f036c9acf4c4005478be0cbc6b783bd76a2e7b9f15c1629e14022ea140d969f8df68dc62f2f32e938ad300e5a1655998a5b59a73389ec3480acb358b36263f7fb7340fe75f0d58a1910f8a5feda02ee8fecef7621f4a7baab2c20f69d18e9d920e24083f6805e50fd352bb9dcdc75efa934077f6e8e612cdbd36a39310d36c848938449cf35545553cb2f9790f39f1ff179420cc07a0c2cabb41d2212a73f3bd058ec47951f794131c15fff722dcc63d843817345a0858b95725351684f3ab8f5c547ffa9395fbc788b9f49a53796cfe0c13ae5e2859d5ab9df36d9a7db396c1291a09f72309722dbbb08a7009f2e4c5929f3ee85d2e444b230e2176757f0ec99302448b02823f7d21333af10a9fdeb109a877e0a36c18f9273d5532cdc0aeafe4ff5ae68c6fd789ea9e8fc0ce440f8fe93630477f9583f0552533a4c707415f70aaa97eee4d90944db709ce1ec1309ba13dc88c7a7300ad4f5b46d40f6a385fdbb1b00106361a4ebbfe60af3688571b412f07999b912f24238a60f9c2d1a23d18dbe3c92080beaac74298b6b9b0bf4b7b840ddc61e212860e362e301eb695b04498902ab00222cc36c7c28d818b880c1b0a112601340c7858a8b8d6123341381897b0089864e82df51fb53375381e68667477df4e5666aa34a972f97915d69e9803c5ba51d3a6681fe539753c893cd09729258933a594495cbfd47f7a71bb1e42dabcd1f7d7e63a0d0d0b725db22e96c0f54f350817f61660ef57ea588d17c798d4aee20736438a7003f9e14e8cd5fe967141ae712d7a51492511bf258433e734640b06163b1d57d2271ca37cad329b3469f689d91edb066634aad8f8068ec99e875b65173a9df48c81a47636d694a96594688a4740257e0b337a14089c5bce601568a736fc0612e1a81fec85ba32daa46fbe7bba921486224a106257d863b494990641246f06f0ad0f3f88a66eb561363aadf359b05bac5e11d94421cb9745790926d0b9300f01e11025cf7c79d80a9f3293c3f616e396a24f084330b3dab3564c50d267995823a78bd6880f31b36c51206edc80e8978ba3139893ffbefe13b7eb841fa517ce4b17543b45eb567c0d4c0a700e419ac9f841ffea63c39b7a3698c8b13270f57ad8860818edb901c4b5ef4971ac397c1e57aacf13842427d413dbd8e287c908910b2e4b2eba951ed12aeb7fbe15f82942999028eeb4698aee5966a53966833eeffadedde181bb06a2a974a10e442d7f52a9c499ba1d926784ddfd0cb83bc51772dee0f677f37cb6c9d41a7c92923a625a41a55b3177fae9bfe4969162f912a28dbf9a986d284a97e3b8fe164cdb588e770cf5175f4a9371da3ff1c4c1a4b5ef67326146279862f0d59809fc23d6d1cb9f94b55b142db61d8d6e951f5bfb2cbbdba7e371db1737598d2eb9e5d6ad9f64f13ed3f7fa7b32cfeb36118c8b7ed3739c4b669f2448336a94d5125de44fce0604fac001b6e2037ab713b5e5cf75b3cb9ec9ccda031d18df1934fbef3b8e33befc64cf95e238df3b80cb6a2611b8321826ad5bac9b2cd262684e32724008cb521758af35d2d7d9170c5f5a596be91dcf5aea11a294bd21842db681041eee58ed999bc0442c07984231ca43ea4b01b74370a9041dbc0e9ca60c12ef8fd68b7233e01ba8951979c56a37287639d48d6a27a6a9dd517bd6bf856234a196d7cc8020fe97526afeef204c338988436e821a4316338943812ec98be42c10ba147312f783dc78a3d0e7f5ed892633a3cf33ba4033e5718e764de837c7ebe642fc4449d0b6e2d6a93e62c4e030593136c73264d70f03a5c7ba8b5a9be1c57aa2e623e11cb1018d71074a33332a4c370803c134a291f9f7535d1215e1b4e82e731930476a6399842ff0100443e5197790196e06d51902f29822024d6a87826c0a84ba39c364c5005c2c6756ec852a45d986631116c0a96e2678542321f0db4e75680e26d16d0df6dec3a04aaf41a575364b18cc7dfcc1b46f3303e3ef2880c1d71751ded009d50fa0d9c352e5fbf8eac39342c6fc13a4f601af238a9f607c10601a00ea152d8632090e28b03f564ba05baf20a0e3674e21df9d2d4518739f407d4b8680cb48b68aac10f97b0aeb10ff67af9e5192a14f682ac15d901d293f20f2b8639539971a196e6a3663fccfc1e405f97fe9e8456a08d088cdeffa905ff1952ad616756c71a2096cc7ae6145c1745c2d634954f16318912fe0d6313c985f454598a9b37cc3cab1a6cdd50e19fc0ca4458e6612ec6fc24517f2e8ffc4e640d9a0ff689f352b30fbf15c6c8fac78f0b2e4775e1072cee20aaa664b3528ca5619454149b0851ab68893f7bc6059f584ae1198368dfef8fbd4e66a372b81c19dcf5cfe60587e45fcbe0941c20b5a29e53ae0a7edc615834e5bbfe1fe76b637907866afe11ae4fcfaff59e979e3b9df11dc4707797f0edf1b4bb53a4541c9ed84a1fd5ddd7860ded5098ef85a65cc812b289c4b3d1692322b231816feb5b7291054bf60c768e420adabf75f77810eebec3401ba41593b97e13a8877d6eed4dbb806298e0916ce8f8838f440af8e32ddce7fcf73b05fc3b81a721ac5883fdef944e7bc89d88ca0a5dfffcf927dad353ab7fe42d75765c68b2496ebcdd6f29b5486553a7ff33063f4b3c46b869db644b06938a5fedc209ee8e377bf30e773364b262b0d02c6a4c9b392cb3abac18020542f23a451b0700bb871a519cbf3c9fb57f25a64fe8da5f2289ac912ce0bc4c4f1235d78fe8a67cb890e2c1438f1f2b652b877b7ca9b6b4e97ea02a036a1125f0d026ffb611b238ab843ed4206dda273b5a7e4f6afccec98b613bab07d68f9c9b9322ed8ca989ff263fa7fadff6c88c597c0c0339f6822fba8e0617f9e2fa0b92723038eb1ea050fc5a2eaea3aad9195fda87bb5fc20b309bd7764b0ef4a5979822d24592bdc81b5d16e432877397c2b43506b6819cf67e8c5eef580fe7eb6c93fd00f41670dafab5c29f6fb86f0d873d81901310f47b0812437fe81dc2943b6609b50409845a6f707f4ff0a76513562ea7f8de1d6d482d816af51df14b20640771e7247331727f68d8dc3f7b22b7918d89e436f780fb0a2ba65a2109a87ed50afbc24a0653c3565cec50a4ec00adbeb19d2e1b9f268fa967e339450f2d66d1125c7fd5a5dee0de7f016b2cead5c405d95d4b9c98b02d63a53152159d2493437472a87ca983bf4566bd1e2d17df2cf724e11cf24466306eea638783251e2e0c0248d030b8501f00712043c3c1c5ba6b02680b4e897b7abef02143523cb8cd0da5c5d63420d869fae75340d1a6fd0737c691bbc0c79da8d5e75f73d480ac5c8f330c77996b7c82c4ca5816b5a277582f73d5bc4b49bbcb61cd122a253191146407020a85547291617ab23dfc869fae94591c772c1ceefa609c276c5e14c96f4fe9ace50e62678cb8f819baa9cdcdb4eed3bf034f76936f5762efb51dd4de933a9a4d76916c68fbcb7cab6f9e956001430b3daff97b39bc5bbd37c2e4fadbe06b205ef0f0f771b351185a16e61c627e02580fb1753165aedfcbafca073b61e37132fc65ff9303d4977f16b98f5ff8528e418163675132282b52e00adbd80ea00747e1d3692fd79c3e1cfef5db34a52d97f7e0b137464aeac07540b4e0d87033f68bbedd317eb32e51813d249e96984434be3d600dc687a11d7642eb6bcb049820e230d0b400620dba6c7c7b53d7733a3d65807ee7f5e46142af48cef3fa2d9ea4bdf2b0a63803e6561b75f6386ea459e1d4609d1c16783ef42b295c65c230dc24f80a6cbb927de4aeb0a4f9638af327592d5439248794a8b317175c62ad1193eb07d4aaad00cc73c02d19076a8ce9bc7d048370031d7db14af05848396a74f3c5ced47387f3230cebe0d9c2ef165019bff2d9002f0c6303c2e4422e64b7f3c4d81f6fe74867f15869f7ca9cfb8aaca59b8ab21139c1f2f1ffedd5a8a36b6246673a37195116c853f7bc5cd96fec8a6a1c2904106011a6f4f93e2bfa7bd9f4752d3c03d39a9a6367993f2dde8c8df2e70a67a668ffab521e609745da6e7ff1f9a0060c8e2b916f710c9de56d5f2c83ce32afeebf06c1d7416b86dd1bb2dae8794f55962d003c0e26263f6f5d83f1274d5ba4216847bce1df6bafc3e8917847ee49d78eb14d0516c013da826ccffa6ada96a20372bc0d6167d4aed92865e4a007059c7608ec2b3d127a1a49864ea28e8fe936691d7542afbe8709cbc98824c8b06a9d56d8829875025e45e26e5049c5c4096f912ebffa43815df17112aeab8b254d742242c717f2439a86bc04e0b4bc3c9c967e3d61c8baecf65872c8134343be10444632117d14afdf97c662041349b8561c485de9cf732d3cd7c36b6b62d9d8e8560e919c22ca86074f7c7d1a2a63a29d6a97e2ca15badb3831142b400d4214cbd55685ed98ab5dca5d956ae96c9e9ba48199546372e442549a1510c2952bb75975bea44a1f6032f178e8e0188a2cac0c626573eba1b41de694bfccad728e95a50d42b5c5d62864930fcfa69d29bd9c685d61872b7b51c9585c3b73b7395f6ae3963a91c9686765da39faaee83e9fd9a2e109aca15f7920172a8fdf4bc22f6e19bbe637d1a31bb9bac85e01637df1c1b72ad32e03703db59ce265af896c0f01adf01cbeae4b3aa63c2c3a3f2e439591ace88984992d667f47677a95dff330decaefb229a57b1ba67e1d31456fa4e01473c57b693cd55b178f82353c7eb3438a0a1e536c907fed696c6b0de96beaacc49789f7cd1392c11e871b6886816c22ade46c8cba23f2421e732cdc3118b0999639ffe8b1331078df4e445e7d21149562c1aa971450e195891a6351381911ccf8734cd52a6bff69aa066e1a0dd5c6b45309b6f23eb4e2136c2577b28ba68df5a8c77a18ca6be072b29487bd1ebb5e6a54dbb18f9a65e3f0396bc40997217764693662cce8778cd709672da3aeb9c55ccae60fb52cdf6074d31b13030a166eb44dbe55ba9ebdd75e12770513128973d794cc2febcdbd2fae2dbdc7170601c8d02a5f129a2d87da3ac09a2c580b17a62da3b332cbdb93d0b4c5df9b4e5c5a8108ef79c25a73734de521a42250d4382489cb9e728555f7dacc690d345727b3651bc1d631da128ff58744ff41148701752d7e0a2269a62846cc399a0500e208da59f82c3266deea93e1942b397017506bf03b8c1f0e09184882a36ac1fc2d7a01c932c0d135c5183602567ff05fccade0117541c3a7e85c5c5355108f9e17b23646fa7d1784ce3ab106bca56b04354d0c688d417e6adc03c4d0e6d53ffe854072f0a36a3d0e1414a8fc2084d017b809279dda9c2d4cbf15c97d9cda6348777da91b69b39b83aeeed892702eefb63dfcdcd2c13f7f8c5446dc2cb9c630a41d081455903cdc06bc782f0dbd1bc3fce1fb5917947a6912133ecc2b6a092a4e5f1bd2d39d0b9749b90f7e9682bfeaba3011f0503173e02c7eb76cf0e5a781cf9b447430f57f988d189617065f3f422b4b862f4293db33aa8b32c3c2ec22fd6f30fca3997eebc2e2175aba2fc57b2aaf99dee79a45fdabb9819cc9d49f1c071d0c6c2a975f7b279811e3f865efe8c2bb20f250b882d065444e349de59ee7325a8cf5431abd6430774bb507b475e47eb637db09e342c7cd9f5892df4f4ef20cfebf61b23347397e6008c9ebed9cb3b8d7da391644f2ba1dc8c96f0066332bb98eb3d0a82c980156370131a1c83eb096cdde95e6f6cb4965899c910b85266f88fe33e28f49edf35ffbb6d33118bffe97da25dca6565edd24ba79e5b1e8bcd9e99a8ef092d398274b40eef786b4d21febcf67b156ecee60410a788a4c58a314dd001c7b6e4a0d86b4ed6553197e83fcda57d4168e38c2b1ba245f58ad8cac551f07de806be6b596863b33c7ad6e69eb5f9c2e2a839ebc1f9f98dbda4e324076ad9bae482e6240ba192fb34452d096b4dbd2e898f0895488395a52bf5f636bc8e5241a5b1d3ab58006713112760ba4a3894d18cead67989c83861aab08431a57ab3b1856d933f5a223c45e69c3e20187b72b4982e9f9a9c020c1da759f448446471304cff779f6cde0cff5e5174ab8165d515e7f4f7d92f3703651221c51120ba2407f69abf4c3e1ebb6e4ee9a725e618ae6db974bfab81e2ab2f7623169423e12efc5eee3f73240ca063d52f13b5b76a4d1b7483f77503ba68cad9d4c243bc3c1a38ab453cd64f0c8c58a4d6367034f1e025ea50357b43b612f8a48b75f0913c32f83b4d515030601a3fc51720d0a8586ae1013a2a891ff12663ad40ac3947d743fed8a1d666ab068b215e321a325b4d81dfffdab025f06574d2b23a7b88d8d9e4aab609cfdb4fdc520f725588ca4469a46e38d818767cb21eed17dc09b8efd581f93da29a2b613f6597e49d87b92ef4f6e479a300548266e5b26acb59248095e17d26374c2c5d2ab3a3aad83f1e3420f70a63876bd0067069b3c74d190b716ea1e142ea95df1243ce16eee41ae8536bc8866ff2a588c98d0dd10f195ced5a9dd6b143a82444c589157d74a029e3378860c8cd99813784ee6f334dc73b6a45963682b8aebb2967ff73f91b3e422b8ee589730ac15f1482a18a0db9033e2d3fa80f0569d29582c9bcc2f86b181254723a0a4532d8a865cc3adcebacea92f46d8081c8757ba5dad9fc6e88994878e7aa903c38ebf0b7f62e3931d1b11da74739adda76e790141fc04c4ad0834456ef2440dcc0770914dfde77cda2a8d4ca31337bdb54e65302b1c1834062786bbd58934480bf0a4bf75751d76e27ef3b74895414e73de9287e5c440a4720cf28f6c09aacb019d1769f2f8e836de1f5afda8f941df03ae530b42ca5db3195930a3c4434a0f582572739b2145e7219b30f879fa3d61050e1a0c0533ce088980396aed99b1367c20d1247848057a41eda42d66361c65501576fd362208306d3889faa29c9394d0631785035a4b65bbb8b928deb53d9ffe28f9daddb300e8703802aa2e04044512d7e025b06f331440aec14b1b2a2e5428588026d98c31c23d0fe89f9627ab4b327512c893f8057a47e6e10ba5bacc4ea235d5ffcc4e55e636f1b6f52a4b64c83aab266e56bbd2521ba1bd4cea84dc228d575756db253242f7c3625294ea109d9c8c038fc7d547fe74185a9677ab864263c9d44bbccb51339e1d0edb85d3ccd6e5dfb3ab114d5492a642d319dd2d8c139f23371c6d54d8548687162b1825c41fb1be282368d2e58a60c74cd19b5842e5f4d3eb1f0c76432c9f6b51f62339ff64a3e98cb0f76b32869919078551852df1e2c31c9aa743772927d5a8029a51f94200f63906fa7d8ea57412c3ba3c7f454b636e0a2e70d08a5b63c9a8732b38bc45286ca3a1c23c5566c38b60c279a5b076be7f671073ef97c00fb0764ebfd30b6807dcf2dde4fcd4c98b492f6bb2d8e90de9e08bc9ab57c03bdc972def35f0d5899462f043de483d8c962b812e16154bc281f77f83a2d4357bc28cc9feba42b708cba49fe22f0fe7e7e5ed1153f83ae94e48aae643f22fbdb428f57c3a6e84cbc84ec8f886bad44d1d1a26c88befa2d8f16a2d2dece8528830a95b668e5c4631950a79e8e5852a83f96d2b735004d5d4cad3222b904fae2445a41cfe5c6e5c7801f2dcac4e8fabaeae1c96c19d2868b629c7ed5f63950975369ff8afb6a621eb69a674a4121e97506390b075058230662da3f9d466c715b00e03fb3f4ec2b9e8eb8cab254a8653455822659fce20996958e885193b99e56475658c84c954d8ec33ba5642847c31b764ecec33d137a4b527d362d7095243fc320b58df48d7a9418bcd5125191bac6d471fe7347d1eee3e90d7b3df8995a34d8f1333f07badaad443add7c73dfea6fbefc4f3784589d76852232e425f8ff80160da4d65b3d7353dd31b69bbcee3ac796d6f75fb39d060c32ca8885f35405fc51f28ddd422786fb7a57f60bd73029069e982c4c68706091303170b610c5dc47aff6982d7562151ab8b3d03bcf2a85b3a77bef302e064cbf36b42679bcf1d26b2b7bfb2837c9bb05ac91d557c921e25820dc756ceb992ad58f6999f1ab5e14ae26c04bebb985cfde30d0589712143aaa6282153652deb2f336db4f5568c02adc8d7963eb8fac5d4740cc4d8c29155f3d9f52c3b459f46f53fb97842a6b9426c2e7f451ef80a51c847cae5ac49a2b5378eaa1a46f286cf32e50d10b9bc4c6615ec1305141b12643c020c5c2e645c2c1c28788a2d887f9e18e814eefe4ce0af3bfa8a8c3fe2e45e39db933def91a81767024c0ef10dc94f59e105289a22136f4ff0a82b7a57e4f89d194e14b8a8c123b1d1a09575395f6a585edbbc35ee23ab9842d35565de2058ef0045537792bf179fc319b2aacbb2c1c8c18003ce29355a7217e80ac1a936e3dbcf729ad2ceca976be90b3cb393e8ff5d66665c7c35ce7270e912adad5be5f3a6d354d433f063b2bd9f5bc92ddb60b4ad1cbd95d8e400d17c68d9a48ede6dc07a1daf322476368ebe5d43549f9cbd1b2d5b80b91ed117404fc062751b8493a118e0657e317b28916d83f51df2f1439a5b6d01c6b08fa47876ae1d9b3e8da2251c018828a3be2c51a92a603ddcbc65d6276ff0fae0e20d0c5035062a6bac899a6cf0ab7cb875a8ddcf879026f3c2ee7b9f9118eea601e01aa72c2b07dd2a46f55a3dab841d8de8912f3ff473cf6730379fa370417aaa642f7b7fa34aadb7f7d07a7fcd7571c8fd518a60e5c1fb3e44244ede3a63d4ce6ebc53fac892c075524f313f16aa17061713e3d63e3e4804d8d8b8d06ec59f8c22ca79321b2509b6d6502e96651ac8a4052663b46c5e0a0052b250a4feb85dd44fc64092f2d7c34ebe30283a3d91ff21d313e0a189fb543b08f9caa7529b4e56299616e24c0eccf85151ccdd20dcc55b55af466f54c6190d191607373110c812d23f9a25e8a153220207d74817079db986c132519d815193b3704ef84e7e73b893847a296a89800935a4216697d6da0a2f355ab949662cd955d30a8bacf7fecff5af901e301b1d328f0063c90d7a9ba538542a1fe8aee56ad2fed0b6e0f71bb2aa18ed3419f159b407979595d900c39289944684070ac0a0ca4467b9f1208ff2860062a98f85b45f18030d38620b52e0882b48118329483d2f69fcf98a2038324e0c96e96f3afca16f78d699869aaaff7fc66b3cc060ac45b5bde774abb3f79f1018832acd0cb9da3496ed63bef34c6e37c9868ed483a143fde3478642789c0a9348d4159ae3064f2a1c915b0bf9eeaba9c6736a0ebeef13dd982cf645e4b3e302584b1c8bc9ba70d0f84dd0e3e9009dd04293516c5b2e186c83317dfe63b51f85f2849a43d49fc8ad4117078d2d88e8e0915d78966b5701c089b64e58383ba1aa386c6a03bae8c4114cd303e694bf81daa3709eb8c3b6d82a9370eb17f367e2e9a1b0126ab55d6c70d3c9b49b8f042cbe414fc8c81073af99368e94a7df64b4081066f0959e6738f89133f4260b43cfa7635ea33cfc7aa449cee8dbad95d0cbd489b16e86a8640c3f4fd6997006a092eed940bb9c2c84601874e57a040e04f157e51c933eba7bc1eb3212af498a3d8640d8dbce45ccb876521e853f9d752a921575129fe5189672de119aa66c4487515b9b596fbc4ce7547d077f1ab36873f3db44188c5d4c6cdaeabe1334ad93658d6101cf868e6f1b32c7b22cfe54ded76c4dec148efaaa919d10ebc44c3d3be397edd342bdd4fb598a1274c59dff949591af57f2373afd99a678573c365fc31af91aa78563c1016ae58524dd080f38e68016ed9208059449f29cf812e60862f2f6f0984b7e111b8c1f89b73d751f730f8eed87b1ab32512239e7968d504dd07ba8a787d092b6212fd6e345c8ed5a1ab88d76de8dc8950371de7fceeef2bcd43dcff60e5f9ae3104980842973aa968796c0a429f4b657443820a45c484db3e868820c5b9af8a36ad23f829ba38cc5938822ae036276fb5d04c5e72f0bd08a3e65344fb1202929d9d6ff3bcf8a3920a1d158ab9fb83f9db66934e5b895386190183d004776334ad0e79cf8f6f30ba4a30f5080e6270e7cb5c521b817376f7f7f0dc3947f43b5ce9047bbcfb617d2e9d2419dc8e42012b817a7ef28470543351bc2b465a7b3f2b60e03d847836a26586e4649787d9711c39a45259e200c2c6d4e96d02131a6d0a3d94798cebaf31217dc2174625b086f040f94ea751c784d4cf5045fc31dbb7693f491bb79ad95c6c1457a07bcb3db0bf632ec6cf28c6987f3d60eca1843ab31ad9d270aa49b2fa4b696f228317823ef7c26d24e1c9e9c04fc200de8ce8af282586008860f5e0bc4af2c8560ac1b5e33119e90f8dab193ebb76399ea3b3c03de58efaab89ec67e3e817c3aafe5bd9783354e9b3fd25cd8c726f4e74f1e4b944ccaa29a2045d0317211aae14a75f88d653ce2a3f47d45c91c876ffecf312c154591cdd7a078a3a59d12eea28a5c65d1c1e40a7c6318c4811544331c9867fbb09fefcf2a45531a6a94cacfa6636710216d1f503741badb741e45320bcedc23ccf82a7175a16ede2cf1663af45d728338632d8799fda862782fa9ffc8976ce567e6884e67ec6fb5fc846fd24e37b691208cbdeee77c0783b30a5133ac6dea797b22d52039660be1197e7479b498d5666e1e3c163161d3ef22dd05a05870a2c2c74a61f2a97b427da3a867633194e9468566437904a7965bb362f60d885b4c5770db0c0c0b097fb4359f0130b05dd123b2c947c0e60c13e64fd34d7a52d820a7c797dfb844a7f23ad03aeab502aa6b6c9db3bb47e523fe5b62517c2eecc57355451d1829aeef5c671a63b9675bef87f0331bca3ea35d68d984057b6c4112c781e12c5efddeb97a118c453dd6c4eea30306f360463311278f4482c6dab0ec8058e156cc3eb31c049d4edf32f279ecda00f63f6d1387c7bfff490c2c027c5ca25a3c2a83aa940f62c2676aab813b23bc4c24aca17136bffb484eebdb3bc8e77bf3e726708d343e62c1a3fe6d3e3f8c7c3bebbbc484c37db2bd5bfe181acb9df30b1146627b40de4114c9569ff2330212f733d1729279b2305eb5ee1f8d12d89f01330873a79db3f1dc7ff9ba38800071e5e2c897843e2dff727f13dd40d519cd8cc5ec1b5da7cbd63140900c799ec039684bdf17fffc2ce067d3a9f20f1406bdb811fe9d5d60fd16f397ede6a4538b3b04c7e46c40c01a34fae999ad35681b9ad3a030f7eb34c5b241343a527ac2b1e12b2bd1fcfb52cfdef8801635944b23ed9bea4a9a0363d4d628345ae1d1f4ae676e247afe07328a76f3117cf3a2d6e113c7979ec99a11698cc48caefd0b927f7977730a083ac4f4b9e7578707bbccde2f3e61119f4ff598b1b53beb5fe8d725d826da5110674ac2269b7d19cf498b4fd5b28396271aeb48d137271260c96b2b7bceba7b6e6634b6f487b26fc032602fab0cca19fbe757a4ccdb59f48f605618314a4304d2bc7ce97a59b10d850ea3a9fd429b650b70e45929ad22f232a310b66c769bf64c5d99a303289b103ba3696a129fef9b1870db5e884c5e80be2f63a0a6648d84c1175836a0d80760a55367ad50b687b7bf853f1b2b5228f4a061df502f7daca48c748f39757745020f883e6a1a773788f79c56f6bb5299913ca2f0d5287d86f0885670d28e0c6b88f9a5279d30b46cbb176bdc8cbf8060e65463f3484cd84b91eac6ccbb65b056d99769925f347af0c0956b57f6c38c53e431757871afbb00ff6471bfcf9b50de2c059e701f73acde005914e314616ea8ec372142780280b6e0801a8cba61822c0649e60a852e47bb774d54fe991f3e28ffcc9b6258e9c778046ba261ad529450f4de8155d50d22d7b9e8ed9d528a4b4fcddadcc0cf726c546f0d344ead1042c3bfd5de84b7165c0a1d623cc2f1e71c1b053e51f0ec083f9bc53b1c200c21e30c1a2b101e2e10f2f988a3bc6bfaeaa96d2e2156d0632e20cfc760830ad04c9fde647a808f2a79612eee740371a15d833d2f93370df7f2ae7410decdc38f5829462ad1643bbe9d7303a4a16ad9a0f1c21ccc3dacb86424b289446c151ded223364383bf16f827a9cfa1d4d804f5d8dc719e9718fed39d47b34792bf6b19561288a330e3dcd13f939ee1854f19a71b66c15409a1129a3f0a9a21a037383c9d05b614fce69e145e47fa395cf9ca7a94cb6f251cbe69c3877ed3f56a23fa12125ddbf0f18679a3e5e2dea9df04f81d6a23408de5a538ba215e4ba2209a105fa1cf15de90286f268b536b75c1ba58f4297bba618f1dc40f08b7f691104c53f177672e1a964226ab8238ca5c0bcd1992102b1e457d771308f674925fde65c256044470ed7577c7612553c5b7f31d1cd081b95b066f481ad8804e060e51f17b0cf5a121071b0f1a080080862e57f8c4aa46052a09c49dcb1f685aac97a0a469dd59d033d1a15889d5c43a8ee017081db3d936feaf61b2cc6d9413ea4f211e1eb121273373ede463de4bf83a0cf93d4a26aeb164f33941ab5887b66654a0076afd4df3c4b7a25537eb37960446d522d4662dcc4c65f844266dce613d6e28bd2160b10c9249f5981ee2209a3c0b8ffc73119e0af5f3f3bc9e3487dec06aecf8b4c3d8ef59c52a2c6e06648f96a622d8231173f894599c486d93212b06812b558a96797adffb8b2c359d191aa365e4a54ace64da536dc9d14754b4db1350ab4ff8f4372b63b713cb4ad7471e704ea589667f31c575d42f2298aee20a6163e644c684fb4e9cf4dd4e779c6438f0e498b67ff936a047d12764dc396373f08fbb5c0e1e41c65b76677abb4131ead29684717c0800357a9c9cbd304aa76a2027cc994507fb0205230533ea57ab30b049bb2e8099713d69fce5a24dc7a697a71ac4f525fb44e019366cca162654a25734fa10d645395758e4e5f751163362c6ef4d3dcc5e90c48b45fef3e4a6a2c4eef715fa7c0ae4c8bdf4f89ecf043e470e4fa5fe5cc49e8890f587648e0a9a24de155ee9437a2b18d17e12b4606d4315ab3cdf6b634157c96f069eab2ffcc413cbfc36dba7836eb3455dcf43ecad6e8c6b59110181a7270e7641fc00f1c89a9d4cfdbbb884a42711888b416386c2725853eda1850a89a7c6af4056f07e08d099f40a58d6e0bb6787bd76f0ccfd979d056d9a98f1e53273e7fd5380951761b5b6c5216fb6cc4f7ceff02bdce1740d5590398a100883a83fddd0550aef7465e56663fab0b1744d9b0c81c5bc4d6d1d08c55103a914cd96b5c014d1d0b706d1b73f81f7e4a284df2405a072cfd96033369ae473758a7f5f4fb5c9da9b34c3539d2957b6566dd8726ba067eed9f2d45895728506dc8d172092f5a862aecbe6880ddfb1b31623488b8eb95d1913ce604998cca733a6d069c5c4e1c679d06e59c24f50df565b0d191ac1613e75c94259c258ca104a22af2d5fece9a29ef8a235bed5b11daaad28851855d9ec7d2222d51036a82a2ccd8cb9c18b2139ba4bd1638acf39e58fa25f6b10c06aa8cc24bb6372b7b8a57474be91c30d304a73369ccecaf983575aea84a749eb4dc8c446ddfc68d2151c7a9a3c5482582d93b5ba38a8e01bada0cc89e0109a5d519ff47ebdb67d3a631aabe715f7c113032c3a09b2afa85a7713456cfbf1b4ad079c94ce10540cc4b2ffe595e2cba32849f8d2aee0de0b089eda8cfbb9db2736cc11cecd556ef15683a4b5e2d365923f7b44d8cb941cbc640d63c6c3686ed97dbfcc33d85a3a25e085b5713839b223b21734cd650ba23d69e5d63243645b829f1eed9a3e262ce37fae3ae49c8248860bc085671c392d4e6dcd086f2970031940b1a679aa3f79964bcded54139ef9c144c8da6728cab94b4abfb083786e6bb09055e45ba3fed9307366d5bf78bf4ae7dd030aa75a2055f5cac127dfd2349f69e5e1132cc2258c52eb31d327eee7fae9bf03f7e2d092e33e28b79670f19c548f03bcba42bbe60f09579e86c3660bf00fc2c8cfeeddfebf0a36a6f75fcb0d9c90375b04cc633edc737c5e9fd56661315db2683d0411b41c1a648af31928ed7762636d88b04766e2d15430e0dbedde95193d58299fac61eaf6c384ee9cb10a82638105fda4aeda59917e752f829bad6302fcc5559a5942d28e37c2ac14465a7f81706a4cbb4f52840cb11086c4c86495750349917686d6be5bfe07536ed49bc0982ea1b47c81d567b46aff568c5009eaba17d5f232b44b63d4a9b16f238f1a4d40d6060ded0f3180130d951e59670f193d937c31c2ac92693ae10b92129099345c9f3adcb14c9e88619df3092264428a3f3171194a4f16c9205c9c2c18681838d8301e8faa116ea1f09fe5c6141225b882c874cee5335739cedb48d286eefa8462be623796adca6dd6444178b714c31d8293e7d667b5d5606e36c9b7e2b3ec97b1192e7cee2cdcdf53d0f21b78a65439e785e252b209e75f11403f54100358d8d999f3d98b101bd61cd7124ec759da819d096b21aa9e070c24becfd99f0705a974de8b160d72891aaa3a28ec1e70d246ec1ac12ccd18b2888c458ee4f956efba5cddad19f0df1158fe6a69e487ac5b8e04d56baa7c4a0d1f39760d8a61cef2b075c18a7fcdc5c45dae961c71eb6bed3bea9222545b46eac05f348057731da737688c30d65e9af5658dc3bb64161dcc6c50547d7d51ac8601c10837d505749e6e27f27a4ef4333442e17dad2701a4f56046459ddc3b712ce8f82e83e4472e1f64c7e5cfbb66067d5565a976e663fc2e70dd900cced4a035ca5ebc56612b058502f94ca98df5fb28aa1acf137ed5705f161b92bc7f3aad262345d35aa17e1867eea6845675cfb2069c6c46af7993e4edc1261dafd8d2eb2b570a7ec4d6434cfca38a143aef398dfae7a8f0086387a1dca332e8eda75c652f04d74aa81c659130e7b65338b0906c15ea9d5f18e6f5144d50a5f904e04fc09f50e8ddbb00d966c867b2587baa5611ca12b1162c37bb047d3e48e674c5cc29d43b08dbb0ba730d5e38f3cb07b30e108ffd86e00dd5bbda7c0bf5d0dbf17d0cdd5ce77ffcc40633294b4fd05d9366b9ca14e50ee9327376fce1ea5f4b076bb6756b84faa28c3116af98dca018db11f6386c8e830364e7e3d0a824170631fa39de56767e31a37e53a18ce95528bb5e9c7582e4471d296bc616b8f17a8fadacc1c3c7603c8ce8168dab51fff89554aa12f3a579bd59e7196d1615f969fd53ca48e6152703fb41d2ef38d94a21ad74b7ad8dbcf272ea611a5e886d48f2f4ce7f4875a1695bc99844377d62c443fc3be9aa81e4f5fcae0fcd0bcc679db50e691bc652e923d2b8c8bc9bc34049b37e392888cc03725cfa289c5735e38218b8db0731da61c594ffd1b463e49e9d647e0a7e07ae8eea3ab7f66d22e711a30752cb1b0ffd6081848ed7fd0d1c08f4babc65e06929d9d95c79eff94934cdb41542b6a6d5686456d28bff5766503d583c48d100bf25ecdcb36d8e33a50715d17c82daada7497b601e9523cec55735db4b7390896375461a779c675f0a8878098c8e605e4a3895da232186ccde823e5bb8cb6c529e07a672223bce13a33f6e1f27cd417669ffa0055dcd87803da92157651d6f326bc7308450c63fe02e84d6830158305de581b7b7bdb5d756dbbae2d772e0e09707704137129eb0609faef480857df23f7b7aeac810b7736bf94d4d48722e0e9262a43fbee86535719e88120d996a9eb266bc5e7f96a3e4075a17b73f820a345ac9d0da12538d5f1ab485dcff4111653076455d93e66706b54deaad864b16a57091dbf8e634f2bf69a75bebd031ddf1e17d2b17b9ced9ceb1b50568c0666998bcc9da72f9bc632b09f2be8f8562a9fcbaac64ae0879aa9c46c85f74e4395d4b48aa1354c43ced4a66ad67b8c9e912348ee0d979ae5e208bc13ce73f9f3d075bf4cb4a60241117dcb12bdbe6f7ff05a74349a4ca3aab53a7892189e8da555c89905e98c5139f87bc460e2d8b24e92fe7e0eb8a53a43536778beb063360c4d4d1a203d4657f6bccceecd105a695c89190e27295cf3825d5c85a49c6a4e5aaa5286d93a9b519c2b2feb3b23a514b31746a4770539b04fccfe4e68871c7d47aca9d52f93bb218ee67fc7727f56357d3733d9a3a9ecd52521e588757d9ace7ede4647f4b0fa908e64d568c0b22e0131c3454ecf2ea337db8dac9ff5e81cc0974d003c1e403572763b1bb101af9bb65f381e1a136571b2c81cd530c7ac24339a426558e8563674fae07d475dd462982a07453f33318fd379b5e0e3231e391ea209dacc89d2cd649a1b0791df6951aeb64ac7e95ed7507f5d745a7e6b64b9220b32524c582f2ebe1099fe3b0e93ce226e337ca9c27aa34fa7a3db1e5a35e7eb8192821e920df88c5931b070a043c7c5c2c50319d0dc0d495aabb944f616978075c6a4259272988391059def1c0721e040672c5cc041c2c55c1a8342046cd239958faa4160e0cc14907009b03040c6255886007433447cd325156871be4f705b17c7e3405f1603092413bc517b80b15f2f1964bd999ccb44c24f03f9d8251e1de2d1bc377747f33a20730fcb61d64138ea137be82085b5f730dc79f59d9c0d470542bdee0da2627168acc601c94e22f852a0c825f6623bebd199718691e6e06ea90d5166e927ac6583b4c1025bae8e6d7eee482f6766d958edbc5d0bd0cdde66f0ee26579d20af95e16653204886dc8b8aae6a6719785348a1f7342c7709893716371b6098c94f7a503d6e7a28ceb10f2f3df4bec1e5a01391fd8c9ca85a58137ae466795b689416c0e4ae481f8ad7c5803598b876754b9a3d5ba94a0428b87ef4044c738f8abab95e9576ba2ec8275e8c6fd287805f92aafd623137d0369c6956cd2ff8d908c3f8b44450d7de7f8b32418579019c56a272ffb1f652b2b7fb7dd1cbbf28f6ae88fe44431689044c08482001dcef4c40c84afbc7030eaa0cdc7cfc238fdc331eb36eda98898e93c094f93bf8641bfcc1f4937ea59ba3fe9e9973450683c3d294f5af88fc7247511e6edc4602148a27efd91d82d500e78707df849902ef32047189f59ba93295abd4306dee00f623d77cb37f7999ef547f4e4a18a1e313a5f05ff9b4f61c6dc6042b49ce0edb674d5b49a6956e40bb4f2a578ffb0e64fc050fd6522bf1ce45e5406b4022d33182b2c035c76ea37cfc8494ae5cee833e2349369a32f5e0c5486ced870e5bb04830747cfe04471f3ed0db59299b06ee5df347b3534c73f7eda785cae19e8dddcc238007b1155cf637f69113a8e65849dfa93da509fb8c232ab379e015d88df17329829b41c0d062eee8c1238a760109d4cd48aa34c61ed05fe5a62bd409c686a6738c6b84a1de2104510a8c2ab1659e542a910b62352a1e95ca154fa4504cb1202e8df4422ccbbd8883b1504da9b8edd24e52addd95e19d57ccba6f5d9be7b24a1ee3a6478d8abbc4bd9081b9ad5fd67ee10431880565d48292204037fa2d45c09765d5a01caf58d89ce5cc0b4c4343c70f08c59133e58da542319c91567d2ff19731b13336e9862ce4f2da4f20a9eed890f310b216e5f27d16ebffde48342086b3cf065138645226a835284961646c31a50f595f2927dad1e0970b3b493e3a9a04eade7f5da1c3fe5e9003cd6aec6648ccfc2a72b22e96daf7865e1be930326020cda11ff484f466a877e007bdd1f7f284b0315f700a7c1022a96d983f143441215f3ec42aa4b485950a1905bfd9eaac8393c02e147120ce2bb27f67115451147c08bfe1af6c25907472d7217f77df44021ec8d528d7f756db445ec08120bd9d9fc1bda077e5c0d315946c8878865462cfdb560c6117247ccceb6d129bb6645e3fac6bcac8da549dd7a6d59f3d49b5fdbb264be1771da70dfd8659445db12b771b0cbc45a40e3157c781612bac8ab8932bf9945e979280a2766ff3e2294c1d618982868679d7b05650675d9bbc6df1c44f84a06a1b553813d15140082fb22e3000c545d5085622d4fe41f1b5589343e4b1295311415e990ce0b775fc6ec772c4c68679100fad9b3ea17b222929e5dfe1d826736d0b67e1486a483c43abc5338bfae7cee6d7e4c89e815bd26a167d0b3c552e54ad60eee88aeb9a351d4f5eab72c8ccc018ad8bae207de7df21652911e91f3e3ce1d04208af208f62face967626fbdb1df934ffff96ec0c611378f14a8cdbdf31f6154c50f8c80b3a9bd846de48ca5004e26463a61c26229fe7c0796e26068796877f58016302d379e2d789ac0534072e641e3152a2d1dfb9156685c455db885fa174124846b8c5137fc4848d768a184b1c24baed862b82648c5c502d56c28c36c5d6c6f718f58ba08d794938103395f300b0fcbf94620f3c860071ff6d1921ade02ce1c25814beab81ad2a50f92f7842e6929f27e8d9090530213c59f14dc91eb2bd064485c274ebd267da7eb08d45371fdb0a9e48fbe10e45271281e14888680ce452ea52c3b19967bbd19d9c884dc84d82c9450e5b7b8f7c9af2bce465df15ac83ebd39edf56bc34a7b67271ea8f1d16cf9e58ecb35cf1e25edb2675ac13c14718d137ad2ba865562f483e3c619c7d7f930be1f543c570cfdf74382925db8419e96c62e85ae9600a4c149afc0c3cc3be8d5006979dc650d7df05929d299d45fb6ebd7124225852b3aa355f5e0daa4655aaec4884fcdaf9b9634cb295642fb92d5801abc0dd8059d804d83c678a3869784f365de1a674e2f9e36ef16d3c0b0f5920262f7039c0fd3960d9dec1ea3442291db41054e61449dcb913d3c6bc4a86f4670862f6fa96248ab997e1c75a67edd38e4a5448db3d2cce7f5cd4b74cf6236ae2079f4415486c1e48505fc484dc5265e81da217452bcede60f3bb467e6ff58b6354aa8f6dab7d69a6b6e3acd5f3c8057c2a5a8677b3f964392ccb22632ff7056fe2202d6e9fd5a2ab7a06d9d8303f6bdaa1b06315792958b0c634471fb31bac26f9c06c3b700e0ea2c93ecff981f2d4c97360ddda8cd75a4b353b42c90245b22b437e814d340ed011a7e755c028d7a628873f496c3f1493130f21bcad7813d9b482b47c371f839602c9a2d59edaf0464d0d4f5c57f3ce242966a4819afd3c7e35d5e534d690b5e64947ffd0b81dd91614865f4ec05889c5453bf7f3f0c10f46bc449652b4c85e80166fdaf51f822e16376c256f91e4508d1d3baa563fdfacd3346cc908c3313eb050d02ccb660a321a13d07deb88cc8218f9e4962d38b20a26578d9c0d6e7c2ca8c5e68d059df279debeacdc90b91804bafdc552958dcc342855d8e78a887fdd318dcdb62a1036bf8de605d6543ba822ed896b3f8b55dc894ab9df8d201efdad9e8816104e997dc51fd3444f955c9bd4078db6d9bd97c7196cc83d7800e5b9d2fd074e3f821ae2fa32878a084d5f0784ac51491096760425f5c4cb28532a9495e29dd9a11429e4827a0cc5c4c94ec9d99747b2a5f120dac10a1b23e7aa107dcefce8ae6e1d61bd1595cbd0a16e7730616713f3fb2bf2544c7586031db4206c232b9d1f1055c5720a02c24283e8b0119c91675d49ae7b80fd81802d98d94b51390946ce6c5f3a2b0142613808ed2a3d425c44b3740587b189f54325ffb53e346c135b02c3866557e5fa4f10cec1c5ca1e2cfca8e63364a1a488094d43253e8bd01390fedbf729f60de36cdca3d703ef5035f0f7dde2fd3aec14c20b19108c98be39905d2b9a7679858dfe1e5fea79fa8a469c83c0a3db1571b14815349dabdab8fc16a60d1ba0600314400024000608d80009440b8eb75a2eaa8dad8db7068dbe6af46329fbb12392d606ff911e37d9a0000136106d366dc3c9ffc846e98fa1aaa7bee7ca8c0934cb86fc64b2fa7bce62e646082369b4b6f792f3abec83a916fed6918c23b3ba12559f9575084fdc7e53a203522ee29d334501480c1d9c6dd0350e8a3d5a34338ab20c800d100005876f65324aae4996cb3081f7a68695875867571eb44ee2cdf96e3d8a4d4e374b21a145c3b55b5093e2aa006f099796429eed753452e5cfd21644518809c96f45020ea5c15d51d5dc6189efed738a6cab9d415fafb4459f755462754503bdcd9a83c65712c29c3f8252f295947628c2937de28f02b903cba49e82ba78011d108c985387ed330cf43fc44bf150351829916b407dca15dca2053aa8a566c80fc268ec0d2191153adf96f48909c182999ea4435a933349d591b271583d8d6e3806675151f6dc92b8730031612a9426fe094ebdb9d4ccfbad15b4a82a0d75e2425761e06f94b65bd2eacb9b3737d53a6e5b6a5a3da01dded566596b41dee5bc600b366c753df4235e1ebec4bc06b2218b50fef2165a3a8b66ecaf1c7f5dfce91aa631ce2e1e2e5bcff9d89780adc98f8c61e434e2c52c81a36f74dfa64d72397d4acc6c1d35ea26a2b368a86bc476cc298a662a8e826b2ca38b2128a6722636ce34c1246b050dbd055c9ef051680c08dce5a42171f8364c497e012a0160b88083848b05682ee4c74238183850b031b9f850a0428574915e5c5cbc851ba67b70627040fbb25eba4308cf13452af4ea8afb69796b693b7c286e30c9646ea0157d6ce746b25c6bac36e042ffe74185a252b48c34cdcd073825a23a5969ab2a49f27a7a6e0f0bc421b06ce0b699dddb9f52f20a2b4b4b16efaf4e60c3ab1cc4d8762fbf9898d29a60b6f0594d537bc11583a37bd1b3c3e8e1dda961640f511487cd9e18a9e5df0f4b2943abaa294a1bf99f588b358f9aac75864126e77cdbb697a2e8a8eba1bcbe2fe7b712b08769828bf3d7b388c4c9a0642c4ce6165fb827c45954df7dfcfecdcdaa64d7061092da34434eb2e3a6783414d6e18b3c729540b0f5a745aee6a73b7c7b09facc861b1b6681760689d069724f35e853856c894a977e29eccbb0cb4baa5349c79325be7dfbbb5c85b0da287cd23b174d50e63a872a9e572b8279e9ac388a78e287892ceaa217746485168200519852608248ff2068558718531b52d143763fa465b438cbbdce4db1cb00ed14a2b22fd05d47ea34b3aa20d7ac511438c81629935f918021c804cf13cd0d25d1f8a2b243faf3a5f65fa5f0c5333ac3b8b2ac2ac388925c2bb4842a868df2376b149234ae5234761284427010838b4541e7b64e7061c86eae70ed32fa5c575296b23f20de6ab8b86ef0464f86af72ccc896cbb0e83154223208030244510d27919637031ade7934174925d7b32ac90a294f85a10e929530999ad823f81c62667b64269888951b50f7b3ae6a35b4fd7b11e755ecba1045c3c4ec35441bfd0b09c59d1a0f4508fb779bd07dc5f596db306144b0d7773d2cbf128ad12cfe82e2b81cfeca89f70a6f094ff90863543dfcfc9df2b2f03e83feae8e963e99938f675dec137fbe47ae1999b8cb2e8bff6e9a1f31cc8b58cbb655ade63ea04003c1298b0436c497120edf990dde9c4dae98be824ab49015f7e2308824ae6dd14992a9330401441e25ef4381920302aca7bca016c27821b5f88e3063ab5877e37bea1ca376b4865b07672b39e6857f2c9c05f367ab84f443d1a8e1ae71d7012b82f0dc831ab014fbaf80107e2213ad3f7d4aa22304514cb1d05949383acfa6f26c9eed11d7987d0caae4cd8c781502ca6f916ec178a2145675935059f965cae30691a0f1d356353d9659158a1d4e782222574c2bd9c737e14923112a150b8775f4a3ce16df68987337761e2a9e575c6559b19d40124190982a2930ab555fa1d1b0849576877cab96ced83eaf285593884a6d2c250307cf1b3dd652bc2071c4465c50f1c54b997744137d5add71d5e319e834544c9661d08d67e901248063c1ce62e5e2a01a75c4405147835f4a3586945c653acdf306fe33cf1507dd98921efa59cb450e44f19896cbf8c4840972c9ec7b784dc0158b4c5bf4c53bf7b4d279b3b8c2d8c80a587d454b738799ba334249e5866a905c10cbe6e57a0f9a2c16c618843be4c8b9dbc667cd9599239684b3e6ac6368e266e744d8161c22310981759b91202225e7054f221caa221544cf29a76e02f1a2b4231831400d5373b040d77586bc54906740f6504e57c2488798d0288e952cb7799f8169934de61963924990223c7a184784a1b0ee0f1e47927739777c15cb3f6e713af952a9d249728b223c52a5533e5f9854322d54fe502fcf2906750ec2db804961d6a3c6700f3b8bf24bf6c3613927548f0b1ff751a644d26512044db67f460e932e1b80fb180ed954d93058340525caa6ac15173abeedfbd21c4c6916ce132447159e97a02b664e0ad10f367db113924ee807006ba839fef7c1bf270b0eae554da4da2425b23d4ddf1b53b860c8da026425fba6d2186f5f2912c7d391947d032e2101f78c3cc86d3e6367ff4d3fcc08bd16a15139042cd639f8b741ccd324ff984240d7391046dbbe62b4ddd4919f0d03efb61768e88bb0b14ef90d8da164d3fe1d23e7c77b5a2e92f389ceb3c0e91358be5c0a0417230abcbd995c29c7de53bbf0674b78519dfd28cf9ed54c72e9e675b26354732d8c33476743c72fc1df71062f861bc5d15069ec90284afe1b269f74148f5c90e0518c3a06d506a5d1a263710b01cb865d79ab9cc1cec84bf5a56d2fe980144bd8eb80e176c3e68fc1bfe8d64314862d354272f669d6c0d7c62fc181888018ab057ac1764b46a0f06cd811c1887008ed825dd65262feeec9138d7acac3c379cca6aa6bc484c94ff7f71ce76c650870c19d2ee823c1da786ec233ba5283f804f35883030143353986dbf3d22f5684eb474c6123de4563c047e5c03ffc32deec971a8999bcc05e8b6563ac495f650689628837abed172457af9f3ef849b49b4c635e746d4eac97e5011b566f60c162cf0de931514f98ff36fc390ff889fb6ff5e1cb36cb302158d27d5e7f43d15d173afe263fc710c2fa60ea460e83721bfa87b7292d21bcba2fc48200a2b68e2d8b8e989b562b4a3a7caf6b544e301954ff81814d3606e0d9707854d63fd9a555d00e3a3f0675547dd5c521a68cc3d7c691aaa7dbc0e14923b9ab6051361f11a9c6c716124202cd1423d9a2524c2d52af3c939562a4c672044b2dbea85ede318a4ba18a07d44c2dfa01cf0678b28b693eee12afa849594f7e5453c181a9142f15b7d6ce9c3545d02acf2140758ee28d00cbb5b994d7eca4b584599d2f27b4e14456271b8a2c162e932e2379d96291907644c5f02370fcbf78b2238c051d788f6becca0969a61e3161b135bfcf3fd3201108182f0d473ada1fe7c1513835fbc6bb926a0b50b02fa817f7bcfa57005e25efe29aa25b3f8fd2a5cd5b7478aa46ac45adaf1ea41ad4d0c43bfd78916d9d6af0e6b5eb72c2394f3c5336ab9bc548891746541458b5a51dc01b06fdecda9d41c36f2e51c6771dc9d3cd9e540cde8c3bddb471f67266663f4d6f6715e5947276a4eb93136b153203d250b54b739fa179a912d8a49bd16d2720eb4912d1a79c8d901064737e6bca2d2b453edd738c5fa46cee5a388c3182adf52c1a4c2cd69ba4a6123bf62233590a41d2a245d9be8a9c144853a487ce7f7413795ba6658937ac0d9c3cb0654f6fa9a082de25390e65ed494b183b5e977a5fc67293f9116c87ab5b9c7232a44eb38543280c73f4e4659dbe9698f5c2d4a7caa3fcd7d8ae5911b19048458f6f9afb20aba71c2ed0ef7060348c951c3c67ee6de2cdfade7cbfb4f873b022e6cda5ac6df7c0fca95e4d190f10130a26a7188acd0f02f93856b4501bd358e13f731c751227219781441092fcedcb44a0c1b339565243ebe4aec8294869d49a073c0e9b98b0811d7d216d18585c37f99e0a610b7a8f4225906211216f044b20680c8f4804ed50b30ea523e77ea0d0eba4b687e22693f8c59f17e9d6f676f3b7350db5b85a905c9cab6220e211329c0c7e6d0ae14542774d520152bd65aefdc70570c309ec39e330ce0ccc627e794affbbd436e54c5cb885273c601cbf038441804100cd8168523bf1e0fcc15077ef743eccbb8a145050bf04d6b71ab835dbc3ef07f3c9823f563923e8d97f621a27a3eadae244bcd4c65a64745632ec3802fbc41d7b1e9998f0a584cd4fedea64bfa93b593da13fc431949d86c2872d41069256fc5c65956e4db7e6774aa85f54190fb66815ed9b82d93afaf16570b5e204c0a81c308fca6547db4cb1aae09b47a94ae34099abe8023eb1827c65bcce8e2774d72f84cd1264a4e2dc547e18d30b5d470d435399e6de0f26d2b38b7930ab01dae3dbea7a54580722ed4a5c917e6ac6bef1826dc1e12d67ae04450291d14534c8d4408ade12dc7cb8a817c7aecb3fccc80d5791a4492a3481c4b04fe3f4ec1ad6402dcee3ec8c554298d9d25c863796791a4744dcb9b1b715c4c854f7241ccdccdfebc38436b5cc6dfedf905a364635707e02cd40983496acd3bf2d54251739ef497901f991b51b0e58da2d15cdded8f5ad6a9d76b36d24372dbd360a9be7071b3927e0dbd4cc411d6b57d1d2e4888abe1a9d7eb79cc10a0193c641e1dbaccbff260162cafc9af6d65f9e6dc48137d4c3f16707462daa7b392c8d0361156ae230a68c74f60a79cdd7187b582bf21a63cd332b9c51834da34ff16765ae41814e2e37b9e7b975af4bea0dd272410820412c19e1bd2771899de5df74a37cca5213c1da3ef7f9ec7c9613d5746e55817baa6f127dcf89fe111c1d7d91371652953b1e0dacc393c935a7bf700ee3672a7af79dcd3050cdabfa2abf2e4e37c6bafed2e9a742f6ca113f6beb9cadb7649197076549f4d73aecec7c94b7b6bcfb1bf656fd45d6f0f399aef3e2fe61f36b9cf11ceb9d37ba81f298cd71f07db44724c6114aba92b3157e7995d1b66cdaca13e78ef626330face9de361f69b04cbab2fd7bdda38f1d23a6ac4408eaef50d8d4f760e75937e51b9016af222dc9cee5cade34142fc82c3df985688564de2c5a576fc320a8e6dc10c05327415dc49eb0b32adc0410c847b836680905da6c0326a801d9580f08922351a08d1e8f9f310e5ba12f377392ca62f9d10f3a781e60566fd385e7accd56f31479ddb23f364c99786798bfad6448335b35463375d661096b386dbd3f3d54f117a4d149cbbe5c14c9ba42d1772639603ba90d5858975e3e19100ca4b11e9e8bb4dc65786d9a0f8fd094d1497e5185c6c5ed9bebc887b6fb7a8d3f285905cca1b49b7dddadf6220c7f90dafbe950cfcd158e1afce573104c859772908770df0ece6a46d967870fd8d6ca538a8fabcd302bddaf9ae92f9dd606b233c1333739b4a06e3d9a847d569b75f49b87067edbc31f943813d2682c43cb0a5323fda22eacb688fb8081df8ec15472b74d5519d972b9a9b2c1fd55cfe4727b2d68d13399f90975e44dcafe519e40cda45bc70772d2d8e1593fd415187b161d7d1b15a61997b13a54b2bf3e3a8bec418fd8ce3f8db7577d53a098bb18b02c2051d1b1b55c4e7a0163d85d94272e0c9c5093610cb4e772f73fd0b4d5f5c15a808924e1c6cc14759c6d052cce4aae08309b32042c967b0293929a3774a1ab3f68fe2c2a1330d8f8eb8a963cd2ce0889f258b71b8fa5e1021218b66f89d19f0675c39887960221fe44496ba7fe7925d2674765721c04c44190eb7c945ff70de23aed084bd09317d97c00c748f7d4b384cf5a8508d5c82808995cc6c46e87a145c99eeddb2c63465cf3cab6b92395fa80493f8e392f45a3b176589cd36167a5b4e5dbebe6187fe1f9de9c95a5bd0532bfb831fcc271a26f26a53af67288334eb995bf52b89ebaf5684e18295db2ae432256b849cdb5dd5c2c56ae7ac0bd3dbc2c7397eca9e29b83ca36f7da8cb1748d8da45f1705f3e499551905caa7fc2309dee8c6f275ad583a89c153fc70509462ea9cfdf1d3c43987d38f4f655c106043dc21311ff843cf260ee3cd82a0430cc9febc8b05fac5f7f26d80ad771658f7c99cd6626bf242955e27563ad5abd79705073a57fd5f83720875574a6f681f419777f5d080a432704ea853bf5758cf480f43631b59c809413e7b6be035fdeca6fff8c131bba0b958a597a5a09e5b880fa807c9525fbe193b7aab97ac0f3f6022d1ac8ef59a468530bf88b333f13e778f72506d359522b7e7699d77fdad6b985777adc96ee56329f035445d0f78455b87dbc2f7fe8ce0c40612908b821d8ec1f895a9856847aa255598a9fe4424a16b3e7daa749d88d6ecaa3a23e11461d8297c541f1bfb43da33e76e6eeee72fe52a86910c739aedb8d165f8d7287d2357f5295b945ffce015262d13f186c5220f0e29928bccd3a80c536f105d263ca3d3abe31e65b72ae4a48d6b4ce5262d0bce0752a578667d04d1640d13125a1b9294935082d1d139f82d2da554e8c1e8b67ede3a4df5050bcb60e926baced265a45cbe994ef92c97d8a83453359f753717ad88c1d4a4f42d33906c8d269f217925f3680328544c1b645c4c0c2e2e0c1850b03016ed3ea59863cf786e3987d373230e5697c18f02a15de4c8956001e7f376b9902135cd46dbd23a4d5e11b79eb9ea213a9aa8f31fd39ff6ce269ab274eb6a38e32b8c36d7aeffd10fd557c8c4dc66f7f1f894a57650e2ef8231c20f71c4f4fed4aba7e22d0831d9149121affde473d3fa1dc7b54367d0ede9328eebd2b691511d65b1184723d1ce28651e747a6290ab075770d6fae98dcf8adeb46f9bfe7b9c41dc524666d086c1bb6b9c369be0553c0d67779a21c6eedeae4ef333065cf733fa8d44fe54c46d946451eca452aaf1769b54daa0c926713758428f1618a30b6d169f5b59cce2806c2a3a2f720d2d4460d346e06db25f3b43aceccbc99aca7512c68564359aa7f0d715731490e90dc2e1b1c50347f28e4d9799177eaa8f15541b52ffe2dada44e7870e3706ee4337d672b58ea6df008efe27d16e87ab9e25d49491f55b94447f86f880554584f8ad66ea5cf0ffd9a2228b26f7abb0186b69986d804b5681b2a6a7401d452a6b3bd654f3163ba0172e721dffda42f55795fcd463f6e43fa14ec09f3253659bba6bd45271a079e1b5eb396b8891c6d043b37a623536a0332e9ac4ee1827e3ce94ef84df41e3e589c3af4fe8753a53faafec1011cc868acfb24ccfa7cd1a10b738743641a584b505e01cf33d6a3896b8b7e85d8adc28d1f84b52eddc8a9bba69d5b6d04b3605aae1042761c06cd1a09a2f2abb1f0d540d1e1e7a60d146f595242304adf366686d4a5155bcfd74c5ed768e4d356eef785a11fe21d1bd76fe942dca0930890d0ed73ab242531c1c3fa3a731b00de47e6a765195697418c39e353c4214bcfb742c756dcf66d0766448473905b53e4dcb6743e4d795845321a8298f16e6df36815721158adb9ce4d0c5892b6f1273d17426e7a2d482d45a4ac0efd9f72fe6ec39920c7ea6c4b18b464fb9b599993321ed6a8e489587c3c3974b7fe387b13af1f45c8fcc4c75e7abfa3307cb81cb89a292940c85a3da4d371e97d522ca018b75ff9446728b4265801d3180472b823c503245a1d2b5b728ec5014b6982895dc705791eeda4499929147a69877e8f932fcbd759b658ec327aa78b96041e70983baaf31e88767c55e9d97a380279c78a1a510e00833860df34bfd10d1675a96cdb25b665afae5ef985d45dfe5449928e46aad46244f16c41c2a203cb7913a10735248703062db7accb6bcec3744be3b4423a4768bb9740ed5a5763566b00ff1d4f624fc3badeb793f42ec45e538be94a6009e5de9e0bf39332190ec457c675b5c07d0a1a4d92c976ba7c4463cdc253baab49d3325b579d7aa7bc35d730d85d1d6b2928b59ab97a848619e92c3a9730deca6f938cee865ea69cefd51f2ecb01bb113305f0eaa228b8eda8d74cd250d41a7d0e7aade0e4665519e40e52bdba742e976b567b8eed6fc05b437a31c75fa5644b75de896dbbdd15f94457e85be2ddeb3b3358f742f810d8441f02b04107436c4d5134175d42fce1725f028a8990feb23cc65f51c5ac0f64e94a7f02505848a6388c22a0fb55d5736e1ecf2bc153727e6d711f888a0195b379c083d48068bdeead434465618ccd8b93c8f2e8cb11af10080ae9f2d0c05a56545f24f734554ed1ba0eb217a923ce733ef39ed1bc6a4b6e7332c421bf6848d873693da4cc1aa0c3b3d591eaef22d39a59d3e8de405690da05dcc707343e4662b080b2ec423721cf63a1707b369825ed98338ee8a7167372fc5b17c5267dd023294e4a0deadd6163fe12b5383a59bf22567c264c06e5c3f15d0f8957a42ad64bc956b49c0bad26c882eee399267d26c5e902c1ac7196c8dbd307e0fe3a5d6f36e0cc2c6be6627eabc2e0b0d12b50e1ccc51efdf8b2588a62f76450ed8fe69c0dc15103bc02ed2d057177f97ccea8a7a1c6ca0a1191c79c049d1f6a5549c5310df04eb0ca399886d816cb57b8cd28a3d271e5e674d71eb0a7d6a80164f4b342074d92a2875f17aabac23cb3fcd64e78876a584b4efb31dbd81bb4404337f650efc483929ed554b5a243b37b8532a5db1961a70c7a9baf9d6807b9081eeb8d54cd3ae51a1af69f75b43b95730d1c6cece3cfc8261261e2395ade8edbcbf95f8b663315667e68f23f27f32cb9b3e2aa892677577809ca0eb1fc9f53b25e22aeb009c520ebd3ac22bbd73041c74be2fe7002481e9c67cd32539c06f7039e8b6c0cd277ed274742121e88fa38be040892091a149b884a3937e45ae9cdb99d78f81d5db3a15534f2c7cf462315c449d431defcf413f18de57faf07990e29a6c7513757b067e1b8f9da027e3d67d74725e7fa479ea2760b071c1fd0a910d7c74c1119cc6b802cb4301495364464ff121f4041cf27af6f132a50285da9007432b392fd6b59b30d334b8f18a88137a3b24eae7c2d0cdc35547b0f285632a831a9feee689311b708da1bb3255ab3ebd474f1525564d72ce25efdcc339871efe939f62b2914b8e734e47559e234a597a65a12b2fcf86f1204dee9bb24b275c89f75848ded94e9076cafbf28034b4103f444e3ec6d09175edee8bbbb192e3099b4e37f4c24c2d4b5bd199a519e694c60075823a81d825a01c7f51b6be73ea889adb1f7231ecdd3a3c5b487ccdd7bdb834600f63acf847bc797057b409f75384b1530a520af3efa877a8843a773b145d6e9d21f59ed36d58740f5d6f3bfadc23cbf1c9ed27166fcdabb7334d4b59802f80878081b46eb12603891fc57b32ca3727d0d9842b102fc7b5aeb1be2525b468731e719d79a23bcfae4e7d64f6e9a4a4678a7fac67397d55472556639384577c8b4054a83721f001eda42443a020313828aac6388dd88f3134156908f219dc36792fc2ca600f61a085d15bc27579f4a33e979a5d9d38b29e984a22118f42ea71dd4d067dbb7b350937de2d2cdc844527504d94a5224c2d756687dfdaa28179961f325242e735cf9919a7c7628124c8ac207411d6acd60c54e2a8d1c8f45990f8fbbc2c87ce2883ccb524374eec7ef76609b9ae91511bea6ebdf551e19d0698439657733a49b2ebcbeb1c39b2b18a89a6b5473a0476e29c00c6cefd927297887c0acecc6485f44279bc4d70b553b1e87887474156edb935c91422959662c328d151ce6d1765c66828d72b9a513f242d33c96652a877b05914ce0ab982d8ff1f30249c5ddd8a3a8fd913f72c12e700ea90f80eb82306ebc004e94216c72ebf3a447cd73f2992fbfde47036c0f5af56004258b2a25ab5b2920ee7f170f423d8048817954f4445316bb54bae721f78e2d127b58e631b8b3e1a72b1e79334f316c5c9c924d2d9e916379adefb3c20a723cd90a89a7e1232ea121345020a446870291f728c24cc59af0cffd0b4a146182f18919280c7a8ffd9aecb172b0cc6abed4497c3da6e67df5e0e66ef84cf4cc6e6c671af9bd33026d8f36e064dd19c1bb2241ffa1f465e484d9f1883e38c50e2824e80525448990a6a35082b7a08ecbd862c7de60b2afca9e23aa2a54ea1fa185a94a2e533cd75446c8c053b0fd2f10adc27c4f16d7cbced0896262e9b2411284763a2af9a8b510b7ac66bcb47fbfcaab2f23472538d703af5de950aa2c800418d6a2a45e35b271551bb50941cd915ad9a13b74e57b19012c7604579e6aeac4540de40238a894e535153c5339bf45f5b618cf45ea2652ae884372dde80c2f09aaed36da5fddcd4759114f815467e29a53f8bf55b85b3f96f931126b563abd515ca8902b028eb630881747b45be6288206571db281477ac73439d6ab3483c3b992a25ec09636845822ee624afda94f3a3a63223a816169d191752cf94185a6b47efb0b80dd65eaf5064d6c570b2f343b24d6ebf641deac376d6e144f54e34fd32fdd56ae2cce5541c8a31b61bdd32052fac15031c725135575d8307f3dca87734a1eaaac89f0853943f40a7301f32d392fa164b8d6edf87b6668cacdf7c71deaa17acf98d36bbdc47c2f8a94ea4479903b363868b226709b16db1495d328b04e722d5508509a9482133ec7ab7e371635a417658979881da16c80d76c2d85009b009a03f40b5e989cbb81a1ffa3362698ab16144c9654f5e25576707688d732d03ef047b25affc89898b691e3fec8a5753540366e019a827a7bee4314dffee57bfb89a2d556e0f9a1bdfab902428cf18a2e81c786470c306bb1d257554948dfd62a0f22ddfc40d192e9e8ded7bc7baa6b81423bb89b860625c7dac310b3529b80dff89b526306ecb991443996acc5faec7654fa8517cb713a0b444367aeb9c492ede4ae9e828b9fdfd167d7c50481ac1ad85cd88d052370c2d758605ebce633301d84234b018caa69fcea962fed5236da173eceeedc24e9100e5ea7406a0d6edb59bf67aeb144777518c2832bcf3c8c654995241b21ab84decc0dccaa13a73ff189ff1758c6b63aee93529d492120b05adde4c09dccbc31cbafbe8cc0106052df314454a8a972988a4b1d894457ab6640157c1f4344cebdbcd7cc2cd0b76cc3f04cbddee51749713f3d66748753f46fade1bb238978199d5b45520bffb53669ca803fea510c0f89d2799eccc366bda399db8905e716663a6e67ec7f135974dd87a046710208c41a359f7a3f4329ae76ac7a9f0c844ba9ad75d2e33be3a66224df99b681402658d079d4a1bda63440c4dc0ec8192d9232508cd35c464a5280a8e0fe5ef031fe394d410408396312bd51706440df4bf90c640d807b20df7036fd2a1fa3ed0ffe26dfdf0edd423e1a48b6bd6b30abc5c66ec03e69ab0c3e24d80493ce422569ac8dfe2607d6b17a212032f8ab677b196f8ba7bba871d79671b7cc57182cd166489a5d4bf8ff597f2029ca6c59e83ffc638c513c2c13bb319e3b707b9e012a510856e4ec08c7168dc271aa0b4616804a7838d8b8d67af4247121071b0f1a080680fe204f5d437920037cbd82480f8002230c3ec9b7f71303170f03111f47f9985c0d0759c3661f9c72f9da3d85da4a57c26c0b2fddc63f9441aa29a5bd7a167376c5b3eed4bd244eeb4cc24f6347363b2111c5d1d77b049deb5cd63b496143d6f41ff3f4ed3c1b6601b141a3a4b5fe5b504749369dab26132f9398aec7a70552ba14c765672bb4ddd85210bda8025df463764e48bb01c06299198699b2856a613d32dc35a13b11a9adcfdb8103f366513fd19496a8c4d087b8f9080a8b30d89e415e73937c1eb465b971dced8db4fc5d6640318e4eb822e504b4743da7e05591b9b7b0aaf2309cf2c9c922377334589c3e0c4349e9f71d71887f8fc0e37a9f69aebe24542c7fcf4a39f7131800af3c254323d27df3966d892398f276b341d356bd55d7f9d6796f4234df34e037bfe41d8045071d745488c43618752651ef3b75250d7115c3afd4c08996a5cee081a05b974da08b7cae6b83f8d7bfcf0b60a6eac9af8f522ea5035b1b32c4f482f2bbe25195aa12711990205846b0b66bc37afa88d4663d58774489a3c55e4eb8ecfbd801df1f478279883296c85791e856bd99de162203fa4feb0dc6740f5bcf95662f7712580bb00b6ae5cf529bb5e9d057df684c95c797aaef28297729e144d3758ec61d05842e80ae5882cc52d52b7375dc16bee0454f20a120aafed160b8e5df3ad6e28a10100b8086a3dd3c6059f0cc51bbf92764dc74b83be3b63bc8b2f54dab7bf6953b7d049c0660747508d93ebec6da8936d4e6e4c42721784d3a41165c45a74185b418671cd2418110513faa2ef6f3c30345ce7dbe45230afee28935c5e2b86110f055f1bc7ff98a9ab659d1e15847aa336652b92ce2d0dd645cbf4685993b1694c10a3574386ce48b0da26e1927223e187a359dfb6a7c51880b737ec0909e3a8e5c39c58b75357ba428c714f2a224c1832a60e4863c1be617e837e2f30eaca08ab0894bab8be35e5be01e04f976025b6f6d8cc8bb020a8b75ae234ad6ae0108c7428938f1b91076d0c9c9fd655444463f614ebdc674f846862b83d5d7dc2bf7d829582438f1c61dac436acc4254c305753c9b198e3187fe88561aa1c94798aaad150515651db84cbb7c9fba857b95af11fbbab79968bca17d7a5f072c4a708723df7697dc6cc71e03f15c2e97e45349f8f1ed7284c643a39b4e878caf3d55d3a645604dece93b6add45fe33187d466430c1bdd7373085a2ab8402e7c2671d8c61875332462b5ef76859d28734d00b2015fa5c613058dde11db28c5461c79c8f0926480100b7eac463115b8476636ea45ad9ac82612352477f24162e82df9a8768aed1c37269091303bac08f30f5ae7182e5ab62aabbc8d9facc01fd834a54cd4d3ce1ecb53b0936227dd5f3a271edb0f360e1a7a3b3d1a0cf306a1d80771a1136080848b152b0c3bf1fc046999d7f75aed846c8993739e70769b6503dfc79236132c7126ca0932aaacff3e7bc11d41daebc8fc8e6dade7866b95a211e2f8a9ec1b9a6c244d5b5a49ffbad8714278f4153318db92c9c3e57a835e2f582eb8b6f3ad31943186b25e7a191ba25e86e348145dfb99cc67fe463f759f88acb3a783154cac5394c90fa7fce1b8763263bb64acac1e9e41be49e43cd1732880529a3fa3ed7d2c038fdc36c8ff700d8ba5215fb6bd6591d8b02d9b6047c184f40992cbf8e3993515c2d0647e54115669896a9c09d7f62ed4938b818f979f6b7373270c23b4142b83b32abb41b1c6747316713553de32af2e1fa21b7c4e6e4053da82cf85ea091e65d79a704f0d2960bf8fe14fbb7f2380b1263f675f1f80b310497cb69d27e9424e3c6666d8cd0a806e565c0e78e674f829a0a6edc9d7593cf5a4e7713cbc09ce629963de9ff9f9cc4e940766c7249fdd40b46cc845a74c95d509a2c859e763fc191807068c0e213ac9bb84da18ec5494cfecea6ec9c90e0998fadf0d495397cf8b4fdb7b1add2c9562e388b67dd098a9cc6dcb2a4a5e9a250ba94341ea2f20b181d07f70d3bb4359efe48793c22c5b30e7fc7b77bcc774198967b3696b4b1388d603a63fbbb29dd96ca87505e65ff353882f51c741803544610f71adf82d9ddc38dd41afa613007693914f97cc5053bc83afedce86f1aeaab4bc9905262aaa7a9af90f0f4e347a1d6de0b631bd03b08cd4bba2931d107e6c68297edc3a3bf84dc8bfced234a2f963356f716ae2a47510f12f4b990bf4fbc52d8bea933b98727897f73967147922f9d89a3d9a9e18c518537ac32e22b15a71667f4611f73c460b5f6b8d375bafdf25a73515691cb2dbfc4f23ff87fe73876485094faeb93bb48a11370c88a5bf30234e7c393fb2bbe231769c0f9fc0dc5f47dc550294fb2a4597d0859a296984a8ae2f2edab476f83520927ad8597107405c10a112c0af98d51de9614c44cd991b8fe8f085f41cf22dd882e2aee9e9dfc632821288dfba17b2234ef60129680e49647c3bd28c328470759390fb338044fccf32fe39c9193db533da3907eb61a1d02a81bc1e2c6432142012521a982c007d646822f6a319c480249740118f54b9e25045d97f1350176b1617832d4ee1bad2e58aab5714a7f0b0eb176ffa5dcd0bf5a66e3657281e2def6dd42990c33904525715f96c66dadd410a6eea867fe11e57623bb40bf6be5439d25f292d0acf8649688392a01ea65652da649e0f3974cf721b074ab6b8e1da176c312e705de8bada448f3cb79ada3be03ee3eece61e0e042c3e38208050bf0b858985c4890f1083070f1b8c7d86dcf01f6b7d6455d2917ff7878f2200b89c4c4dd941817ebe26993e004e0512d1b8781be5182d39262fdc7e02a14c5844a80810f922f30c0de7a8ae6246ca817c96050121512360ee020e172018f0b68cc281eb666d95313b5af24faafc8a6b3280b3929232e260e00e8d1acf54b5f0303f7fc2e29b2741f324da364353941cc21a520e2e0e1722163e1c2c001cc82f177c7154e4d2219e69462cd8e635f5364494960a327ee8654b1eb2092f3a9d1469ad2db2354ce4da532daf5778cec207359cbc510c9dcb68b91a51305c699c9892b1934999817402e333d0f8e66950a6b2ede987b21dc5cca6ca8315ad4398ef45ba675093e5352a2d2e6e572d9c685e28efd2411a9b30df37bc1c292925276d5bb72e5f20146a4e8baa0c20c2f3c0ae32265d017c213983c463cfb13e6de125fea5b87546082a1ce8bcb18b47bb68269c3dcfe12f2307ba423fefbc014db2a32e3b1eb596f8037336a01da2ce3cd9d3093add9b636bc63de62e88c3da753da4cfd8c123d99ce9c40e9e2af3363c82ca494a976582988268887a362893841cd0da8a6baa0e4da2c24a9f0e2e9cbd1c1299e98a0f9499d352313d311397e3522fa03c52dab4d0216490f173cd1043703088a7db878e60da310a12862831a9c0cb175ca910bc43174c18954ac3d7f2b1c3c26202d08c318996d5fc96d3b876a909a6fc2e75efd988e6da09934568ca2cf350c347510f6b5af0f1b8ead34c8d34134b861e13200fb3c99916c20d8632eafdcc69af016c5f102d8704e2916102c38fcc53da405d31e68e27682932d6baa06823dcf8d69a4c60eac67651ebf8b67eeb28957b829a579c502d6cd1507ec0a9b758eb742148c62af5938269ee331f694d5669d256207a03474ae2774084a23483e68e9a1e2e03c4d9369e1b45e089dcc1e5701b71c8f1f3179d47fcb0f9da437f6b1c304c73cfb452a8b4f1ed93c58b1fed151945b31ed82d26ae91b5c2eb3c6207887c9769dbf53e02436f3760dfa1878ce7e36835dac6c89a8f5e188e3e1dbcc342f7634dcc6839e5b8ff400f6ba26419122316094633ea420b491468118abad0b076da1419f8b6b2ec68d383f55ebdaba916beb718f34d34ecb6adb67be4c7cd702b3be736f3a0882fa2c60cc306b380102076bac50e839dddab6a18d400344fefed6432e0d39969324b599889bdaf252ef377c7fa2aa9db8803a36e539152a3829c117f522b0a919f1757d4ed472ef65b5d6706ff2c3351069d2375e06b71fce3d6e8a255ff7ede90c927066ca84eee7bc2cc9ca0acf5ccaf8d95efd25efed0777dcc8f30ff229550bad7f581230b385511cc6187115786ce68ffdd516393a7266d856a0470fb85f983b9f17de1a64af371478483ecf8552f29c34d92b93500a742f4d4a80e9dae26f9f2d3485d2b54947eefcce0b2e479ee8ee6d555345a85eeaa476a262bfb5f087fc6f31bcf13a9cb7a5b338553ce035a8635ea17fdedb751fea9960ac0c0b13692e838b81218ad3aca4386ce53a12baa3219bc6693dd9c9f8c5346a4a561fb101f3d13a3ada85109b33016e53d5f1414a7278e9a857df46550b39e1c3e8c6d8327d2a5cfe899192dbfbf5638935ab1cb8d934045b8a6ec4c211400886cf7763044a760c973c43756509e9042e6448ea555223a57c7b86ad786bf78d645ef4d4e423d692e1d20fb8db35f431926fb703b8e1a730058a486c255977e20346b2f6e4587094304fed7aa5e75e8f5fdae97b18a79fcb34e987e12e8379e576f0fae57648600efc8d01def24247832933da6c324a599ffbd35fbdc93ea553d7d6d4cc06b1f2cb5fab6469502cfbd8fa08883019cec5c11b60a7ee7032e357641242244aa28e302bf69281480e9a5721f8c9ea0235a6b70b2c2f275e207a59f4833acc9b259fb3b679fc5fa043fdf2e2c186ee024f20d3532c545fcf2f52ce13b77fd41bf8dfd69bf2006b781083cce0810fa79a8bd46d58a5e2928d21f40853b96d960a84bb698459abcfce1267aea12cf80671e6f5c1159b322ab68e5b323341c2d3153acb444af327556f5e71e1e3a3c60d3ac01523f4261b751929279b205f050c731dbc85715c6b7c2d12afb85851d23cc396a0daeea5bfec1041d5613b1175d814d074845eeda492a241809c4babff2e74dc2935b710fd23d1fe2e7e89fcdba6e6ca4914df599756e189ea635dd5e5e0a9212180222104c7462804e0ba7f509cf70f4a38f0889f3fc25192d491cc0e6ede55c36d10fc73a72e2bd7c2293fbdcee9c1cf1135a5832232a43b3a2bca58abb21336709e8661237a182e7627c30226d8b12e31e96c571c4bd7aa835cfa980fa052a1e5d95c45547e146cce9a20658b835aacc4c1939f276cec73e65f5fa75b335d784d6a20bb9b782839ffab083cbe46249f3b97f321519a4cbb749dac3f3d16e34018038d8f818f9c2909e9db37b2db214f18e2d69024451e978737f0d1c098def29b90c8a912b4c133f0c09994afd0877541538a3bb7083a3fa84205a9be36fc1e885ebcf02a0ecde498bddef62338d830a0b49a8a5abb9790cb698b400032895c9087f76203bd2669a209c59da62595ac0ee0f3aa21d349935708f17a63b103e639fcb4796e17389781b78ab152fa53b48ad0b67b37bf228d823327f28bb35eed7ea2b7fa325bbe756b2933dab6f5f03a679e31e7f383a7190ab626e3827b0981fdb8c66dea9a3521ca8333014b46d93030e42ea7ebf278bd9770af32b1d6b87e5eb28fb88dea92efa3775994f101544ac136213c255085e40c070e85af0c3d4ec44a0eebb9e1e83ccdada4b073a83f661223437d13c38f0147344bd4e9b7d82c1ab58436146c68808ed155ae18aaede152a8b14d808d5723f1a29de1c24c10863d10ad082661666384bbcac29da0566b4809cc0a3319054eef530403164fca374f024234cfeabee16aecad1a482b85b2fa430268d010fb44e0fc5344d285f2a710f17dcf548e0762d5139ecb7ce806c73c2736b3a7a51966577d4f5238bbf6d2d652c1459ca36aa717daeedd7ad8c042cc952c6a5e66c90e99088b92f0ec87cf7e06a418852dca3290a29d16df5b03000985d9620b293c0911670b059293f451e213d89f27fc0b4520fa53608893b9ee8a01a2483f5b04a2fa2fd0f95ba4eeb3603240d27792fb98ccb4d058477ca3e83bc9e14dda6d534d7d4c83129d3ec942b078810e757d2b8dd13672ae238c5ac5e4f3bd8d213b21988beca11bd9f5b68dac484b531161f1a6f664d42e3b4f01c2a1496dc225449ada8ade50f3d41d4954e71aabdbe67c02348ec992baaf66f2aa7ef023bc23efdc236017da5c92fb40479a15d5f70cc8c7b0d097a1ca2a06e963a92e41905aa277481ec70407c4f54870408d06e9dd10a2c34986e6f80cdaa87795468f34a21ea282892c21c6bc50473f89c8b242df730fb51305376ef748f6812f3975fe4285c7197ae0242e024a8a71a9e004dedf22205587f042daf78ce8147b8fcc6e42ab405e5632e291616c4a719d1052b63e93d372d62d1a2fd1919d002b7194d590a0081948422f9a1492201b00e9f6e0871779d8a609fbc2f0d954c4f2b634e563a52e4372a8d528035510c9be526a1c917ba1548527fb3aa9820054bc4ca9aaf5b057c03aa3e032251778a9e5cad5ed9a955cd135fad293bab3bb55595173422dec867e1f9a54a5ee5c1f5a8f6e5fc58ee890849f85fae93c46585e0b20a9ca4ec2404357ced1ec6402001282a688e4366a19cc046301f096c3a776edf7b62a1c81df74c53c1dad9948bb4db735cae1a63cfcfdb6d5d2ff36bdfd5dc7c50310e28874474e9bfda3abd10873025fddcdcdddcd69e4c8110d8293f35daccfc9d19633020dcd90cbf636ceb507ac3105ed28377bf4f28fedb716fc86990f28c16150b77c8294a1b9c9c4ab43640560db35f66210f0dd345ef04813b371ccf88ada9d15b98aa938dbd7d1621b4620e0f1593897e28b2ac487219a15bb4535144f41b2882efadbccf7d03bab3cbf8676ec9b175d86a503757c679906f6367c9394214f12fb3e33491908d0c0dba0f77442059f70ef737b4e2f84b2957ccca085929086c6f56e36bd6bbc167b7d48b1b6dad629b4cbea4df621da052087b75216aeb76083adbd9ed678ed04b640b9ac9d05997bd9395b4af99c884388ec8edb10abe1cd9e989d0579bb3822acd14dc84cbec5753a43a2cb05e90d3875baafa8714820518000902000708020dfdd8d2fa45d291691c53a14f9de1ff3ee87ea3a1bc524a40fa9baa311e6c7dc26e5213c14de4f51cf1ef7679bfff20b5d07974b0c72074c415693b9647c6852db7ef150d23d8b3537e427b33cc5fdaf8c59136c5a253345782351fcf4f24d4eea29d369c94a3a976c057520a89a83bcb95c6b38e9d6fc5641c723c3cd99b7aaaeeb3f4d9507a088591e981495044ac2565dcfe7dc72840376a9e00a9374821bfbba90841d12a80912f92c9b942420244852d915a1692fbeafec12704fd3d78ea30bb71979f6687b9283e0898771100b43c8211c90e0a37ccd6d96f13a43eec2c1a3637184cfdeebba0f53dbee88834f759a859d6cd79b35e09e1b7955a7e6982a679dca2c357a8ff266269f64adb53d448b19562a65def5a826aed5eefa344e557bebd60f3f1a93321d0bb54bd92ea7974e90fcefa29b8a2830c69105b58aad173c4db2d84c0e7a11db0a816712d7e4a0edde7d6853edb4848fb2191344ab346f86154da8286f9fd4e9b151556b7f85d0029ab618151b1373c7aae91b2f2e9384cb255a73c7589ccbc3ae202172e23c8100c31c392d41864639b02fd071b3e90aaea61c492b975460acf8c38de25fc5fe5e0238ff0679e89afd27723aa6db35db1d2d6163917743240869c1c692f6b05716799cd0ff4a452af958de9d2b046b032ab4bfece9e311272d9731d8ed48b9f8856e5a136a517b902d7085ea9d8c5bc4eb66cc280a8326604451a62c50c3651a0a1bd3d0145dbd0307e521bfab682b8bfa2248ccebd4fc3439e2d24b361e49f2b8bce2c7bc5c10769fb86d9c61cdfa50c354eee9b68d1f6b72060e7ce86659424a4f2d28bbd8812421835a578965c858129d254c2a0955ee95cf8b46525d68caea10c9c54ebd4a2875a394c38e58af3cfe6cc3dba3ba10dc9e043eb2b883e3bb9d02a1caa63023517d5ce2cf796ee413a50be13828f711128a5cc9ecb958ee3a3ca6cefecfcebbf8d98386781d04c270b83c13006f02a48b457a792c79d8d56f249c6f5c6311ed903dc8fa8fcefd2ba40ae64cffc1e86bec38955d3a338af3bc47ad7dac763e5cd353dd6b8e370d0b1354c432397c363a97bfa411b064f590c118d82046551ed1671850057fc6bab044194e282f999f592a732336ffdb0d1ac5e99a410ac44d989f64b084c4ec2b23e78a1ed874638ff3b9f72c9a7e799cc994f35d8c9eac87a0880670bddb5375ca65521d14e12c5b8662ec758c9a4995d6e996b7b29a02c16d188ca7a25c51219f57752c96574599546a28d59eeedb903423365719910d62da3a2ce59324c4434c3c34e3242c035e4c0560a04986b511692ae088564272793041f4182bd2b090c10af5227c4bdc4ac9eccb5669554463c0544c15995515aa4184aac8526a2f45b3fd10bbb343a5d07112700e2c2b909f1139a01012faa71dfb97c862f8a08d80948625b7e1ab94b21a25c9e369860a3e4d96509902496a9206842c44ab17ae1cca280fda5ba3dbf33d88f506104410678707d8be52917de958176994f2a1368658de51c6dddc77463f631cebb5bd9b3dc9ffa8c435335d4f5f268c2a271fed56823496c6a69f89d20c315bd7ac23ff0df033fa3bf9f9b96ef332f6b41d6e02337e88d2a9185a0e265e2ec6994b93e70781f487c54a611120ed0c4e0b946a4bf7134facc3599bef92c9c390454d593db00fdc65841e684166311a0e0f42935af3f643af62ed9b43e6d6f970d00f18590e33b20860b448cbe3b0d0843ff30b13e889ea5f59bac4a57bdfaf370d11becd5f18261a313aaead4b28aa7721e97ea5effa42810fca625119e6c110abd4160c810a692d10f852da3142bbc350f0da70f8e7cf7fd0e659b7dd512108091c12e407516847832c18315598680c22518b258728262ab06b5ab139c464bd6b7301a3da4b6cf75081e4cdba1bf542d8621d106bdaab77bd40f6341aec2ca4015146bdcc4ceb2093008a70c6a84c6c425c6c22426c7c3c604d38701e88b3312fbfcdf626b56c7aae5639bafe0bc9bfd9fd8f3633a4fae1eb83e2223837989bd1ff7ca459835b55264736f01f0d1253dbd799f86c95ce9a61f43104cd65a9f2eb31777c9c14b94b905f52f98ffc5d866331b417cb010d1cfda7ee3708f2c71c593e1465445d56e28856d82b50c80b9e3d140769aac453fb53126bc7f942d9226d40a3bf362ba8eebdf0ffe4642c98b9f7d32dcadcd6c2bdbe837265e9a32e487cd0d44ac3e3b3e02e4fc8ab69d4757ef436f93928c716a037a2b60a1311129040848c89019990106812403d3e0f75325316f542892454030e22010121b6a79a658facb97e389963138e7d92cc4efbc53447833d545106472d63acaf0ae0fe5d1c0575014f3fd06a4f963ba25b6e963e6c28e2c35e4eecc32e50fb6365a53a014d05001759b0789125f39e95fb729f67c1fed5d6b367b105b3338d053cd27d5621451540c6f6c6aea0202034649eda418ba2a1f212a009b5d8ae84d8a8cc680f6fd57ed064ade5aece2a5b7cac7b3de9bfae08c1737c8e976e76f592a57486f3842686a78c0a5ce1a98c4ec1e3e365087f78b5ea0e1ae2e81595bbfba2258a0d86d8c4675d9b26ffb670a8f58cf16428fa4433ed905e6945888d8d8bdd9ff111bd30858e8626235613f8db8382977059ef32fe557fa816f582f5295b956bb552c36c88f0d85c02182afab08809f148b0f1714d2c426c40e31313c266b102a46c3964b01e0f07b3adf524c61c4032c2983af52c2b12a81c15fd26746f3731e3e76ada9b6fec2e4d4798d85da67c48ee1760de6a69275fc6603017ccfc9eb8e5994af3f0cea5cc66afb129ce4d8ae56a0779d615e82863b4575c5a95b3de5b8526cd2d12d05e571bfbe33ab4d6e2c60f07a81250d14cdb5c00cee01c3e51da724da01d038d7dd07b009335c4f49dd2ee12b1405367d2f60ee6388fabb50d9cd1ab106b363ec9a26d6ba2c4a987686fe8de3c81a9a232ff664c92af81a1ebf48cb13fd4169e361d00520dbe89d3d83fb189aa53adece87a2e32aab11605b3ef28d8bfe39c0528a29651a965d14fe01d283c573a4b4375302680dfebe361a98295a654ca4eec0e3c4e5939461c534f6686e26c6221e3c21a1ad292df5394ef19e63c527021a13d9243707acfb4381d2356466249ec857831d534b706e8344e3beaaac83b7e9f28114eeb9abfbefd5ddccdd018ed0f057550cf75a21c49f3254c4f462d633085f483edb93befe7e8d69f54087820396816a22ac6c89d07509a9a8f64a8a9a832ad809d8e6e87d850984c3a6bd28cfcbb968afb5827ce9d79f555fe7cc377b59eb49c567f7b94970dd47385fd4c390b924329e32a53520e85cf037b2f336973b3d88e38d00bda986e9d560ff29bd10c81d845c0ccea3f1d25bc6d983ea8e3deacd384c2971a7dcffc96c1b869d58791f0ff45b6b3774055149eb00f027c7742163422e1c458c259645d52bbc5c9783c255ea14d7e6dbb559dbb5e8a9ac12913cd8cb3256ee2ea68671da8b21a9e481e51010c44426c4095e157603260e24efae36436d3402f56f48c0d29abb91346ccbf12653c02c9a61224424c1222124c92a24c43432e2673faff4bf9f76419e39e59c6481247140339fb68157e5ae1002668b30e9f7b709bd7bd668c031a097feda7e4c55d1ea6ddce4f75576dcd4383a1cc7e7a466395ae99c9dadbb97d8e450fc02d25b71b748f52ddfb5426863f47b3e80703f8b0ca8522987ba9321814769bd0d51878370adf8ec74273b4ff88f02ad6ca63f0d02d82aadb3d2b2ab6cafd4a945a812c0e093177e124088596a00693ab005e85f2d8142dc154eafcbee9340436677c32fcb37f868128468450fa4e0f53ddff634f84d0ed5d43ffe796b7dd8f7007c0c92a70d3d1c7401e2bf3302729d13e0f233b244de1a521da04021a778769874420a5b18404fc1582b6c1d721a1b6bdd726db5012afa40153bc5a3e1a4419c3179550eeefe25fdbc556918977207d766e82de1eaee747e780907d5bba5f5ece24e312af6b5b0a93a937b2ff9c056b01fb4d04e6efa33d5e9f8eac8aa1644bc9e7729b5330d593272e3fb6668e8a4aa4f15159eac55e77acf6283264f5661b3807706df25fee037a335eb9ae018dc2242b8382014b4c3234486a92f90381e122f0733960d47788382be9bfdf7dd472c62b22d151a69efb4d877073f0b587c388ab6ce878cbdbf257e91c78515f076a8b679a8aa7599f82fc7cc096b0a1d476718067da24705714e396a265cdf425c15fba5768a04247f9c94225d240eed634d330159ff2b786ac03afe8242bbf8881fbf251a185727b3228e0e317f311c2c9539e615e1fbe49cd4d26bd257252863ce127ee41057ec0444a02dbfc4bc503ab5d013c840caab1aae9a5d408d1da4de58503e547967c21c9cc54563e915ba80cc72c433d0d9b8caad8bb9c2a556751ab439e5d2d96011f594eed46c21e6821f151c8d270d321a38671c94b6f3cebc68705d14339253ca42002a0982a9df1e4e7bdbb1ff8d3754aec9e0ca18fc459cc0267d2f364def7418b36231332e831e8ac0c1ce7f720f4f3aed119c81f0d9b635723150471d2fb9743ef63d4afe31616a494ac3f79a297ebc5e716c0966f119cfd2404bdd9cf2cae599cdd523ed74903883dff8960f94946c50996ad62dfd0d801aa0f8e5931ca9ab9edec7da499cf3b13a40693f1d16f364a1c6f388c6145ced016fab74e2bb8c72a16386bdc8d90751d46e801479490b6098e7c552f340bbc002b599870ac628412aacb964ba6b55a0a054c7d71269c6144d9e23d80b1a5bb0f7129dc17ae8be24d363bf7176d6fd2f62e9df5f526a3ce4113b0e655383817de39dc475a956c25fe4ea7ecafe7a39692d28d824bca06543f6dbcbf37c27f000634ec8cac3f63e650bd805625097d6a7b4135a7f05a4d013d7d5d4e7d374a15c4d4eba3807ac8a875fcd71453cdad41e3723fe7f4e9eddd7ced5241312f497eb3e1491ad47394da222cd8817da18bc93c4d76f0b4828f0ba1036e76908890ba84faac98ac88b0d5e013f9d762470cae2619b25e072fe5519aabbc43a20f7c6d75c7421ea32935d2b28a16929b7cf1c2c5b1e56e90b7b6b6a43b92be57c0c713ba7b05bfaadf54e2636a26de913c98a02e59cd52e8bf5814d6afc5e802dc7ef129b7a0b2e7ab0b4621e4828c52359222f7bc8af0f2d16a2f803db6a9dfc10324681cdb52aad1ece2c6ce9ec942ebb8663016be112d4603a941550bd288200cfff82f0b9f842e57d535922bc80908734f55763573c5225fd8dd1b82d0bb2ef1a77de9e90eb8fa272cdfdbd4f2781cceb7109dce5391c949c5e268f936b4760314e35f217e9de2e80ae37226c25f1dda480fa29c6700e3bb533da9f046c8c9fddc9a7f2d114fb29c67091aaa7eed8a3c376cef2b2886f1ae1162cb61841dbca9ff8a78d92d90382e06f27f0fc27315d5af80e0208560623b270f68831df50c079ad20e9de334094f3a3308cd7195065994874ae7dc9016f938c56cb6b53364c7b3a3fb1cb9d95498ae6ca6fb799ebcf5d9dcb49e9ecb7bbdca53fa7653a3a33c4b8b61c839bf161fe70a4546e1dd78c4ebfb8dd8a3b7e27a72ea0ff77f277502a71b72eeb33b7b6f7c4c9b99eb5581731a605811395e3504a586f1d1d48afe57148ca76b8d52cbf57a755aac3bf8b95d3c4e553de336e6eb0efe78c2b1b5c390bcc36525db4edc923ab2fe9b428738a7cd7126a37329e36669047c68e74c9f59747986f1d063fd6c018074c5d113e398d013d6355e8e769aef8906645275c05c902139733c554f7980af3277fe73425b15f1fb25648d6846cd5c7fc5751bfd939a8e376ea30daa83debd6cb5fd75ce408f5db5e0935956653c95454143d5dea81cb5ef61e4c15829f5c7f30e047184d9a38521a4983de26887f460da201d371459e81a4e9a10dc55ad52d130a6acb10ad9e7dd834dfcc12926ffcfec7b80d1bc722101333dedd51199d51834299cdb58e159083e782e9cc4e11e1c1db4cea39f0f97caad7f4c34e8b50e3a8b6fa3df0f2528313e160e09766ef79884d8f80084902823aca1de9ea0f2ef4eb8ac5cdf938b2fe0fc403d1867400eef14234ad35bea6586e6cafc78b9acd46d04f7c9f95c93db925a9589d86db3f04cc49e67c38a840d0e2fad2281e0073260bcd2e07db4270476ba3c2cc2c364e6725681ce7e6a7fa7a3bcd06fe005fbe6daace2e8fa107e2fbedfcd711be754e773e5a279beb5ffd817255b24251ee82de69fbba8d19d58b68d8c1c40bfe9758bc62e9c438eb6788455ae387b6a6642cf545198da658a3a839ccb37653463aa2d001d62c4b516e61a59d2998f71f932d8c071dcff1f5fa4802a1ce422211b8581b484b077d5da614206ab18d7bae4ab1f7ac325bcced74a9451111d475ee4847425cf3af7ca4ce45cacb107ee93cc105bd348188c75ca48be69ee54b7b539effd4b375bd15128182ac5da81eccde3a60e22ea39897c540c414f468ed0153829be40f9aa9bd75afd346c429a06d54db8d977aa59796f87d353ce6e07d49f446c0aa3b35cabb30dc4797426f32d6ceefa122fa596b35e6be9e4a375b7f8577671dbdd4787de6e541599776ea261705f10987f2fa70aabc795873a3e7d0bd7280361c96fade42a46d4b8efec2cb4a57e0ee324f8e3db75751616c56c8ec9d3d242d7a9cb85ae6063678ec20d45eeca96100b8623e1bfa4265b82b3a71e4f2617336e8be9e6c8d2105d955ab856a682943acafbaafeb4c83bd86ce2983dcd6e7313eabdd6abb7e341677dd86632243b6a9b054c012e773d24d3f3e9f419a11b44b30156299b72d1f0691c24a1d76095eeafc200cb0fe82b56c4a517d1f2284aacd44110ac58a57b0c3e072ca6ea836931c055d75bd1d70e533161c6deb76004f3b2da4aa73543eea9b6d4c356b56c89754b960871e42141e683d559d0775aceebeed114b67819533e67474d8f0072fce2c4b54d6082d36599cb44e6b3b6f983fd6cfe5d94dabdff94757f300dba224cae64bc8c1f888a65b195ea1b01990f413c5a08080482cdbd164f39a57d3faae4b22c503986d48e74de65c52e659f07998ea9a827e8fbede46860f53a73fa41ab2efb4dba5218a4d040aa45cc2b22e649da662ea927de0055a2894f6b856b8c74c8c4713b495c3864ea5ca45c1f94d79359cdc90a9943f2f89deeb4baa064c16b8cb711e46aba608dd0728b79bc4f1933f9c06f6af299ea3bda094d9dad31d6d7f5d2d9faf89e3e67acbe604c2ea56739ebb5ca5003172893e22777d1338564cf5fd12a1d06542773824ebf79da336db90c2c47cb625eae5a4ac8b8342d572d49c3e51f8271aaf0addbec1c1c58bfb990d44e8b16a1594c26dd54979a2761f3a1a9a34d1683b5d38a0ff0ee1701d5f670eb7453846c6478b6839d7f1f574eeeb52f977e225f8a7a06e37a2e68e61bc8ab8aff47f8cce00e5a41d824e4d7ceba6f433c081d5e0c4eaee72e3cd28179dc88bf6c325147a3fe1d586cf717c55937a5355695357857a1d68f6d57510766bc80650a789cbb02ef119ba23340c56bb5ca9746bd27a14188d08387203e671c31788bc44fc0a6723186c3bf26dbdbb278191eafa6ef262074118c8db94f3bff719aadb395f8233e0bb8c919b02fbc6d3b8d2267bce51a99656a8b75cf80d07a47fedc4fec71af7f10f7a9662495c593c48d3d9d34f8ac07c53b075eb13381599fffe5c550590c8ca2f1db214be708e6fa37a5de245c953d1b7f78b8280fc168d72fc564d1dfe727747256cea4e388810e9aa76f92f2bda498ea3b2efe1d5548e02eaefbbf53b868d12fc5702b88dc6aa6904801f2053be090b69c0dc84bd211c98b3da1d8f04214e7a08fa72b067267442dd007e256f020ff83b18fcc6618174d9593cf8bb13f0e2dded1d450289ec6cc7e60b44c25c5c2aacba5138fc70feb7eb56e6d2b096d3216d15b7a31759e9392ded020031c5d31c1ea3a8a127c5e0e65055c0d9e63a0c6287fa340bc36b28e87639880a57f2ede79a408f5fe1185076907e186fda2b9fcb7b981f9c1032512c10ea9598949e461d8a21ff1bdfd7d593ab0a867001981b87e2ae7c73dfe2951ac381c3e4f07a772b887f8f9709da6b077c2f5b6a65855c4dbfc4f68ac1791ce465199ef161fa1dbab6a5e2e01d0358e7616cb9b0acd105f6d9a1bd2dd5609dc32bcd0d188ec7daf89b9377a413f56ddd6c6bbae7dc8faccaf5164c8e7887e62e3d20f4b1835517516fdaf84a2aeccfcda9a572c7f9906f0193d239c276be45e573a8b50fefa2c8ca28170ce32f5088b408e133ac4d598c53d6b4387465d475ada69c28aa906fcfdcd57d8d4845454d65d96d3743c676b3ca64a31592f63251fc0447077315f7527c80720dac53cfc82f4170a5d4f5aabaf855fdb597543486a8317dc64d37318665f2928c100372de5e3cf058220a3c785ae3a4f8c28e9b0bdfd825a776b58e4bc8029d351d9dc10c51966eba3626b292052ffc62c7ababe72b7921153bd931ec79235d596859f71dcf6287570a5a4796c65d207b0750bb6985819cb531b239b13c5e2e948b55bb1e8dcb9b0f59b7bb3f32635b418feaeb8d438f27a34eeb01ddf413c22a763acd750b4b5287d7fbdc7b9bede029b31ce0ec1d3513e74f04de98d07bc1cd75be70bc3bb7de1c4c4bd667639c0e5f718ca8ecd0d58628c5c03fbe8a2010ac868b3539cad9fbf2dd68ecfb56fdbda5cb7075f356430f351d7ead69da0b1387c23ca478227d6e6e5d7ef9cfdeb9b45f54437f21de2e7cf2b430c864eeef959ca921cb2a60e329cd015e5d2cb7a9faa535216d71c433fea3c2fa961b838ccfd461a0a378103252bee832f58112f8084a7ed0170fb67e50b6b6902dc04b8cc3ce2e386b96363014b5c5a07e510a90c22b68c1b419c70e2947f3541403bec487df4716dff660d74e457587c14055cff2d852eb914eb45a768a8938b9881f45455cdf6a78ef62a6da0f0cd6a217d34fd747b93f60f0be8abf1975c1a5e138f03f7b1784fd3f50b6cfc4dd0d00c892a367493f2ae533211cbe8cc10137c6bd5293a143a9b3d5ffe675337a8c14394ff87bb1297c295b5aee7377731b7b5ef1173873cb294e743aa5cfb0a872cf7d86773ac67005fde57d64196f6a10acd4616ae4c50a1e707bcef099abe65405de7b950ab798bc40fa6ebadcedcf813bceb33088991cea5fb41846cee98974bb214e37e80ac5f6a4345bf10033f5906cd1172566343b9540bbbd655bef0236c320bf7affe43551cc7532d639c784d209715190217e1f1332257d9ec47f4b34f7c492d78d6c2a5273b243affb297dbfc858dd67adaf1f56ee68fd5a5f272f355ace4e3488001ab84eb885feed22bd5d1f8952593e08cbb194376d1b4edee07caa2cfe93799c9c426a3f1d1d08e0c5d3c26510f84904b2aadb8a5cae2678eca7dfad8cb3233de0d86bf7fe2891dce3b71adb6a9274a37204a1df1584d473e6813106aa580457a026f6a12b1c6b38364b3555634c9eadc38ba9a9921f4d9be366a7d58564cf8a7aa7bb425a6079752c609050a97d022a707ce0aa51657e273e180035960df6ec3093ea66d69115ff31038ff297a7eea709c4fe81a6e2cdc753f31690ffd72c52f9d86a62d96c6ee13f4246f83c1e46f3b7eb02aba1bad3183d0f350b69f652f7370d9ea685e3b04abe4895192a39a188298cc836ff38d4a49442ee8e8d285d667cfc9726db82dadd39da01bb57cbe4de4a456df260859a1fa8270dab210472a71cae2af946f883601cf4de01e30aefd6319366ce5ae3bda15dcad740429c9d5791a9bcfb12b38b011a2dcb09d5db9814d53b9460f6e502ab1cb00288ce8d55a43d7c7058fac20fd426555495bc8cf1cc09b4665a10e0d539850138aca2eedfb3d8647554b8b1fe03239d9068d1142f062b2d83b1170cbe65a2600916c16daa28e3b3720bce80162b6ab86dbea1de78e4aa82c24e1f918eddf7090e21326b75c72ec2fe582cee27f5f787f9586c254d173898d340b91ed9883f682e26ac9ee3c97c41fb236610ec501a458f00004a418e6768108c453cf03fc7cda604ed6ba69c00a451c56bfa61878303122ffda480139fa0029fea55e8ece426580cbc03d607cd005b0d5f9f1f30c085b03ad73337019487606ec71b30ce8163519904353bdea74c6468f911e62fa05373230d0a1884bea4aa6b54a0b65b4ad488e1b92502aa040b658c2be272d9ad30884178fdf94a44533da80f062f13b86b458461bc812a7bc6b0bfe98ae2afceaf49a5bc4c69f620d7de07a86f8c2b41aff6e51ef45fa99a783f151088f6894c0841868126c3c7198e5a5e46aba3dbdbcd7b45633d1f3c42cf6abd1adeecd306e099d977ea1fd8c8fac1b5d18aef0f4be4f812da523e52bb0fc31e9bd245eaa9dd842e7aaf766f3a12ede74564155e7190f2a41725191f452f6739ac7d77c138f8407d63c67503983fbcba1f5585eb4b0b7e41aa4330fd296f3214f4551cb64a1bc0cd1db54ffe0186a8a7e349d7d7afb275e1d8e7fe73a3ed2c53dd6516dd1afba76b6d9f7d9b8eaffed0fd36c25d0f575de1f958adfe94717c68b8b80041f3221d13aa1092ca40c3bce34cf05cda8fce4f352424e2ec90b416ba82c9579e4c50725792247af1e98787c1ed8cb7f54aa6c4f8144b6974ccf38291c49101a7d21e82c900805193aeb3ddbeb15203e11552032523aa061770630f9a189733d3d9f2b42f746c325ede3506923f2aec972aa13cb3351ec7cd7de724d37dcc90d2d86df13b76a0a5c759bb5da859126b3b57d5f04d309310d1c3b9bcaf8af2e9887fe3cc9c2f9fe59df21e13c9842cdc61a9b2b76771891ac55bbac69b3cd0e376cc712f6fafcbee2894db94f34bdef244311b56e6c7d9fbf961dd51f28f9dc039f83cc4752f6db60fd003ef8bd01f114f4367cd0119e8136ab1cb5b7ccf3ea7b245443bb9398a4b0324730c9f9d38bfcaf11cb35c0403a41a3ea8c0d7785065ca2b12bf11d7e005f6718245bbf6ff75ac909e6a43cf8264b65d9bfd29004f204c321172bb7472edce1f15d540e1f7507aa738e9289f225335d49fc21a4cabed40d4bd03226e0ade6b54128d2b3a06f234cf772f2c9b0f56e722ce89fca1fea6dc4b506fa13962fde26684e423463896c45e7801974d9424b167818cca7a047e07c6e0f6d38637873957b70b05f160c096a640feb5287197206d215f3972538d0046c799de67054e4bd2acda08b810139d7c82c453f248822d05809e5a173df7ac5588a61b8f4020aa90b0d2412008ab1a722f87858982478c4845818c4b8902041c4c3c704140621113e263e2e9e887adc4d868c8b617872b9f263fc733c0cf182c681926287925a41053bc8de5732ca1da9b5f9ec11b5db44a68903c913b520d01d26d922dd232735935b4324e546d3ec6a7345fceed1db893640190bfbdca25930195d52f6ac07f19c353c7e2d485ef22a8a12d80ea3eb8f2770e9289cb3109c33d662983781f2f5b89de7ea589a4d75c6a53f47550b917b445fc2d403e355b538261a3960043009ca43e509bfa642b6dadbb6b4f1c4e0d2c3ea8999f5a7fe676daa5f8dce2f274607ca3d155509fe387e463616c9d112fca140512972f24c1309b131cdc47644a462183633fb1a0c2834d58b5c0ef84d749df17609e7f3d6676a0bfa5693f23dde5f7372f2a163072862a5b23eae107fb4d3bcff699c71f9c7a232323bb71ea657cc45067ce48ac75847960e9369f6ec1907efde40b85e19b7867c513175b7404ef9f5a81fd5db7ff5229160d48cb0a7b3fa3f4c3b834414a483034e1f874fd4f19289c218558befce4d387f9a8cfebefbb3fb93b1435c83058041b80a1301b71ce869a9323ce3880c798c1a1991dcc290fbf21e8ebc1b119b8ef895ebae1c4a8c9e96de62c5046c0aa59e0f5e3943f1b1b3dc98ddec90db48652c55623ea835832addaefb6170931d5aabce5e4e6984c9a6b78f43823599a4562c1e337132d733a1dc807c20c710b3deb33249362b7fe97fea276a7cefa8b83e73f0a6b42b607d86aff80b7286385cb26e05e4fc72ed8d18d83dcf30036139c3388ffa6a915bda70359f6c97ab229004201dffce0df68724e5c15a6816fcf4ec3b874b9902c60f37b333a6863b5e6886ddca741272ad748d54037926b2c483c694eb7567003e35c3238bc7c161b7471dec72d0e221596e22245fe115322353dfd557a754a68627cfd7cae3999620cd7953bae751be219def221968de4d6dbb4ee7426ad35467a405c314633ce0a1d27ee21b90e27808e5dfa3543067d72b144a4ad951fc68e2d67f04b585c7f1ce295bf5f48ad96e2bbca352b75fac36ce47b89eb39398fcf4edf4b3132796bf9461a2df28e214ccf20796821a42890bff89e78ed662541bd511d9726e26ab1125818bb246300da25970ff28f8094446c62ab969c7fd12326329c52d82cccd1c67815991eef93f5d19eaf1ddfa584d5362a091bf57df5b8fae2c5d761e78fcd1ff0ce867dca995fa0459d8868acb0dcaf76b2613ab87cb6d8d25c1eac62defd811723579f4f6883c13fa865046782fd3cf7d9d33ea8dbaaa5951c313e20013a83548a6dc58df61953099ceea22897f32e2abbe1fd77eb586c3ec82f983a24d5625e20b74ae3fb2aa3cb0ff397b0844864940824902198128eaccc678d1ff149da9f2b93cbec2b00f2df3fb528f79a1f373727b6a3a9ece73f0ad05a95113496758fd8e5e3351e073e426d8634115a0040aa23f24eec467db2561e37878997514d8bcfcda7db8565fdb56655951695fdca51daa3d6bdf1dbb9d60c168fc48f4d348706c1ef5f4dfcb54bf35c630a5fb99bc93af426fca9f16c51b4b7fc7f2f14d1ffd7c680638297f4610420742a19981b23afdca8963d1c0a11b0080704a2513f0e371b4735f0c1ed763d46f1b980060e05833c414a40ef98f0651f5671afa22e007cfdbc387545fa5e2cbad66467336e711c234de54ee7c40b6769c2edf698409c2f13e729c8b2bd473cc7865bdd523e1d6728a67a0962c5832b305362996c72f9f34740aa0ac465ed58e0d110f0f1f0f5871235d4938bafdc5f77be785078fde7a1db330cb13319200cc0cbf965caee8f2e9ee9d878662a8cc8cb2acffe9efa920a8dac98aac1ebce4be953c33dad1eb23d0dacf81070f8f9e4026d7e9092875aec287426fb0509adeb4f181a4385c9e9f2a4bee34eddedf64c7e0d7fbe66da4ba5c9423d63836accca4596bc4aaee3a5b39c47fa8ac3dc1e5cfed0d99b0e1e311e006e9d0d029fc3a99f73e053f3072d4ad57c10b91d822dcc4e07288f424a44e34763e6daac9ef66e74a1394d5d764584e2c5d9bc4a1646a3e65d3eb0df627d46559512499633fa40309876384334cd5f57c08becf6e4505f8a10ef64327bed0bf9ae2c9c77e4276d0c7ce7d9ad7fb2697086e22bc72bf6ca631b995689cdf18a92889b799a62f6b827f9820eefa28629fb671726be69c74cc93cd8ffddc622f329fd9ffb763cc90e266698977706ffc205b6ed8f6644cc0256ecfdd2459634e5e5064ae9fafcbd3ff2b35bfa85f04b634fd5bbf76c54a078a3e2addb753575929679e7379e80137410a93bdafcab9aaf1ffd694c3d0327edb11a695ee9dacb57727e59dcfe9b4a6bd14e56729fca4b111f08ca8f5da633e54db2ec5cc82301590522eaa5e64c2a5dad1a3eaa1fc2ae77ca3a1fb3ebb19a4382a0bd57d404d99fafbc8d928788734a2dd96daf7dd7ac89c4b496d9887b05313e7e934943051b5b6ac1eda9ca85eb42c7d58354cc75cd7569d0bbd9ddbabbd4e5899e7d27c7d7b1b150fb24da2283315fcc4e829f54084687890641f154a12eda342e1270f7dd9f5b9e47ad11f7b899e19e9babf93e0e68ceb26a085a39b9172fead3bc0e7534e3f7cee6d48f6201c733dc1a20402883844249884ad15ac8e442a57e4afe675f9e779399510db19239420aef9453c937743bf49d061257e6524f9cf0d938ea60c60e6c8fc0034cd98f8ceb0540eb7a2d3bcda99024a6bcc28488b466bb8d11c00528e444b564be0ee9be59f9164809fc05f04f77547135e327309f5a173ce493f86d3635c9dd27ea69481efa3f6acba23880e269820240e78b577273550740ccf5dc52180902e2383aa9396aa76ca682cdb8a36bfb898442ce8c4a2286d0455793bde41499aa408aecfa228d69b8dabc6b7dd0bef3dfaf04cffaa61451b0d95cdaac51a8f69ab72a7a8fcd24518ce1a0df8171b039ba939431d2bddd0425549bc643e7270cd6b3acf7279dcaae6e13947456b1afd3ca81fe24ec9beca4aae1a5919d57681acc3c493586de8970f9d68c58d252d6f87be5b850c6d670f7893af04dec6caf3c0d56187a52c97350eb9021288e583ae2ead0b7ffaaf07c5ce014d383d3e139a0eb38a6e015db44af90eab4d05115d1202046c38d8849070015d1a8e090047bf1919fd6ce3780ed1a6ec89c63b91304490f2c37ea36eea1791be57c66b53d425c01a630d76968985739bb779d71ba36973952bb7cb53f77558d544bb5188cf7abeb4f71ca984c8187495ce1a87b50cc81fdb6fb2cfe4a331ae5840cd555d461a0f824bfed1dce3ba980b03ae734f7303b3671d681e7ad67051cca2bd3a1e909dfa6ce367b95403511c790ebf82f1998bd1d1391a2fa3b01f6c4af5078b86f46112b7bac6057a6033853b54cecf73631ee67e29f0e167348df36ca92644e7a1051fe5a7acf6c2e50602797cc099e064271d1ccacabd2a73481b7c15201dde2c722e3e60975404f06271f8275930dba3b481a23ad3724b2ca18f214ca5246ef97dd57642380ce089fdfbb02e7af04ca1b5fe151be4843dff12646e0a3af9f6500ea1dce3479edd085307a3a97405c7b1b6f0b2b9e566270c319230fe698d11a28f622d23dcfa976604f13c8495b4646e52a462104d632a0cc0031ef0b2ffb66ef304f9b1cd09f15211da3cf41a8de066f43c00a3d72ce764b2bf261b062e36c55fedf4a85c8accc47a8dad72f7f6bfddb450548d7523f0ac189c4456999f8647ffe5c347370b1217b94299e5242bcd26a3fda58a1013e15394e03041bdaf3b1129830b2b3aa3607bac39261c1bbe180ebf74b5e2106a2a6da0c36b0bcbf9c19f58945709eff03dc310f8843708d687e1c9d742dd5bc8eb4a9149bbf76fa02a59e8bf9b2022b3456927174c6671ba3ae9038fabe478554b522e9c2b52795be1406b7455b2e2df445aa2c4050e565ce5370a78d4053f89148e89a5a1fe44edd348fb805d8751a38303ff8f0c6294a83a5d0473d81818245c6ef89f1198d787ff38f32b674b94f91987e272bb79832329352546b4a608c5787423501450f67917359878fbdcc3e47676d25e89ea5f63d958a7c8b23091fc96346e7f614b7b2491d156bb3a7b62df992b958a51f1decb937eb64bc7367f85fb74bd9fa8f189c8e3460346247918499531a5e52af5aef88441958fe2e9f76fe11ef3fe05e9f1ad46b9844faf83080f9013aa30f44a6b40733fa89fb8096b06ccd5024f791e81d73e9df653660845520950002fa8587e61439fcb0d08655d4368061c0adeb9df76c8eed203ec7df471e018816a4233906fd7fb7d3ff87a6e2873ad3ae2dd6de116bd6d7ebfe9dda60ffaadacce4c3493b4ca026d16d76d0fa959e0b8cc0c6633e4568f953284f16b155f5af1720d1bc9fc3b1206141224ef558cb783b5213e930aed844168ef9072670f1920e97e1d428ccfbd1219a10df8a1976f46db87d3184c911660f5d6040e6d0c41573208fe9241f8990c62ac42644f740405314fedc1c7744acf81c7f0a869d889a5ba5ed88da9dca1b013f7000984409095f78f4a950fc85d74907f91a17e242109337a9db600650f366a8307b86d95c7b156fb52b97c4938c8be801a19416b0f88540a5479721b9754ee6b2a5001e66e591d47202958df37947764fb6ef9093094f76067804e5f686bd93926a5c2895b2b7a7f9ef76ffb6cb3fbacbd72f364f14b7b85471b9bf509b2e5cadf06d5d1f47d2aa5f3180af43440117af72d43fcdad0212e2e5dc3e02b0e85b74b2ffd9dede061124587942da40537a28d4e878de703d8fb3ea04588679bf982bc4123d9e74625eab720be2d657e55ad72e6059a9c9a1e2ed8d2143b565a763212b2184c2404d65e414143e6bb312e2d5a04e0584f9e6bf0aa2408bcc5ed22cdf521698bbef13a6eccded04b9d4c19c1fe84141087d525a8b5bd57e78cf6f49a1016f0a7527059351a12908e8ef022c606048c563a016b533afd375981298a1fd049f5e0646480792a9d8034b50ecad836ba83be52c44ae3d64546a5aa8fcc5146e6066694b3e8970b0852bfcb4fb30cd9c174deb92bd0d2731e548b262ffbfc974847d09e3e6c06d4686de2d1f8bf5c501c477caebef3f7fab8d733ab7dfc631f1b0f492601c799699137d999478f774301c767c6a7fd71e75ac7ba276f3f9c131775afc04f3db7e262a2f59de147fff51ebb85988a8f98f6c727205841c05c61580f83eca5c411558d9bf043e6d1bf0458ad32f63e45457f3fc22bba63d12189abc9da5e582aeece3d1e6b5a9a043d3a23c817daa8a80172802cf81fa980ed8b0b66d80bdb4eeacbbf85804b74b7eeb81e58783af07da0553a8b51f0c5d2435d126347067e677f448ba5f237eeb303cafe9e5832cbb965b90cda24b82b4a078ff6f03f97c3ba34b3f1c0e4b01f24e2650e25753f18943e7b9ff2026829df4c9bbd5bbe144944457dd77e4672c63dcc641e3ea24bd0e2dcc77e11f7f630747a028b8101e1a0efae6217c71ee1b0f9a00d1f9ed0c592aa9dc272637d8f8dd7fd77af9dc0fa3dd43d661ec85d20023c441e6bb14099b0140b46139965013c9a20f89eaeb4052b090706fc84230d4bb632ef78da393b1d5da270d8d4049ed421a809bca8a459d46badbcd642857b45ec80af44cdfc5e6532e046292dcf645ce37235990f6d199294d3e3b92a7e08836a816491380c6115d99533511ee1f7e5ea6a4649add270aeecacb2c3b1a08b3e5588d6378d6fd134682294d8852d6539507bf2efe2f9764d23d00072fb72bc45a7cac0a3b3dbf1bfecb1b7cb8e054256821662dc8ea70ecbb0aa496d6f958384fa962b07d17e2a3762448a4a4b7177d458711ba7674bc8ef376c29d965e0c130a9a20b5e139436c85c7bcc8dfac70bfe750d095bb5c53c9332eb7ddbcc740611d44d42d3a567be1d6535d3ccca26234df9197ff9a2e36b8f2e416a2562ab47ac39903a0608f05f833a97cf36f27def68f27ea6d4cfb9b393516a03efd9f062b479677593f66c7a03c4b2eb9862ae9b7170bd9ce623653e9611ecd9785779d5b511d6672cfbc712f73d19cea3c9f2e52e0837eeac164854badf5a8f247f14e7380c87a9e65a4669ce57e98c97e32dfece2750c04741d159efcf5b8d69834b9b8fdd843209651f6b84c39c3eb316e695bbd9db62e56580582089b8da007f100760494e9ad682771aede8f0877f3240d1682cce9418672fafa1f9eedba2fa9faf388fe58fdca89f0bf101303aff51e7c67777cac89aa28ffddcfc27fd61ec9ac2c7cbffdbb1798907413d823eebff4322afb9f77c7e0bd8eb561cfa477efa5ade47d067d7717e7c3d580fb23ab79fc3534949dbf8669f9ad62a33a396ffd5ac8da1e1659b43e34544ca22a753e6509bbebb3cefcc3c332b165e6c777357810a7f239c9258f59c96ce0b8e27f7feee335cfc7f0f4d7783eb7722ed4106fd7225a14f413400dae0df7984537fe9de31629d05d437f7358ff262c7215dee423db58e2b8813216bda2a4b1840c557644d6764523574a0acd519b965281febe2eae874d4b5bf1ef1ad74099c88370a9872f79613f6f5d3dab7816ff124049884d86634206928bac36bac50c48c3d6ef998f0b9c231ea05fc1d129f8deb7308da26f1d278681bcdb8fdc0fb47b7350178fca3c3d23d7a280cc2b326323cacdce6a505df43f5cd53cbef0699a426383a7a668a047ce0d9e26200f5701d068d960c43bcfde02986c0721d5f27b22d4775b029ec9e9c0ac56b37958c7eeb8e474d6cb1efa77df7cdac7d84a96dfc9322e74f72c4f3b1b6b57f4e26c1ae7f572cd8ad5d3d8a7e39dbafa9435cfe4d8ebd4a3a5960351ae9247235428036087157fdc9ab43b359be771db4b6b8a90a9ae87a9740c7fd63aefaee4cb344a32b9ecbba64f5e335a91adda87c867d42aaffa27180da06af7289cda2d26c8bd56ee0e93e3502bbba09982a1b5e35ca491a96286b7706c702a59428c305b059a05886d3ed1555163f80696b2fe4b3c9dbe15f7e7e00de8b94b9bd4fd7160869a115cb03bb151d9598de70af87e5d9b4db3dc2de0654e770e47e5dcf5bfa69e062ebcc7fb9b810a882a2b2b8e589bdbc1aae5b5653a3c039cae63ab5b10a8be8a4e378b5fd85d2f9a67a21a2586ec75a64e5bbcc6af1033258901f073f6905a373ee718e7cb15d6e1b9f297c83b9c663ca4e2c987f3799835da9625d9e42c0b952879d423d14419b94cb8a044145bbcd208ecab84bbc95f51bdb281d0d32674b5b05e3226ccbd16b7a9ae76652cfd6d9fb1477f197bae4b6285dab79b683e09536d5bcb7f862b60c78f7c17a7dea24cec16e643f457833987529bc363bfcb18e156ea02203d7ce8e8cb681ed09d81893780373161f4c86738051dc2300e7c72cd3ad9d40e03aae8fab3ffcfcfd6be2729dfc432fff15c2e249edc5ffaf65fc8e205863296364af06b3f88bbdbb51021fc3b02be87a33665d251da77a1e8cd404046aa4805680018e5323008f1807f5db28a9574c84b9ddca3b67afc77b340b9e9b1c4cd2a4d72108cf51732dd4335a010d4d3f444f8ff48fdfe520ee06d54749b787a8690624287d81f8890aba3df60dcd8599a2e33e5c6b28f21d9d989e1425321fea474cb88e141d92cc6888645744b43106e947230a900bc032a420674212479a3c0b1a50f593e103939efee99c085e0ba21a80d0a1cba86812668ae6e5824de0eebe03fe2ac24f880b00b8aa6512e2119958c4847824d8f8b826162136a0f189094d48247824c0124222c4c334e11aee864e01b00f40d8139809e090b060990f03f1c13ebbd00215f3c4b0ae710a128b078e99bbf464a3800c368960630287d4932dc29df43549381c60f6790c9f05888cd3770974b5ec5d0822a7c2e602fb0bae190c4f3df5124083d4d7e6cdf074eb5cc1afa6bc293dcaced4deee2d9fb5791f061fac3e2f06d3cfcc536f879157f52fdfb3bc4273b7e432a69a91c55f422ae0ce746093d17cd31cd0c73a60f0540609fd2bb9acfc33fda93420fbc8dbfa12c34f90ad705627d9cbfe95e0d5ec23376b235f11ac1b6a3e638bc77bf38f292aab3ae51e59007fba77a2c7d933e8465d6f548b78c756c76b031da939f5e7d2a26894bd40be9236b1274001742e024d7ee64e8ac21702b380537f9af49bdafe902cd39ffaf15dd8021a7696121c64b90dad7629c603d5d8ed9da8706f5874527d7b2737b4a8c1f5505f4a33ef6740999f16f9f5f764ef3f1e84276c47e403112878e27ae13482cfa8013027e0160943dda34ea434325e8e3013a881b89c01c050981a98affaa210e65e1272668429e5da128e7f9ece89ef6420c23eae9581ea6499b256d999cda3f2d519e7d1c868939f329fe2bdca0d7246b9974d19fb6816f02f4b59fa4b9a2b8bb03e5abc4ce8ac1666e52eed63bde9b90a69235523d530bae024c73c74eade6e3ccd77b8aadbe071b34b06763eb693ea4be2439ad4e9f8aa3583cd724fa9722abcd47a0a0cbb4deeb8fa40690e1a8a4496905fc9e855929c0aed0d4018505d6148cf3d74df36667f894a52ba622a9538fd427e0e0fc690fa9ad2c975f8695133b6b8979dbcdbc7be865330d87bf63b4a9bdb237ec2b5630fd358b587b19b622442387df3bb832c2ed63fbc67ccf65359211adc46b523da36fe4e3a2a244ef42976f2c0a73ca32ddc18941ff50dcb2656659a359be3c446fe3c51e829848529f8967f689a00ce78c055bd42139a2839632547ef4092630263fe50bb134f722054629266cb90af448d5586428bdaed620b6151248f2757c65063f162f1853a89cf2a54c72e99066b0f4b6becff3332c599bae370e8a81a4bfc3c0d0876212d13700e305777794a56be1abf0ec17c82a60f5e1bd68d7434d1c8d44c23a53c924612494424dcaff4f1f511ff0fb0a544b99d06bc960c66024d0170b642c8f20d3c1eb6caaa5d08bf67cad29bf2f0cbd6950127075c83086b55c0a1094136ea1a601545188b7dac74e4c477f10af3464f336bd3511ef7d84d49739a3f47e3a36b1c8d8134dfbda7e4ee3b33fed3f8bfdde8cc3ffc8889e0744371db8b5917b27ed584fecafc355d2e7ebe0b51648a211af57eea99ad3116dd7dd0324f925cf36cdae0aaed4b6efa32bebb30cc9d967863965752cd80833bd3b25acc87f5d234c7cba39c7a31930a50000d6a480b301ebfde59f29198a002ed79c131f589d347a8773afff2fdc68d3c6f35ce184d734ef6b348e1ff2be64a3aa640f77e2e2d027129dbb0b4cf8e6449199ccec4a47f5c25375d2efd426bf2e2147055020e3dd7750a81ca84c84aec2d531f1159a00705f0e75f8ba8c56e4d73b22b894a52442a398981aeb19974d6e565e2e1c22f06bdbe07f75393a37e7063cd064d06b28aa6727e558a014ee51ea53bbd407f9d44828383418c8b87898d0b1932e176d5418331176581c27c87f457529f41fc18620c51b7ff88780a1d9260c3f53c959df2034a455ba31d7773cf2b8f8e0aceba8c235ce4dce59636ee720614cc5fe36309e7e1fd6b4be567ebb3dcb94ffc21adf1d51c2b170c29863d72ae20e9b7bdf6888e072be008b1303108090870b131e7e54b891c4cc2ddcd8e0f310b0feae70966729443477297836a61775801f778b370b5aae8adf2f138da654e06943526f5207c4a36ff2118846510d3766a01aad6e40be4479d6a31ce4ec03d1e76eb373b3fba0120bbb0db05e528ef87e9c9fe0075a926dffc90fbafd49e267c6eba468bbfc2a6f688381d0cff5ef43fb1cabfb76bf40309ac83eed309742534e6b1a3744731282dcc69631ec8fb843c1274aac1bbb5c01facdb4c0661e09c04187edd0688d0ad8031300043479f7fedb95aead731f10c1205badfb1fd6359fd8b6d856588c8b52938f79175a5c130cedb5e13f0fcaa291420468bcffab72e873b0beaff7a45c8fb54de58a6a974833469afc0092a6d3a34b9526f6aefa03d333aa9a7c6fc6f10bd93aab4d6db65c3b8a84b0d9134e91a74748660a840fdf31fdd8374afba03a47b6847d9d0fe8367845cde2931e0c780121a4d597d3ec476801104445a82fb02a96538cfd768e1ba441122c7453218b92dea4c9c56754a7359846e392c424a2d7765a4f6136ba6fa26cf0bbe1f7aa42b6f2ddf8895e8b1437925fd41738603319f394e8893a43fecbf339cafed82f6cb0e730ab6e61efd0433eb3a079c206d6dc46740a2f734c5e2e83a4a86a13c400634016007ce061a5ab241c89230a80e09457c5dc0ffd0f8f4632c1d28437cea6df63c0329169a10c42088c10ba36046f1cc6511ef25e18135e81a9734eabd01e466d1532c1140c5674f17ec5d26cc921a35056f6dc4cb984021333695075b24b99e8f62a65217e6bbde650905fd9906531e352c34c1a9c87fee3907b18fdbfe01cc0d134f41f25ed357e5c9629002132763d7ca0706b66ee4aa3cfa73431c2be3ea8c3f2c110429d4768cb695439ee350af86ae43eee4a1be68ce1553a6b29c65559387c4e3e8b1043b0ffb2f85538ed7aba209a6ca5d05d0f777c6aed8e33c67e07e0a4d76e5a6b9994b66e5708071f89db34d465257fb90c4e06a1937a44108626286f2f232ef713b03187cb0cf425f23207fcd864ae7f0990d06376ffc9c3fe87cde33aafade5b9e60569d288c5be3cfc2278b26c2590198dcdd21be5fd7cc0c60d78e3f2bc8a248a8d85c29d35104ae23913cabc8e0191614af207c6d4d0940222915de2b38d2a5985f2dce7458b976ca1cb985f0195b1ff26e669bbb4add5b21469a53e81dca764f7da2383e4f83d94fe12a41f90c5a9f598b219f6334d6a27cbe070d801e30860cd787b3df34b94968427da38c98976ab0279220529443a2224e5bf1658f36f013a5348d82f964e42c0aca955417d27a7fc85775ba4b13a7424fddd631b7ce61d7b061b6f1d2b220abca6af8b9a464a2a330de35f651c711511b169a351996926381600caa3169ab159c64ddb0684405475f271b990b9a863c78a0e98230dd6426c4aac64a6019daa9d0c2038a80b7f44dc55ab0c39c9931b165e4ddc1581ef7cb1d8fa51f781f713f7d49499160341d54ef56381be6a6295f2b64b5a2a8b78c23952f2f5ecdf700c3fc30df2230def154391ffcc01d470007b96a55158f1c3d6eebbacbaf1632f5f3f5b9f40e5eb4cebf082de483782d4a0edf7b02d6a4c34d250b53c6cacb0f3fd65d798d2b4c0361ccdc2f59dc4f6e4e0e7ca31297dc3ebc3a03b02267e6ec24f5ecefd295cc306639c429b806ba4b700282ae246f7de41a17e070620d53bab1c35d08e9c512e416a4e2b8d4e1b936caee4c71178e298c7f5f9393bb7826bc6af80a374954f7925a971c74d953b0f6370d89256d1538092b17b10a3da1d62dce1ce7259280e675de310e5f27d0e6aafaae235cc5fb148c9d29772c4488f9ac8755a8e3c6545ff061766be74523454a13a167ea334b2621be62bb37ea682c8853fb2d5d8f2e205ceeda25cdc25d2e41ae8063f190e28a2bda1beaa89e550a8f8b32a1efc9b23d78a2b7c5325740dbbb9b28ca0b2a8b0d40ff8bc03bb1 0000003f C:\SoftwareAG101\Apama\monitors\query_support\QueryServices.cdp
TIME 0000000e 1522267307.5,1
TIME 0000000e 1522267307.5,3
TIME 0000000e 1522267307.6,1
TIME 0000000e 1522267307.5,2
TIME 0000000e 1522267307.7,1
TIME 0000000e 1522267307.7,4
TIME 0000000e 1522267307.7,2
TIME 0000000e 1522267307.7,3
MONF 00000528 //*****************************************************************************
// Title:       ScenarioDeleterSupport
// Description: Provides event definitions for deleting Scenario instances. 
//
// Revision:    $Id: ScenarioDeleterSupport.mon 249541 2015-03-09 11:42:24Z bsp $
//
// $Copyright(c) 2004-2005, 2008-2009 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.scenarios;

event DeleteAllScenarios {
	constant string CHANNEL := "ScenarioDeleter";
}

event DeleteScenariosByUser {
	string owner;
}

monitor ScenarioDeleterSupport {
	
	action onload() {
		
		DeleteAllScenarios deleteAll;
		on all DeleteAllScenarios():deleteAll {
			send deleteAll to DeleteAllScenarios.CHANNEL;
		}
		
		DeleteScenariosByUser deleteByUser;
		on all DeleteScenariosByUser():deleteByUser {
			send deleteByUser to DeleteAllScenarios.CHANNEL;
		}
	}
	
} 0000004b C:\SoftwareAG101\Apama\monitors\scenario_support\ScenarioDeleterSupport.mon
MONF 000009a8 /********************************************************
  Auto-generated EPL file for DE type "HelloDBP.HelloEvents.ThingAlert" (variant f7db77fd96c54d84)
  Created with 10.1.0.4
  Note: This file is automatically generated and should not be modified by hand
********************************************************/

package HelloDBP.HelloEvents;

/**
 * Auto-generated from digital event type ThingAlert.
 *
 * The field '_guid' can be used as a unique identifier across all instances of this event type coming from DES.
 * If this event has been newly created within Apama, DES will set the unique identifier for you at the point it is
 * sent, unless your application has already set it.
 */
@com.softwareag.connectivity.MessageId("_guid")
event ThingAlert {
	string Id;

	string Alert;

	/** Contains values representing time, in seconds since the epoch. */
	float/* TIME */ Time;

	string _guid;

	sequence<integer>/* BYTES */ _isData;

	/**
	 * Send this event to DES.
	 * @deprecated [This action has been deprecated, use the CHANNEL constant to send an event to the corresponding Apama channel.]
	 * @see CHANNEL
	 */
	action sendToDES() {
		send self to CHANNEL;
	}

	/**
	 * Subscribe to receive events of this type from DES.
	 * @deprecated [This action has been deprecated, use the CHANNEL constant to subscribe to the corresponding Apama channel.]
	 * @see CHANNEL
	 */
	static action subscribe() {
		monitor.subscribe(CHANNEL);
	}

	/**
	 * Unsubscribe from receiving events of this type from DES.
	 * @deprecated [This action has been deprecated, use the CHANNEL constant to unsubscribe from the corresponding Apama channel.]
	 * @see CHANNEL
	 */
	static action unsubscribe() {
		monitor.unsubscribe(CHANNEL);
	}

	/**
	 * The Apama channel associated with this event type.
	 * This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, 
	 * unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.
	 * 
	 * Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel.
	 * To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.
	 */
	constant string CHANNEL := "des:HelloDBP.HelloEvents.ThingAlert";

} 00000069 C:\Users\jagt\workspace101\HelloApama\autogenerated\DigitalEventTypes\HelloDBP.HelloEvents.ThingAlert.mon
MONF 000009ea /********************************************************
  Auto-generated EPL file for DE type "HelloDBP.HelloEvents.ThingEvent" (variant 3a7f054a2ff2335a)
  Created with 10.1.0.4
  Note: This file is automatically generated and should not be modified by hand
********************************************************/

package HelloDBP.HelloEvents;

/**
 * Auto-generated from digital event type ThingEvent.
 *
 * The field '_guid' can be used as a unique identifier across all instances of this event type coming from DES.
 * If this event has been newly created within Apama, DES will set the unique identifier for you at the point it is
 * sent, unless your application has already set it.
 */
@com.softwareag.connectivity.MessageId("_guid")
event ThingEvent {
	string EventKind;

	/** Contains values representing time, in seconds since the epoch. */
	float/* TIME */ EventTime;

	string Id;

	string Name;

	integer Health;

	string Account;

	string _guid;

	sequence<integer>/* BYTES */ _isData;

	/**
	 * Send this event to DES.
	 * @deprecated [This action has been deprecated, use the CHANNEL constant to send an event to the corresponding Apama channel.]
	 * @see CHANNEL
	 */
	action sendToDES() {
		send self to CHANNEL;
	}

	/**
	 * Subscribe to receive events of this type from DES.
	 * @deprecated [This action has been deprecated, use the CHANNEL constant to subscribe to the corresponding Apama channel.]
	 * @see CHANNEL
	 */
	static action subscribe() {
		monitor.subscribe(CHANNEL);
	}

	/**
	 * Unsubscribe from receiving events of this type from DES.
	 * @deprecated [This action has been deprecated, use the CHANNEL constant to unsubscribe from the corresponding Apama channel.]
	 * @see CHANNEL
	 */
	static action unsubscribe() {
		monitor.unsubscribe(CHANNEL);
	}

	/**
	 * The Apama channel associated with this event type.
	 * This channel can be used to send events of this type to DES, subscribe to receive events of this type from DES, 
	 * unsubscribe from receiving events of this type from DES, and get the sending or receiving chain associated with this event type.
	 * 
	 * Sending, subscribing and unsubscribing to this channel is no different than interacting with any other Apama channel.
	 * To get the Chain instance associated with sending or receiving of this type, use the com.softwareag.connectivity.ConnectivityPlugins.getChainByChannel action.
	 */
	constant string CHANNEL := "des:HelloDBP.HelloEvents.ThingEvent";

} 00000069 C:\Users\jagt\workspace101\HelloApama\autogenerated\DigitalEventTypes\HelloDBP.HelloEvents.ThingEvent.mon
MONF 000001ac using com.softwareag.connectivity.ConnectivityPlugins;

monitor HelloApama {
	action onload {
		ConnectivityPlugins.onApplicationInitialized();
		
		monitor.subscribe( HelloDBP.HelloEvents.ThingEvent.CHANNEL );
		
		HelloDBP.HelloEvents.ThingEvent		thingEvent;
		
		on all HelloDBP.HelloEvents.ThingEvent() : thingEvent {
			send thingEvent to "com.apama.queries";
			log thingEvent.toString() at INFO;
		}
	}
}
 0000003d C:\Users\jagt\workspace101\HelloApama\monitors\HelloApama.mon
CONN 00000036 6538088283673763839:6537525350900211711 from (unknown)
MONF 00000774 //*****************************************************************************
// Title:         HelloTerracotta
// Description:   HelloTerracotta description
// Dependencies:  None
// Author:        Administrator
//
//*****************************************************************************
using com.apama.memorystore.Storage;
using com.apama.memorystore.Store;
using com.apama.memorystore.Finished;
using com.apama.memorystore.Table;
using com.apama.memorystore.Row;

/*
	This event definition would normally be put into it's own file in the Apama project.
	Including inline here for simplicity.
*/

event Thing {
	string				Id;
	string				Name;
	integer				Value;

	constant string     STORE	:= "HelloDBP";
	constant string     DATASET	:= "Things";

	static action getThingName( string key ) returns string
	{
		Thing			thing := <Thing> Storage.open( STORE ).open( DATASET ).get( key ).toAny();

		return thing.Name;
	}

	static action createThing( string key, Thing value )
	{
		Table			dataset := Storage.open( STORE ).open( DATASET );
		Row 			newRow := dataset.add( key );
		newRow.setAll( value );
		newRow.commit();
	}
}

monitor HelloTerracotta {
	Finished			f;
	integer				id;
    Store               tcStore;
    Table				thingsTable;
    
	action onload {
		// Initialize the Terracotta Store (requires Terracotta server to be running).
		// This is executed once at start time to initialize the TCDB Store.

		on Finished( id = Storage.prepareDistributed( Thing.STORE ) ) : f {
			if not f.success then {
				log "Terracotta DB connection not successful: " + f.status at INFO;
			}
			tcStore := Storage.open( Thing.STORE );
			
			on Finished( id = tcStore.prepareFromAny( new Thing ) ) as f {
				thingsTable := tcStore.open( Thing.DATASET );
				Thing.createThing( "100", Thing("100", "Apama Thing", 100));
			}
		}
	}
} 00000042 C:\Users\jagt\workspace101\HelloApama\monitors\HelloTerracotta.mon
TIME 0000000e 1522267307.8,1
TIME 0000000f 1522267307.8,12
TIME 0000000f 1522267307.8,13
TIME 0000000e 1522267307.8,6
TIME 0000000f 1522267307.8,19
TIME 0000000f 1522267307.8,14
TIME 0000000e 1522267307.8,2
TIME 0000000f 1522267307.8,10
TIME 0000000e 1522267307.8,4
TIME 0000000e 1522267307.8,9
TIME 0000000f 1522267307.8,11
TIME 0000000f 1522267307.8,15
TIME 0000000e 1522267307.8,7
TIME 0000000e 1522267307.8,5
TIME 0000000f 1522267307.8,20
TIME 0000000f 1522267307.8,17
TIME 0000000e 1522267307.8,8
TIME 0000000e 1522267307.8,3
TIME 0000000f 1522267307.8,16
MONF 00015981 /* Package as specified by the .qry */
/* Private using declarations required by framework */
using com.apama.queries.__Index;
using com.apama.queries.__LatestEvent;
using com.apama.queries.__Respawn;
using com.apama.queries.__RestartQueryTimer;
using com.apama.queries.__Trigger;
using com.apama.queries.__TS;

/* Private using declarations required by framework to interact with QueryServices.mon */
using com.apama.queries.__ContextMgr;
using com.apama.queries.__DistributionMgr;
using com.apama.queries.__FailedQueryInstance;
using com.apama.queries.__HubContextRequest;
using com.apama.queries.__HubContextRemove;
using com.apama.queries.__PendingTimersMgr;
using com.apama.queries.__PrepareStore;
using com.apama.queries.__QueryLoaded;
using com.apama.queries.__QueryLogger;
using com.apama.queries.__QueryReady;
using com.apama.queries.__QueryScenarioService;
using com.apama.queries.__RemoveInstance;
using com.apama.queries.__StoredEventWindow;
using com.apama.queries.__StorePrepared;
using com.apama.queries.__StoredSnapshot;
using com.apama.queries.__TerminationMgr;
using com.apama.queries.__WorkerContextSet;
using com.apama.queries.__WindowLength;
using com.apama.queries.__WindowManager;
using com.apama.queries.__WindowManagerTableUsageChanged;
using com.apama.queries.__TimerRemoverChannel;
using com.apama.queries.__QueryWithSourceTimestamps;
using com.apama.queries.__ScheduleTimerRemoval;
using com.apama.queries.__DebugSleeper;

/* Using declarations explicitly specified in the .qry */
using HelloDBP.HelloEvents.ThingEvent; 

/* The Query output event generated by this query each time the find triggers */
event HelloQuery { 


	string Id;

	ThingEvent t1;
	ThingEvent t2;

}


/**
 * Monitor controlling query HelloQuery.
 */
monitor HelloQuery_QueryImplementation { 

	import "TimeFormatPlugin" as __timeFormatPlugin;

	/** General internal events */
	event __NullType {
	}

	/** The set of worker contexts */
	__WorkerContextSet workers;
	
	/** The index of the current worker context */
	integer index;

	/* Flag for whether or not (and how) to respawn after ondie is triggered */
	boolean shouldRespawn := false;
	boolean shouldTerminateWorkers := false;
	boolean deleted := false; // has been deleted

	/* Number of instances of the query. Used to limit non-parameterized queries to a single instance */
	integer instanceCount := 0;
	
	/* TerminationManager used to shutdown workers */
	__TerminationMgr terminationMgr;

	/** Set of pending input window preparations
	 */	
	dictionary<integer, integer> pendingPreparations;

	/** The MemoryStore Store used to hold each event window */
	com.apama.memorystore.Store store;

	/** A __DistributionMgr for each input type */
	__DistributionMgr dist_HelloDBP$HelloEvents$ThingEvent;
	__DistributionMgr dist___RestartQueryTimer;
	/** Manager for processPending timers */
	__PendingTimersMgr timerMgr;

	/** Flag to inidicate where any input source times are used */
	boolean anyHaveSourceTimestamps;

	/** Used to interact with the Scenario Service monitor which is stuck in the past i.e. the main context */
	context scenarioServiceCtx;
	context mainCtx;
	// @see HubContextManager
	context hubCtx;
	context statsGatherer;
	boolean isMasterMonitor;
	boolean isInstanceProxy;
	boolean initialised;
	boolean createdAtStartup; // see initCommon
	integer qryId;
	string parameterizationOwner;

	/** Query scenario service event */
	__QueryScenarioService queryScenarioService;
	__QueryLogger qLogger;

	string queryDefinitionName := queryScenarioService.QUERY_PREFIX + "HelloQuery";


	/**
	 * A per-matchset event. 
	 *
	 * Contains a potential matching set of events and any other state
	 * needed to evaluate the pattern.
	 * MatchSets are owned by a parent (either another MatchSet or the
	 * EvaluationState
	 */
	event __MatchSet {	
		///// state corresponding to the pattern:

		// coassigned (positive) events:
		wildcard ThingEvent csnmt_t1 ;
		wildcard ThingEvent csnmt_t2 ;

		// flags to record which coassignments we have:
		wildcard boolean has_t1;
		wildcard boolean has_t2;
		// flags to record which coassignments we have previously triggered:
		wildcard integer triggered_t1;
		wildcard integer triggered_t2;
		
		// timestamps of the events
		wildcard float timestamp_t1;
		wildcard float timestamp_t2;

		// per-followedby node - which way is it looking?
		wildcard boolean fby_node_0_lookingLeft;

		// per-or node - is it true (we don't evaluate other legs once it is true



		// per-without sets of the event - only holds those where we
		// don't yet know whether the 'where' condition holds.

		// per-without start (earliest) times:

		///// state corresponding to the evaluation state:
		integer id;
		action init() {
			id := integer.getUnique();
		}

		// called for each new Matchset object:
		action initBlank() {
		}

		// The effective timestamp for when this match occurred
		action mostRecentTime() returns float {
			float t := -float.INFINITY;

			if (timestamp_t1 > t) then {
				t := timestamp_t1;
			}

			if (timestamp_t2 > t) then {
				t := timestamp_t2;
			}

			return t;
		}

		// we maintain an ordered linked list of matchsets, the most recent first
		// this is managed by EvaluationState.addNewMatchsetAfter and 
		// EvaluationState.discard
		integer next;
		integer prev;

		// count of how many instances of the 'current' event this matchset contains:
		integer containsCurrent;
	}


	event __DelayedOutOfOrderTime {
		float maxInputEventTimestamp;
		float correlatorTimeBecomesDefinitive;
	}

    	/** Utility event containing all user-defined parameters, expressions and query actions*/
	event __ElasticQueryUserCode {

		/* Only copy of query parameters */


		wildcard string Id; 


		/** Return the user-specified duration; the evaluation of either an EPL float expression or a time literal */
		action __getWithin_HelloDBP$HelloEvents$ThingEvent() returns float {
			return  __calculateTime("", "", "", "15", "");   
		}


		/* User code that gets invoked when the pattern is matched 
		 * Takes coassignments into its scope as arguments, and parameters/keys as members on self.
		 */
		action __findAction(ThingEvent t1,ThingEvent t2 ) {
			//Route the query's output event when find triggers
			route HelloQuery(Id, t1, t2);
			
			/**
			 * Brackets for extra scoping goodness; we want the user to be able to declare
			 * variables that mask arguments to this action i.e. coassignments
			 */
			{
{
			send HelloDBP.HelloEvents.ThingAlert( t1.Id, "Thing '" + Thing.getThingName(t1.Id) + "' may be unhealthy.", t1.EventTime, "", new sequence<integer> ) to HelloDBP.HelloEvents.ThingAlert.CHANNEL;
		}				 
			}
		}

		 



		action __andTerm_3(ThingEvent t1, ThingEvent t2) returns boolean {
		{
				/// If this term is one of many, 'and' it with true so that we get typechecking errors just as if this term was and-ed with its sibling
				/// booleans. Otherwise calculate on its own to ensure that the toplevel where expression is correctly typed
				return ((t1.Health.toFloat() - t2.Health.toFloat()) / t1.Health.toFloat() >= 0.5); 
			}
		}


		/* Parameterized query logger */
		__QueryLogger __qLogger;

		/* Pattern event listener(s) */

		action<action<string, boolean, float>, integer, ThingEvent> __handle_HelloDBP$HelloEvents$ThingEvent;


		/** __WindowManager._listenFor_cb */
		action __listenFor_HelloDBP$HelloEvents$ThingEvent(action<string, boolean, float> __onEvent, action<string, string, boolean, float> __onHeartbeat) returns sequence<listener> {
			sequence<listener> listeners := [];
			listener l := on all ThingEvent() as __latest { 
				__handle_HelloDBP$HelloEvents$ThingEvent(__onEvent, 10, __latest);
			}
			listeners.append(l);
			return listeners;

		}
		/* Template listener - not kept live, just used to serialise the templateArgs.  */
		action __startListener_HelloDBP$HelloEvents$ThingEvent() returns listener {
			listener __l := on ThingEvent() as __latest { 
			}
			return __l;
		}


		/* Get time in seconds*/
		action __calculateTime(string day, string hour, string min, string sec, string msec) returns float {
			float value := __parseToFloat(day)*86400000.000 + 
			               __parseToFloat(hour)*3600000.000 + 
			               __parseToFloat(min)*60000.000 + 
			               __parseToFloat(sec)*1000.000 + 
			               __parseToFloat(msec);
			// round time to nearest millisecond
			return value.round().toFloat()/1000.0;
		}
	
		action __parseToFloat(string num) returns float {
			if (num = "") then {
				return 0.0;
			}
			// if hexadecimal integer then first parse into int
			if (num.length() > 2 and (num.substring(0, 2) = "0x" or num.substring(0, 2) = "0X")) then {
				return integer.parse(num).toFloat();
			} else {
				return float.parse(num);
			}
		}


		/* Code to extract the key from the input event HelloDBP$HelloEvents$ThingEvent **/
		action __getRowKey_HelloDBP$HelloEvents$ThingEvent(ThingEvent e) returns string {
			sequence<string> keyFields := [];
			keyFields.append(e.Id.toString());
			return keyFields.toString();
		}

		action __generateSharedId_HelloDBP$HelloEvents$ThingEvent() returns string {
			// set up a listener as a template:
			listener l:=__startListener_HelloDBP$HelloEvents$ThingEvent();
			string result := l.serialise() + "-";
			result := result + "Id";

			result := result + "";
			l.quit();
			return result;
		}

		/**
		 * This beautiful bit of unreachable code is designed to
		 * provoke typechecking errors for incompatibilities between
		 * the types of key elements. (and also with unique). It does
		 * this by going through all the key elements of this input's
		 * event type and trying to assign them to a dummy event of
		 * the first input (or the return type if an action), and
		 * vice versa (both directions in order to find any constant
		 * fields being used as keys).
		 * Also uses 'parse' to try to find invalid key types.
		 */
		action __inputTypeChecking_HelloDBP$HelloEvents$ThingEvent() {
			ThingEvent specimen_e := new ThingEvent;
			ThingEvent specimen := new ThingEvent;
			string testParse := "";

			// Split up so that we only map errors to do with the assignment itself, rather than getting the field out of the specimen

		specimen.Id 

								:= specimen_e.Id; 

					// Check we can parse this input type (chunk, context, listener are invalid)
					string Id_e_parse := string.parse(testParse); 
				

		specimen_e.Id 

								:= specimen.Id; 
				

		}


	} // end of event __ElasticQueryUserCode

	__ElasticQueryUserCode __user;

	action __calculateTime(string day, string hour, string min, string sec, string msec) returns float {
		return __user.__calculateTime(day, hour, min, sec, msec);
	}

	/** Actually just proxies an onload_ call into the query hub context */
	//  @see HubContextManager
	action onload() {
		scenarioServiceCtx := context.current();
		mainCtx := context.current();
		(new __HubContextRequest).process(true, queryDefinitionName, hubCallback);
	}
	
	action hubCallback(context _hubCtx, context _statsGatherer) {
		hubCtx := _hubCtx;
		statsGatherer := _statsGatherer;
		route __QueryLoaded("HelloQuery");
		// Spawn into the query hub context
		spawn onload_() to hubCtx;
	}

	/** 
	* Called when monitor is loaded.
	*/
	action onload_() {
		// Is main (parent) monitor causes termination then query scenario service is made aware
		isMasterMonitor := true;
		sequence<string> eventTypes := ["HelloDBP.HelloEvents.ThingEvent"];
		anyHaveSourceTimestamps := false;

		if (anyHaveSourceTimestamps) {
			send __QueryWithSourceTimestamps("HelloQuery") to __QueryWithSourceTimestamps.CHANNEL;
		}

		// Set necessary query scenario service support event query information
		queryScenarioService.init(
			"HelloQuery",
			queryDefinitionName,
			false,
			false,
			createParameterizedQueryInstance,
			updateUserParameters,
			prepareParameterizedQueryInstanceFinish,
			scenarioServiceCtx,
			hubCtx,
			statsGatherer,
			eventTypes,
			getMetadataMap()
		);

		qLogger := queryScenarioService.getLogger();

		// Create a __TerminationMgr for the master, - in case an unparameterized query fails
		(new __TerminationMgr).init(terminateWorker, queryDefinitionName, -1);

		// Start point of query creation
		prepareStores();
	}

	// Block handle store preparation, where certain store need to be prepared
	// before the instance is prepared - uses callback (called only once successfully
	// prepared to ensure they are triggered in the intended order.
	// Order is pending timer manager -> scenario service
	action prepareStores() {
		timerMgr.init(hubCtx, queryScenarioService.masterId, qLogger, prepareStoresCompleted);
	}

	boolean allTablePrepareSucceeded;

	action prepareStoresCompleted(boolean success, com.apama.memorystore.Table timersTable) {
		allTablePrepareSucceeded := success; // used by initWindowTable, see below
		// Store preparation listener
		integer reqId := integer.getUnique();
		on __StorePrepared(requestId = reqId) as prepared {
			/** Name of the store */
			queryScenarioService.storeName := prepared.storeName;
			if(prepared.success) then {
				timerMgr.timersTable := timersTable;
				timerMgr.startClusterMemberChangeMonitor();
				scenarioServiceStorePrepared();
			} else {
				qLogger.queryLog("Could not prepare store " + queryScenarioService.storeName + ": " + prepared.reason, "FATAL", false);
				shouldRespawn := false;
				die;
			}
		}

		// Prepare the store
		route __PrepareStore(queryScenarioService.name, reqId);
	}

	action scenarioServiceStarted() {
		// start the failed query handler
		spawn failedQueryHandler();

		// the following instances are created at startup:
		createdAtStartup := true;
		// Check to see if this unparameterized query was previously created and if so recreate with the same instance ID.
		// There should only be a single instance in the table for a non-parameterized query
		try {
			com.apama.memorystore.Iterator it:=queryScenarioService.paramTable.begin();
			if (not it.done()) then {
				// ReCreate the existing instance
				qLogger.queryLog("Recreating non-parameterized query instance", "DEBUG", false);
				queryScenarioService.routeCreate(0, "*", new sequence<string>, it.getKey().toInteger());
			} else {
				// Create a new instance
				queryScenarioService.routeCreate(0, "*", new sequence<string>, 0);
			}
		} catch(com.apama.exceptions.Exception e) {
			// fallback, possibly if no table of parameterizations:
			queryScenarioService.routeCreate(0, "*", new sequence<string>, 0);
		}
		// either way, we create a single instance; mark this as loading until the instance has started (i.e. not start JMS until it has started)
		send __QueryLoaded(queryScenarioService.name) to scenarioServiceCtx;
		send __QueryReady(queryScenarioService.name) to scenarioServiceCtx;
		integer id:=integer.getUnique();
		route __Trigger(id);
		on __Trigger(id) {
			// after we have processed Create events, any further creates are not at startup.
			createdAtStartup := false;
		}
	}

	/** Store is ready to be opened */
	action scenarioServiceStorePrepared() {
		store := (new com.apama.memorystore.Storage).open(queryScenarioService.storeName);

		// Open or create the parameterised store here.
		// Needs to be ready before ScenarioService is (ie before we have create listeners etc)
		// FIXME - Use a single table to store the parameterizations?
		__NullType n := new __NullType;
		string queryName := n.getName().substring(0,-11);
		// Table to store parameter values
		string tableName := "parameterizations_"+queryName+"_"+queryScenarioService.name;

		// Table to store instance ID
		string eqConfigTableName := "eqConfig"; // elastic queries config table
		
		// Prepare the table to hold the event window
		qLogger.queryLog("Preparing table to store parameter values: " + tableName, "DEBUG", false);
		integer id2 := store.prepare(tableName, com.apama.memorystore.Schema.schemaFromAny(new com.apama.queries.__ParamSchema));
		qLogger.queryLog("Preparing table to store parameter IDs: " + eqConfigTableName, "DEBUG", false);
		integer id3 := store.prepare(eqConfigTableName, com.apama.memorystore.Schema.schemaFromAny(new com.apama.queries.__ElasticQueryConfigSchema));

		on com.apama.memorystore.Finished(id=id2) as f2 and
		   com.apama.memorystore.Finished(id=id3) as f3 {
			if f2.success then { 
				// Open the parameterizations table
				queryScenarioService.paramTable := store.open(tableName);
				qLogger.queryLog("Successfully prepared table to store parameter values: " + tableName, "DEBUG", false);
			} else {
				qLogger.queryLog("Asynchronous MemoryStore operation (Prepare Parameterizations) failed: " + f2.toString(), "FATAL", false);
			}

			if f3.success then { 
				queryScenarioService.eqConfigTable := store.open(eqConfigTableName);
				qLogger.queryLog("Successfully prepared table to store parameter IDs: " + eqConfigTableName, "DEBUG", false);
			} else {
				qLogger.queryLog("Asynchronous MemoryStore operation (Prepare eqConfig table) failed: " + f3.toString(), "FATAL", false);
			}
			allTablePrepareSucceeded := allTablePrepareSucceeded and f2.success and f3.success;

			try {
				// Subscribe to the table notifications
				integer notificationId := queryScenarioService.paramTable.subscribeRowChanged();
				queryScenarioService.supportsRowNotifications := true;
			} catch (com.apama.exceptions.Exception e) {
				qLogger.queryLog("MemoryStore driver doesn't support RowChanged notifications.", "INFO", false);
				queryScenarioService.supportsRowNotifications := false;
			}
			
			if (queryScenarioService.supportsRowNotifications) then {
				com.apama.memorystore.RowChanged rc;
				on all com.apama.memorystore.RowChanged(storeName  = queryScenarioService.storeName,
				                                        tableName  = tableName,
				                                        changeType = com.apama.memorystore.RowChanged.INSERT):rc {
					qLogger.queryLog("Received RowChanged::" + rc.getChangeTypeString() + " event: key=" + rc.key 
						+ ": " + rc.oldFieldValues.toString() + " -> " + rc.newFieldValues.toString(), "DEBUG", false);

					com.apama.memorystore.Row r := queryScenarioService.paramTable.get(rc.key);
					string sid := r.getString("scenarioId");
					string s1 := r.getString("parameters");
					sequence<string> seq := sequence<string>.parse(s1);
					
					// (Re)Create the instance - this correlator might have created this instance in which case we 
					// shouldn't do anything here.
					queryScenarioService.routeCreate(0, "*", seq, rc.key.toInteger());
				}
			}

			// start query scenario service
			queryScenarioService.start(setupScenario(), scenarioServiceStarted);
			spawn talkToScenarioService() to scenarioServiceCtx; // Ensure correct communication with scenario service
		}

	}

	string sharedId;

	action initWindowTable(action<> callbackComplete) {
		
		string oldSharedId := sharedId;
		dictionary<string, boolean> allSharedIds_and_hasSourceTime := {sharedId_HelloDBP$HelloEvents$ThingEvent:false};
		sequence<string> allSharedIds_and_hasSourceTime_keys := allSharedIds_and_hasSourceTime.keys();
		allSharedIds_and_hasSourceTime_keys.sort();
		sequence<string> allSharedIds := new sequence<string>;
		sequence<boolean> hasSourceTime := new sequence<boolean>;
		dictionary<string,string> sharedIdToHeartbeatType := {
			sharedId_HelloDBP$HelloEvents$ThingEvent : ""
			};
		string sharedId_key;
		for sharedId_key in allSharedIds_and_hasSourceTime_keys {
			allSharedIds.append(sharedId_key);
			hasSourceTime.append(allSharedIds_and_hasSourceTime[sharedId_key]);
		}

		sharedId := allSharedIds.toString();
		if oldSharedId = sharedId then {
			return;
		}
		string tableName := windowManager_HelloDBP$HelloEvents$ThingEvent.getTableName(allSharedIds);
		com.apama.memorystore.Schema schema := new com.apama.memorystore.Schema;
		string s;
		integer i:=0;
		dictionary<string, string> heartbeatsAdded := {};
		for s in allSharedIds {
			schema.fields.append("contents_"+s);
			schema.types.append("string");
			schema.fields.append("timestamps_"+s);
			schema.types.append("string");
			if(hasSourceTime[i]) then {
				schema.fields.append("srctimes_"+s);
				schema.types.append("string");
			}
			string heartbeat := sharedIdToHeartbeatType[s];
			if(heartbeat != "" and not heartbeatsAdded.hasKey(heartbeat)) then {
				schema.fields.append("heartbeatTime_"+heartbeat);
				schema.types.append("string");
				heartbeatsAdded[heartbeat] := heartbeat;
			}
			i:=i+1;
		}
		if(anyHaveSourceTimestamps) then {
			schema.fields.append("evalTime");
			schema.types.append("float");
		}
		// Prepare the table to hold the event window
		qLogger.instanceLog("Preparing table to store window contents: " + tableName, "DEBUG", false);
		integer id := store.prepare(tableName, schema);
		pendingPreparations.add(id,id);
		on com.apama.memorystore.Finished(id=id) as f {
			allTablePrepareSucceeded := allTablePrepareSucceeded and f.success;
			if f.success then {
				qLogger.instanceLog("Successfully prepared table to store window contents: " + tableName, "DEBUG", false);
			} else {
				qLogger.instanceLog("Asynchronous MemoryStore operation (Prepare window table data) failed: " + f.toString(), "FATAL", false);
			}
			if not allTablePrepareSucceeded then {
				if haveCreateParameterizedCompletedCallback then {
					try {
						// has to go into created state before we can move it into the failed state:
						createParameterizedCompletedCallback();
					} catch(com.apama.exceptions.Exception e) {
						// wil fail to update param table if it is not open, that's fine..
					}
				}
				shouldRespawn := false;
				die;
			}
			prepareFinished(true, id, callbackComplete);
		}
	}




	/** 
	 * Spawned to create a monitor that handles routing scenario service events.
	 */
	action talkToScenarioService() {
		isMasterMonitor := false; // the talkToScenarioService monitor is neither master nor an instance proxy:
		queryScenarioService.talkToScenarioService();
	}	

	/** 
	 * Spawned to create a monitor that handles instance proxies that enter the failed state.
	 */
	action failedQueryHandler() {
		isMasterMonitor := false; // the failedQueryHandler monitor is neither master nor an instance proxy:
		queryScenarioService.failedQueryHandler();
	}	

	/* Supplementary query scenario service actions block */


	/* Callback used to setup query scenario service. */
	action setupScenario() returns dictionary<string, sequence<string> > {
		dictionary<string, sequence<string> > s := new dictionary<string, sequence<string> >;
		// Handle request for Scenario data
		s["inputNames"] := [
		];
		s["inputTypes"] := [
		];
		s["inputDefaults"] := [
		];
		
		return s;
	}

	//End of supplementary query scenario service actions block

	boolean haveCreateParameterizedCompletedCallback;
	action<> createParameterizedCompletedCallback;

	/**
	* Run in the instance proxy on receipt of a request to create a new parameterized query instance. 
	* Sets specified parameter values and instance ID before creating tables for this parameterization,
	* spawning a worker to each context, and initializing a distributor.
	* Note we only request distributors if any parameterizations exist. (though of course at most one of
	* them will be 'live' at any one time -see __DistributionMgr)
	* Exception may be thrown from updateUserParameters and initCommon (to be caught by queryScenarioService) if value 
	* field sizes do not match, is parsing fails or if values used to evaluate expressions result in exceptions.
	*/
	action createParameterizedQueryInstance(sequence<string> parameterValues, string owner, action<> completedCallback) {
		//Set this to false so that any failures after spawning will not interpreted as being from the main monitor
		isMasterMonitor := false;
		isInstanceProxy := true;
		parameterizationOwner := owner;
		qLogger := queryScenarioService.getLogger(); // ensures the instance logger is using the correct Id
		updateUserParameters(parameterValues, true, true, initCommon);

		// Create an action and listener list for the chain of initialisation actions
		// Create a __TerminationMgr for the instance proxy, - in case the instance should terminate
		(new __TerminationMgr).init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
		createParameterizedCompletedCallback := completedCallback;
		haveCreateParameterizedCompletedCallback := true;

		// Set necessary __PendingTimersMgr information
		timerMgr.setInstance(queryScenarioService.instancePxyId);
	}


	/**
	* Callback used to log the a request has been made to delete this parameterized instance.
	* Also ensure that this does not trigger a respawn upon termination.
	*/
	action prepareParameterizedQueryInstanceFinish(boolean logDeath) {	
		if logDeath then {
			if isInstanceProxy then {
				qLogger.instanceLog("Deleting instance", "INFO", false);
			} 
		}
		shouldRespawn := false;
		if isInstanceProxy and (not deleted) and initialised then {
			route __WindowManagerTableUsageChanged(-1, [sharedId_HelloDBP$HelloEvents$ThingEvent]);
		}
		deleted := true;
	}

	/**
	* Called immediately upon receiving query scenario service create or edit event. 
	* Exception will be thrown (to be caught by queryScenarioService) if value field sizes do not 
	* match, is parsing fails or if any of the within/retains expressions, within filters or waits
	* are invalid (syntacically or <= 0) - no try-catch blocks are used as queryScenarioService
	* caller will log error/stacktrace as appropriate.
	*/
	action updateUserParameters(sequence<string> parameterValues, boolean validate, boolean calledByCreate, action<> completeCallback) {
		if validate then {
			queryScenarioService.checkSizeOfParameters(parameterValues, calledByCreate);
		}
		sequence<string> old_sharedIds := [sharedId_HelloDBP$HelloEvents$ThingEvent];

		/** Sets "const" parameters used to reset locally mutable parameter variables, by 
		* parsing each parameter into __user (needed prior to (eg) _within_ initialisation).
		* Henceforth use the canonical form of the parameters (having been parsed).
		* Also handles update of query services' sequence of parameter values.
		*/
		sequence <string> paramValues := [];
		queryScenarioService.updateParameterValues(paramValues);

		if validate then {
			/* Expressions are validated here - exception can be thrown out of each catch-block, which will be caught by queryScenarioService */
			{
				queryScenarioService.validatingExpr("within clause \"\" for input HelloDBP$HelloEvents$ThingEvent");
				float v := __user.__getWithin_HelloDBP$HelloEvents$ThingEvent();
				if v  <=  0.0 then {
					qLogger.requestFailed(calledByCreate, "Invalid within clause \"\" (duration = " + v.toString() + ") for input HelloDBP$HelloEvents$ThingEvent. Cannot be less than or equal to zero.", getParametersString());
					queryScenarioService.failValidation(); 
				}
			} 

			sharedId_HelloDBP$HelloEvents$ThingEvent := __user.__generateSharedId_HelloDBP$HelloEvents$ThingEvent();

			initWindowTable(completeCallback);

			prepareFinished(false, 0, completeCallback); // may well not have any tables to prepare
		} else {
			if not isInstanceProxy then {
				if not calledByCreate then {
					 
					within_HelloDBP$HelloEvents$ThingEvent := __user.__getWithin_HelloDBP$HelloEvents$ThingEvent();  
					initWaits();
					initWithinFilters();
				}

				sharedId_HelloDBP$HelloEvents$ThingEvent := __user.__generateSharedId_HelloDBP$HelloEvents$ThingEvent();

				completeCallback();

				if not calledByCreate then {
					// must terminate the window managers before re-spawning
					windowManager_HelloDBP$HelloEvents$ThingEvent.terminate();
					// for the window manager's benefit, we handle Edit re-spawning and dieing - but we re-spawn from this mThread, and not via the respawn interface
					spawn workerMain(); // skip re-spawning the respawnListener, the old one should still be active.
					shouldRespawn := false;
					die;
				}
			} else {
				completeCallback();
			}

		}
		if isInstanceProxy then {
			route __WindowManagerTableUsageChanged(+1, [sharedId_HelloDBP$HelloEvents$ThingEvent]);
			if initialised then {
				route __WindowManagerTableUsageChanged(-1, old_sharedIds);
			}
		}
	}

	action getParametersString() returns string {
		return queryScenarioService.getParametersString(queryScenarioService.parameterValues, false);
	}


	/** 
	 * Called when any preparation has finished - will call initCommon if all preparations complete
	 */
	action prepareFinished(boolean removeId, integer id, action<> callbackComplete) {
		if removeId then {
			pendingPreparations.remove(id);
		}
		if pendingPreparations.size() = 0 then {
			callbackComplete();
		}
	}


 	/** 
	 * Called from the factory instance, when any tables have been prepared.  Only runs if no preparations left.
	 * Sets up the framework for handling multiple contexts. 
	 */
	action initCommon() {
		initWaits();
		initWithinFilters();
		initialised := true;
		if createdAtStartup then {
			// if this was created during startup, this is
			// either a non-parameterized instance or a
			// parameterized instance on a cluster, we are
			// only ready now:
			send __QueryReady(queryScenarioService.name) to scenarioServiceCtx;
		}

		// Handle changes to the set of worker-contexts  - causes workers to be spawned
		(new __ContextMgr).init( onNewContexts );

		// Initialise each __DistributionMgr  
		dist_HelloDBP$HelloEvents$ThingEvent.init(ThingEvent.getName(), distribute_HelloDBP$HelloEvents$ThingEvent);
		dist___RestartQueryTimer.init(__RestartQueryTimer.getName(), distribute___RestartQueryTimer);
		if haveCreateParameterizedCompletedCallback then {
			createParameterizedCompletedCallback();
		}

	}

	/** Executed before this instance dies. */
  	action ondie() {
  		// Clean-up!
		// If other queries share these event inputs, and if this query is currently
		// in charge of distribution, then a new distributor needs electing
		dist_HelloDBP$HelloEvents$ThingEvent.terminate();
		dist___RestartQueryTimer.terminate();		
		windowManager_HelloDBP$HelloEvents$ThingEvent.terminate();
		if isInstanceProxy and not deleted then {
			route __FailedQueryInstance(queryScenarioService.name, queryScenarioService.instancePxyId, queryScenarioService.parameterValues, parameterizationOwner);
			send __RemoveInstance(queryDefinitionName, queryScenarioService.instancePxyId) to workers.ctxs;
			if initialised then {
				route __WindowManagerTableUsageChanged(-1, [sharedId_HelloDBP$HelloEvents$ThingEvent]);
			}
		}

		if shouldTerminateWorkers then {
			log "Query log: Exception thrown when processing query, terminating all workers" at FATAL;
			send __RemoveInstance(queryDefinitionName, queryScenarioService.instancePxyId) to hubCtx;
		} else if shouldRespawn then { 
			// respawn in case aggregate function threw exception

			route __Respawn(queryScenarioService.instancePxyId); 
		}

		if not shouldTerminateWorkers then {
			// we should not lose any timer state we have, so send all 
			// state about timers to the hub context, which will
			// re-distribute it to the workers (possibly back to us, 
			// but possibly not; whatever it will do the right thing).
			timerMgr.broadcastTimers();
		}

		if isMasterMonitor then {
			// Ref-counting remove to HubContextManager
			(new __HubContextRemove).process(queryDefinitionName , mainCtx);
			// Alert query scenario service that the entire definition is gone - called once per definition.
			// Intentionally called here instead of in onunload to as to have access to the master monitor member values.
			queryScenarioService.unload();
		} else if isInstanceProxy then {
			timerMgr.removeAll();
		}
	}


	action distribute_HelloDBP$HelloEvents$ThingEvent() {
		on all ThingEvent() as e { 			 
			forward_HelloDBP$HelloEvents$ThingEvent(e, nextContext());
		}
	}

	action forward_HelloDBP$HelloEvents$ThingEvent(ThingEvent e, context ctx) {
		
	  	enqueue e to ctx;
	}

	action distribute___RestartQueryTimer() {
		on all __RestartQueryTimer() as e { 			 
			forward___RestartQueryTimer(e, nextContext());
		}
	}

	action forward___RestartQueryTimer(__RestartQueryTimer e, context ctx) {
		
	  	enqueue e to ctx;
	}


	 
	/** Spawned on each new worker instance */
	action newWorker() {
		isMasterMonitor := false;
		isInstanceProxy := false;


		// set up respawn listener for new worker in case of exception thrown by aggregate function
		spawn respawnListener();
		workerMain();
	}

	action workerMain() {
		qryId := integer.getUnique();

		// starts the query scenario service listeners as these are not active afer being spawned - only if we have parameters
		queryScenarioService.startWorkerListeners(context.current().getId() = workers.gc_ctx.getId());




		dictionary<string,string> sharedIdToHeartbeatType := {
			sharedId_HelloDBP$HelloEvents$ThingEvent : ""
		};

		// Set-up a listener for each event inputs
		initWindowListener_HelloDBP$HelloEvents$ThingEvent(sharedIdToHeartbeatType);
	
		// Create a __TerminationMgr for the worker instance, so that the context can be discarded 
		terminationMgr := new __TerminationMgr;
		terminationMgr.init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
		
		// and restart any timers we get notified of:
		on all __RestartQueryTimer(queryName=queryScenarioService.name, instanceId=queryScenarioService.instancePxyId) as restartTimer {
			reEvaluateInputs(restartTimer);
		}
	}


	/** respawn listener set up for every instance */
	action respawnListener() {
		on __Respawn(instanceId = queryScenarioService.instancePxyId) {
			qLogger.instanceLog("Exception thrown from aggregate function(s), respawning worker to current context", "WARN", false);

			shouldRespawn := false;
			spawn newWorker();
			die;
		}

		// Create a __TerminationMgr for the worker instance, so that the context can be discarded 
		terminationMgr := new __TerminationMgr;
		terminationMgr.init(terminateWorker, queryDefinitionName, queryScenarioService.instancePxyId);
	}


	/* All input definition and maintenance code */
	/* ========================================== */	

	/* Initialise individual event input inputs */

	/** Size of the 'within' window of HelloDBP.HelloEvents.ThingEvent */
	float within_HelloDBP$HelloEvents$ThingEvent;

	string sharedId_HelloDBP$HelloEvents$ThingEvent;
	__WindowManager windowManager_HelloDBP$HelloEvents$ThingEvent;

	action handle_HelloDBP$HelloEvents$ThingEvent(action<string, boolean, float> __onEvent, integer retryCount, ThingEvent latest) {
		try {
			latest_HelloDBP$HelloEvents$ThingEvent := latest;
			float srcTime := currentTime;
			__onEvent( __user.__getRowKey_HelloDBP$HelloEvents$ThingEvent( latest), false, srcTime);

		} catch (com.apama.exceptions.Exception __e) {
			if (retryCount > 0) then {
				qLogger.instanceLog("Caught exception (retries="+retryCount.toString()+") "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString()+" - "+__e.getStackTrace().toString(), "ERROR", false);
				terminationMgr.incrOutstandingRetries();
				on wait(1.0) {
					handle_HelloDBP$HelloEvents$ThingEvent(__onEvent, retryCount-1, latest);
					terminationMgr.decrOutstandingRetries();
				}
				return;
			} else {
				qLogger.instanceLog("Terminating query instance. Exception "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString(), "FATAL", false);
				shouldTerminateWorkers := true;
				die;
			}
		}
	}

	ThingEvent latest_HelloDBP$HelloEvents$ThingEvent;

	action initWindowListener_HelloDBP$HelloEvents$ThingEvent(dictionary<string, string> sharedIdToHeartbeatType) {
		__WindowLength length := __WindowLength(-1.0, -1, 0.0, 0.0);
		calculateWithin_HelloDBP$HelloEvents$ThingEvent();
		length.withinDuration := within_HelloDBP$HelloEvents$ThingEvent;

		__user.__handle_HelloDBP$HelloEvents$ThingEvent := handle_HelloDBP$HelloEvents$ThingEvent;
		dictionary<string, boolean> allSharedIds_and_hasSourceTime := {sharedId_HelloDBP$HelloEvents$ThingEvent:false};
		sequence<string> allSharedIds_and_hasSourceTime_keys := allSharedIds_and_hasSourceTime.keys();
		allSharedIds_and_hasSourceTime_keys.sort();
		sequence<string> allSharedIds := new sequence<string>;
		sequence<boolean> hasSourceTime := new sequence<boolean>;
		string sharedId_key;
		for sharedId_key in allSharedIds_and_hasSourceTime_keys {
			allSharedIds.append(sharedId_key);
			hasSourceTime.append(allSharedIds_and_hasSourceTime[sharedId_key]);
		}

		windowManager_HelloDBP$HelloEvents$ThingEvent.init(
			sharedId_HelloDBP$HelloEvents$ThingEvent,
			qryId,
			allSharedIds,
			length,
			__user.__listenFor_HelloDBP$HelloEvents$ThingEvent,
			calculateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent,
			maintainWindow_HelloDBP$HelloEvents$ThingEvent,
			store,
			hubCtx,
			context.current().getId() = workers.gc_ctx.getId(),
			hasSourceTime,
			sharedIdToHeartbeatType
		);

		on all __StoredSnapshot(sharedId = sharedId_HelloDBP$HelloEvents$ThingEvent, managerId = windowManager_HelloDBP$HelloEvents$ThingEvent.managerId) as ss {
			gotSnapshot(ss);
		}		
	}

	/** __WindowManager._calculateInputDefinitiveTime_cb */
	action calculateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(__StoredEventWindow sew, float maxTime, float maxWait) returns float {
		return calculateInputDefinitiveTime(sew.timestamps, sew.timestamps, getCurrentTime(maxTime, false), maxWait, 
				sew.heartbeatTime, new dictionary<string, __DelayedOutOfOrderTime>, "", false);
	}

	action maintainWindow_parse_HelloDBP$HelloEvents$ThingEvent(string str) returns sequence<ThingEvent> {
		return sequence<ThingEvent>.parse(str);
	}


	/** __WindowManager._maintainWindow_cb 
	* definitiveTime is the minimum of the definitive times of the other
	*  query inputs; this input needs to add its latest event (if addLatest
	*  is set), then calculate this input's definitive time, to obtain the
	*  new query definitive time.
	*  Returns the details of latest event to be received by the correlator
	*  (the event being processed here, i.e. latest_HelloDBP$HelloEvents$ThingEvent)
	*/

	action maintainWindow_HelloDBP$HelloEvents$ThingEvent(__StoredEventWindow sew, __WindowLength length, float minWaitTime, float maxTime, float definitiveTime, boolean addLatest, float srcTime, dictionary<string, __StoredEventWindow> windows) returns __LatestEvent {
		sequence<ThingEvent> seq;
		if(sew.seq_of_evts = "") then {
			seq := new sequence<ThingEvent>;
		} else {
			seq := maintainWindow_parse_HelloDBP$HelloEvents$ThingEvent(sew.seq_of_evts);
		}

		float srcTimeUsed := float.NAN;
		float now := getCurrentTime(maxTime, true);

		float prevDefinitiveTime := float.min(definitiveTime, calculateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(sew, now, length.waitTime));

		if(addLatest) then {
			seq.append(latest_HelloDBP$HelloEvents$ThingEvent);
			sew.timestamps.append(now);
			srcTimeUsed := now;		definitiveTime := float.min(definitiveTime, calculateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(sew, now, length.waitTime));

		} else {
			definitiveTime := prevDefinitiveTime;
		}


		// At least one, possibly both, of length.retainDuration and
		// withinDuration are non-negative (i.e. set).  We ignore those
		// that are not set, and if both are set, then we take the union
		// - which is the minimum of the 'oversize' count.
		integer oversize := seq.size();

		// apply retain restriction if set
		if (length.retainDuration >= 0) then {
			oversize := seq.size() - length.retainDuration;	}

		// apply within restriction if set:
		if( length.withinDuration >= 0.0 ) then {
			integer binSearchIndex := -1;
			float windowEnd := (definitiveTime / __TS.GRANULARITY).floor().toFloat() * __TS.GRANULARITY;		windowEnd := windowEnd - length.withinDuration;
			// And exclude things that are right on the edge, even if they've been bumped over by __TS.TIEBREAKER
			windowEnd := windowEnd + (__TS.GRANULARITY - __TS.TIEBREAKER);
			sequence<float> evtTimestamps := sew.timestamps;
			{
				integer oldest := 0;
				integer youngest := evtTimestamps.size();

				while oldest < youngest {
							
					integer midpoint := oldest + ((youngest - oldest) / 2);
					if evtTimestamps[midpoint] <= windowEnd then {
						oldest := midpoint + 1;
					} else {
						youngest := midpoint;	
					}	
				}
				if oldest = youngest and (oldest >= evtTimestamps.size() or  evtTimestamps[oldest] > windowEnd) then {
					binSearchIndex := oldest;
				}
			}
			if binSearchIndex < oversize then {
				oversize := binSearchIndex;
			}
		}

		// this can be negative, but the while loop will only remove
		// anything if it is > 0:
		while(oversize > 0) {
			seq.remove(0);
			sew.timestamps.remove(0);
			oversize := oversize - 1;
		}

		sew.seq_of_evts := seq.toString();
		return __LatestEvent(now, srcTimeUsed);
	}

	/*
	 * Populate the entry in definitiveTimes with the definitive time for this input.
	 * Only count events with (correlator-realm) timestamps up to uptoCorrelatorTime.
	 */
	action populateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(__StoredSnapshot ss, dictionary<string, float> definitiveTimes, boolean isPrevEval, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
		try {
			float uptoCorrelatorTime := ss.previousEvalTimestamp;
			float correlatorEvalTime := ss.previousEvalTimestamp;
			if not isPrevEval then {
				uptoCorrelatorTime := float.INFINITY;
				correlatorEvalTime := getCurrentTime(ss.latestEvent.processedTimestamp, false);
			}

			__StoredEventWindow sew := ss.allEvts[sharedId_HelloDBP$HelloEvents$ThingEvent];
			sequence<float> timestamps := [];
			sequence<float> correlatorTimestamps := [];
			integer i:=0;

			timestamps := sew.timestamps;
			correlatorTimestamps := sew.timestamps;

			// Calculate input definitive time based non-discarded events in window
			float heartbeat;
			if isPrevEval then {
				heartbeat := sew.previousHeartbeatTime;
			} else {
				heartbeat := sew.heartbeatTime;
			}
			definitiveTimes["HelloDBP$HelloEvents$ThingEvent"] := calculateInputDefinitiveTime(timestamps, correlatorTimestamps, correlatorEvalTime, 
	0.0, heartbeat, delayedOutOfOrders,
					"HelloDBP$HelloEvents$ThingEvent", false);
		} catch(com.apama.exceptions.Exception exc) {
			// Probably due to the entry not being there - treat as empty:
			return;
		}
	}

	/** Returns window relevant to this query instance, taking into considerations any retain clauses */
	action getWindow_HelloDBP$HelloEvents$ThingEvent(__StoredSnapshot ss) returns sequence<ThingEvent> {
		try {
			__StoredEventWindow sew := ss.allEvts[sharedId_HelloDBP$HelloEvents$ThingEvent];
			sequence<float> evtTimestamps := sew.timestamps;
			sequence<ThingEvent> contents;
			if sew.seq_of_evts = "" then {
				contents := new sequence<ThingEvent>;
			} else {
				contents := sequence<ThingEvent>.parse(sew.seq_of_evts);
			}

			integer i:=0;
			ThingEvent elem;
			while i < contents.size() {
				elem := contents[i];
				elem.setTimeDeep(evtTimestamps[i]);
				i := i+1;		}

			return contents;
		} catch(com.apama.exceptions.Exception exc) {
			// Probably due to the entry not being there - treat as empty:
			return new sequence<ThingEvent>;
		}
	}

	/** 
	 * Trims the window (sequence of events) so those later than the definitive time are not considered yet 
	 * and take into considerations retain/within clauses.
	 * This MUST be called after getWindow_HelloDBP$HelloEvents$ThingEvent and calculateQueryDefinitiveTime.
	 */
	action scopeWindowToDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(sequence<ThingEvent> contents, float definitiveTime, __StoredSnapshot ss, boolean isSpeculating, float maxDefinitiveTime) {
		if contents.size() = 0 then {
			return;
		}

		// Determines the index BELOW which the window is accurate up to the definitive time (hence numEvtsBeforeDefinitiveTime
		// corresponds to the total number of events that can be used).
		integer numEvtsBeforeDefinitiveTime := binSearch_HelloDBP$HelloEvents$ThingEvent(definitiveTime, contents);
		if numEvtsBeforeDefinitiveTime = 0 then {
			contents.clear();
		} else if numEvtsBeforeDefinitiveTime > 0 then {
			contents.setSize(numEvtsBeforeDefinitiveTime); // truncate any events that are too recent (> dt)
		}

		// if we are speculating, we need to reach as far back as within the current max definitive time (DT will be infinity)
		if isSpeculating then {
			definitiveTime := maxDefinitiveTime;
		}
		// Trim window based on within expression
		// The end of the window has to be aligned across actual timestamps (__TS.GRANULARITY), ignoring __TS.TIEBREAKER
		definitiveTime := (definitiveTime / __TS.GRANULARITY).floor().toFloat() * __TS.GRANULARITY;
		float within_windowEnd := definitiveTime - (within_HelloDBP$HelloEvents$ThingEvent);
		// And exclude things that are right on the edge, even if they've been bumped over by __TS.TIEBREAKER
		within_windowEnd := within_windowEnd + (__TS.GRANULARITY - __TS.TIEBREAKER);
		integer oldestInWindow := binSearch_HelloDBP$HelloEvents$ThingEvent(within_windowEnd, contents);
		if oldestInWindow < 0 then {
			contents.clear();
		} else if oldestInWindow > 0 then {
			integer oversize := oldestInWindow; 
			//TODO Story 30128 - Think about how best to optimize this. 
			while(oversize > 0)  {
				contents.remove(0);
				oversize := oversize - 1;
			}
		}

		if contents.size() > 0 then {
			// Updates statistics
			if ss.sharedId = sharedId_HelloDBP$HelloEvents$ThingEvent then {
				queryScenarioService.reportWindowUpdate("HelloDBP.HelloEvents.ThingEvent", contents.size(), ss.key);
			}
		}
	}

	/* Calculate, validate and save 'within' duration */
	action calculateWithin_HelloDBP$HelloEvents$ThingEvent() {
		 
		within_HelloDBP$HelloEvents$ThingEvent := __user.__getWithin_HelloDBP$HelloEvents$ThingEvent();  

	}
	/* 
	 * Get index of oldest element whose timestamp is more recent than windowEnd, or -1 if contents is 
	 * empty or all elements are older than or equal to windowEnd. Assumes contents is sorted by timestamp from oldest 
	 * to most recent. 
	 */
	action binSearch_HelloDBP$HelloEvents$ThingEvent(float windowEnd, sequence<ThingEvent> contents) returns integer {
		if contents.size() <=0 or contents[contents.size() - 1].getTime() < windowEnd then {
			return -1; 
		}

		integer binSearchIndex := -1;
		{
			integer oldest := 0;
			integer youngest := contents.size();

			while oldest < youngest {
						
				integer midpoint := oldest + ((youngest - oldest) / 2);
				if contents[midpoint].getTime() <= windowEnd then {
					oldest := midpoint + 1;
				} else {
					youngest := midpoint;	
				}	
			}
			if oldest = youngest and (oldest >= contents.size() or  contents[oldest].getTime() > windowEnd) then {
				binSearchIndex := oldest;
			}
		}

		return binSearchIndex;
	}

	/**
	 * This is the form that an element within the window of HelloDBP.HelloEvents.ThingEvent takes in the memory store. It contains the event and its
	 * timestamp, as stringifying and parsing events ignores the event's getTime(), so it has to be kept in a separate field alongside.
	 */
	event __Stored_HelloDBP$HelloEvents$ThingEvent {
		ThingEvent value;
		float timestamp;
	}

	/**
	 * An indexable used to identify uniqueness of input as per with-unique clause
	 */


	 

	/* All pattern definition and evaluation code */
	/* ========================================== */


	/** An index into each of the types.
	 * 
	 * Iterates the window contents across all types on demand.
	 */
	event __WindowsIterator {

		// current iteration state:
		string currentType;	
		integer currentIndex;
		float currentTimestamp;
		/** Contents of each window */
		wildcard sequence<ThingEvent> window_HelloDBP$HelloEvents$ThingEvent;
		/** Index into window contents where this iterator is currently pointing */
		wildcard integer idx_HelloDBP$HelloEvents$ThingEvent; 

		sequence<string> types;
		
		/* Determine if we are evaluating against time or event. If true then return the 
		   current event type as empty but time of event will be available*/
		boolean timeMode;
		
		/* Source timestamp (which is known to be unique) of the latest event received by correlator*/
		float timestampOfLatestReceived;

		/* Window index into at which the current event is located. Only valid if isDone() returns 
			false. Use getType() to determine the type of the element to which the index applies.  */ 
		action getIndex() returns integer {
			return currentIndex;
		}

		action getType() returns string {
			if timeMode then {
				return "";
			}
			return currentType;
		}

		/* Get the stringified form of the event at the current index for the current type */
		action getStringified() returns string {
			 
			/* Switch based on type of input */
			return window_HelloDBP$HelloEvents$ThingEvent[idx_HelloDBP$HelloEvents$ThingEvent].toString();
		}

		action getCurrentTimestamp() returns float {
			return currentTimestamp;
		}

		/* Initialize the iterator. On completion the most recent event in the combined window
			can be retrieved using getIndex() and getType().
			@param endTime - an optional (ignored if NaN) timestamp to append to the end of the windows
		 */
		action init(float endTime) {
			types := ["HelloDBP$HelloEvents$ThingEvent"];
			types.reverse();
			idx_HelloDBP$HelloEvents$ThingEvent := window_HelloDBP$HelloEvents$ThingEvent.size() - 1;
			currentType := types[0];
			currentTimestamp := float.INFINITY;
			idx_HelloDBP$HelloEvents$ThingEvent := idx_HelloDBP$HelloEvents$ThingEvent + 1;
			if(not endTime.isNaN()) then {
				currentTimestamp := endTime;
				currentType := "";
				currentIndex := getIndexForType(types[0]);
			} else {
				next();
			}
		}

		/* Increment the iterator to point to the next event in the combined window. If there are no
			more events then isDone() will return true. Otherwise, use getIndex() and getType() to
			access the event. */
		action next() {
			if(currentType = "") then {
				currentType := types[0];
			}
			 
			/* Switch based on type of input */
			idx_HelloDBP$HelloEvents$ThingEvent := idx_HelloDBP$HelloEvents$ThingEvent - 1;
			string nextPrevType:="";
			float nextPrevTime:=-float.INFINITY;
			integer nextIndex:= -1;

			string type;
			for type in types {
				float evtTime:=getTimestamp(type);

				// assert (t >= currentTimestamp);
				if evtTime > nextPrevTime then {
					nextPrevTime := evtTime;
					nextPrevType := type;
					nextIndex:=getIndexForType(type);
				}
			}
			currentTimestamp := nextPrevTime;
			currentType := nextPrevType;
			currentIndex := nextIndex;
		}

		action isLatestReceived() returns boolean {
			return timestampOfLatestReceived = currentTimestamp;
		}

		action isDone() returns boolean {
			return currentIndex = -1;
		}

		action getTimestamp(string type) returns float {
			 
			/* Switch based on type of input */
			if idx_HelloDBP$HelloEvents$ThingEvent < 0 then {
				return -float.INFINITY;
			} else {
				return window_HelloDBP$HelloEvents$ThingEvent[idx_HelloDBP$HelloEvents$ThingEvent].getTime();
			}
		}

		action getIndexForType(string type) returns integer {
			 
			/* Switch based on type of input */
			return idx_HelloDBP$HelloEvents$ThingEvent;
		}
		
		action setTimeMode(boolean isTimeMode) {
			timeMode := isTimeMode;
		}
	}


	/** Internal event for holding evaluation state for a single find block */
	event __EvaluationState {

		// the user object (contains all user defined expressions/actions)
		__ElasticQueryUserCode __user;

		// Query scenario service event
		__QueryScenarioService queryScenarioService;

		// current index into the merged ordered window:
		__WindowsIterator inputs;

		// the current potential matchsets:
		dictionary<integer, __MatchSet> matchSets;
		
		// Matchsets spawned from the current matchset:
		sequence<integer> addedMatchsets;

		// whether we are matching the 'current' or latest event:
		boolean matchingCurrentEvent;
		
		// how many times we have consumed (coassigned) any events:
		integer haveConsumed;
		
		// the most recent matchset id
		integer mostRecentMatchSet;

		// whether to trigger even if the latest event is not in a matchset
		boolean findAllMatches;


		// duration for within filters (if any)

		//wait durations (if any)

		// The maximum time we really have (not just this evaluation)
		float maxDefinitiveTime;	

		// The timestamp of previously evaluated event
		float previousEventTimestamp;
		/* Effective timestamp of current event. Currently used by within filter. Initially 
		 * equal to the time of current event. Later it is set to the startTime of wait 
		 * interval when wait gets consumed. This ensures that within node evaluates 
		 * properly for event outside of wait interval as wait pattern causes whole 
		 * pattern to be evaluated for event outside wait interval.
		 * */
		float effectiveEventTimestamp;
		// value of the partition key for which evaluation is being done
		string key;
		// denote that pattern is being evaluated on expiry of some future wait
		boolean evalOnWaitExpiry;
		// If a wait evaluate while evalFutureTimer is true then wait is future wait
		boolean evalFutureTimer;
		// start time of the expired future wait
		float expiredWaitStartTime;
		// action to re-evaluate pattern on expirey of future wait
		action<__RestartQueryTimer> reEvaluateInputsAction;

		/** Evaluate a find pattern, calling __ElasticQueryUserCode.__findAction on a match
		  *
		  * Walks the window contents, evaluating the pattern using
		  * each of a set of MatchSets.
		  * Calls the __ElasticQueryUserCode.__findAction if a top level MatchSet exists
		  * which meets all of the where clauses and constraints
		  */
		action patternTrigger(float timeAtEndOfWindow, dictionary<string, float> inputDefinitiveTimes, dictionary<string, float> inputWaitTimes, boolean isSpeculating, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
			///// Initialise state
			inputs.init(timeAtEndOfWindow);
			addInitialMatchSet();

			previousEventTimestamp := float.INFINITY;
			// ids of MatchSets that are final
			dictionary<integer, integer> finalMatchSetIds := new dictionary<integer, integer>;
			// in case of evalOnWaitExpiry, matchingCurrentEvent will get set to true
			// once future wait gets consumed.
			// when speculating matchingCurrentEvent only gets set to true if processing
			// the most recently received event.
			if not evalOnWaitExpiry then {
				matchingCurrentEvent := true;
			}
				
			boolean inputsDone := false;
			// first time pattern will be evaluated against no event to find future waits
			evalFutureTimer := true; 
			///// walk the window
			// for each event (until we have a final matchset, or no matchsets left)
			// we also evaluate pattern for window with no event and time -float.INFINITY
			while (not inputsDone) and (matchSets.size() > 0) {
				if isSpeculating then {
					matchingCurrentEvent := inputs.isLatestReceived();
				}
				if (not isSpeculating) and finalMatchSetIds.hasKey(mostRecentMatchSet) then {
					break;
				}
				__MatchSet matchSet;
				// for each matchset (present at the beginning
				// of processing this event - doesn't evaluate
				// matchsets added during this loop):
				for matchSet in matchSets.values() {
					///// evaluate the pattern twice:
					// once against time only then against event
					processPattern(matchSet, finalMatchSetIds, true);
					processPattern(matchSet, finalMatchSetIds, false);
					if (not isSpeculating) and finalMatchSetIds.hasKey(mostRecentMatchSet) then {
						break;
					}
				}

				evalFutureTimer := false;
				if (inputs.isDone()) then {
					inputsDone := true;
				}

				previousEventTimestamp := inputs.getCurrentTimestamp();
				inputs.next();
				// for the current/ latest event only: if it
				// is not coassigned, we abort the pattern
				// evaluation:
				if matchingCurrentEvent and haveConsumed = 0 and not findAllMatches then {
					return;
				}
				matchingCurrentEvent := false;
			}

			if finalMatchSetIds.size() > 0 then {
				if isSpeculating then {
					// determine when any matches triggered by the event most recently received by the correlator
					// will be less-than or equal to definitive time then re-evaluate at this time if it is currently
					// greater-than definitive time i.e. determine how long to wait for if necessary
					// (although explained using definitive time the actual calculation is in terms of real time)
					__MatchSet ms;
					integer fmsId;
					// The time at which this match occurred/will occur
					float ct := currentTime;
					for fmsId in finalMatchSetIds.keys() {
						ms := matchSets[fmsId];
						if ms.containsCurrent <= 0 then {
							continue;
						}

						float maxTS := ms.mostRecentTime();
						float speculativeWaitExpiryTime := ct;
						string eType;
						for eType in inputDefinitiveTimes.keys() {
							if inputDefinitiveTimes[eType] < maxTS then {
								__DelayedOutOfOrderTime delayed := delayedOutOfOrders.getOrDefault(eType);
								if delayed.maxInputEventTimestamp >= maxTS then {
									speculativeWaitExpiryTime := float.max(speculativeWaitExpiryTime, float.min(maxTS + inputWaitTimes.getOr(eType, 0.0), delayed.correlatorTimeBecomesDefinitive));
								} else {
									speculativeWaitExpiryTime := float.max(speculativeWaitExpiryTime, maxTS + inputWaitTimes.getOr(eType, 0.0));
								}
							}
						}

						if speculativeWaitExpiryTime > ct then {
							// wait for time+epsilon to avoid floating-point rounding errors, specifically the wait being slightly less than it should be
							speculativeWaitExpiryTime := speculativeWaitExpiryTime.nextafter(float.INFINITY);
							reEvaluateInputsAction(__RestartQueryTimer(queryScenarioService.name, queryScenarioService.instancePxyId, key, ct, speculativeWaitExpiryTime, false));
						}
					}

					return;
				}

	 
				integer id:= findMostRecentIn(finalMatchSetIds);
				__MatchSet matchSet := matchSets[id];
				pattern_tidy_node_0(matchSet, EVAL_TIDY);
				///// trigger the user's trigger action
				try{
					// check that there are no pending timers
					if processPendingWaitTimers(matchSet, inputWaitTimes) then {
						queryScenarioService.reportMatch();
						__user.__findAction(matchSet.csnmt_t1, matchSet.csnmt_t2);
					}
				} catch(com.apama.exceptions.Exception __e) {
					 
					__user.__qLogger.instanceLog("Pattern action threw exception"
						+ ": " + __e.getType() + " - " + __e.getMessage(), "WARN", false); 

				}

				return; 

			}
		}

		/** Process pattern against time only or against event*/
		action processPattern(__MatchSet matchSet, dictionary<integer, integer> finalMatchSetIds, boolean withTime) {
			inputs.setTimeMode(withTime);
			
			effectiveEventTimestamp := inputs.getCurrentTimestamp();
			if matchSets.hasKey(matchSet.id) and not finalMatchSetIds.hasKey(matchSet.id) and evaluatePattern(matchSet) then {
				// we have a complete potential matchset.  If it matches the where clause, and any without nodes ...
				if pattern_node0_where(matchSet)  then {
					// .. then we have a final matchset
					finalMatchSetIds.add(matchSet.id, matchSet.id);
				} else {
					discard(matchSet);
				}
			}
		}
		
		/** Process pending wait timers. If there are atleast one pending timer
		* which need to be evaluated in future then it returns false. */
		action processPendingWaitTimers(__MatchSet matchSet, dictionary<string,float> inputWaitTimes) returns boolean {
			// there will not be any pending timers when evaluating against
			// wait expiry because we are evaluating after all required waits are expired
			if evalOnWaitExpiry then {
				return true;
			}
			boolean noPendingTimer := true;
			float waitExpiryTime := -float.INFINITY;
			float waitStartTime := -float.INFINITY;
			string actionName := "";
			if not noPendingTimer then {
				// the waitStartTime is supplied so that wait
				// expression will evaluate to true when
				// evaluation reaches to that event
				reEvaluateInputsAction(__RestartQueryTimer(queryScenarioService.name, queryScenarioService.instancePxyId, key, waitStartTime, waitExpiryTime, true));
			}

			return noPendingTimer;
		}

		/** read current window content and corresponding event timestamps */
		action currentWindowContents(boolean forLogging) returns sequence<string> {
			inputs.init(float.NAN);
			sequence<string> contentsAndTimestamps := new sequence<string>;
			sequence<string> windowDump:=new sequence<string>;
			sequence<string> timestamps:=new sequence<string>;
			while(not inputs.isDone()) {
				windowDump.insert(inputs.getStringified(),0);
				decimal actualTimestamp := (inputs.getCurrentTimestamp().toDecimal() / __TS.GRANULARITY.toDecimal()).round().toDecimal() * __TS.GRANULARITY.toDecimal();
				timestamps.insert(actualTimestamp.toFloat().toString(), 0);
				inputs.next();
			}
			if forLogging then {
				contentsAndTimestamps.append("HelloQuery window contents: ["+(",".join(windowDump))+"]");
				contentsAndTimestamps.append("HelloQuery window timestamps: ["+(",".join(timestamps))+"]");
			} else {
				contentsAndTimestamps.append("["+(",".join(windowDump))+"]");
				contentsAndTimestamps.append("["+(",".join(timestamps))+"]");
			}

			return contentsAndTimestamps;
		}

		constant integer EVAL_MATCHEVENTS := 1;
		constant integer EVAL_EVAL := 2;
		constant integer EVAL_CONDITIONS := 3;
		constant integer EVAL_TIDY := 4;
		constant integer EVAL_PURGE := 5;

		/** Evaluate the entire pattern (including withouts, withins, etc) */
		action evaluatePattern(__MatchSet matchSet) returns boolean {
			addedMatchsets:= new sequence<integer>;
			boolean prev_has_t1 := matchSet.has_t1;
			boolean prev_has_t2 := matchSet.has_t2;
			boolean p := pattern_node_0(matchSet, EVAL_MATCHEVENTS);
			p := pattern_node_0(matchSet, EVAL_EVAL);
			boolean p2 := pattern_node_0(matchSet, EVAL_CONDITIONS);
			p := p and p2;
			integer msId;
			while addedMatchsets.size() > 0 {
				sequence<integer> prevAdded := addedMatchsets;
				addedMatchsets := new sequence<integer>;
				for msId in prevAdded {
					if matchSets.hasKey(msId) then {
						matchSet := matchSets[msId];
						boolean q := pattern_node_0(matchSet, EVAL_EVAL);
						boolean q2 := pattern_node_0(matchSet, EVAL_CONDITIONS);
					}
				}
			}
			return p;
		}

		/* Start of evaluation actions for each node in the pattern */
		action pattern_node0_where(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		// utility methods for managing MatchSets:
		/** Add the initial matchset. */
		action addInitialMatchSet() {
			__MatchSet initial := new __MatchSet;
			initial.init();
			initial.initBlank();
			initial.next := -1;
			initial.prev := -1;
			mostRecentMatchSet := initial.id;
			matchSets.add(initial.id, initial);
		}

		/** Find the most recent matchset that is in the supplied set */
		action findMostRecentIn(dictionary<integer, integer> set) returns integer {
			integer id:= mostRecentMatchSet;
			while (id != -1 and not set.hasKey(id)) {
				id := matchSets[id].next;
			}
			return id;
		}

		/** Add a match set */
		action addMatchSetAfter(__MatchSet prior) returns __MatchSet {
			if(not matchSets.hasKey(prior.id)) then {
				return prior;
			}
			__MatchSet newms := prior.clone();
			newms.init();
			newms.prev := prior.id;
			newms.next := prior.next;
			prior.next := newms.id;
			if(newms.next != -1) then {
				matchSets[newms.next].prev := newms.id;
			}
			matchSets.add(newms.id, newms);
			addedMatchsets.append(newms.id);
			return newms;
		}

		/** discard a match set */
		action discard(__MatchSet matchSet) {
			if matchSets.hasKey(matchSet.id) then {
				// maintain linked list:
				if(matchSet.prev != -1) then {
					if matchSets.hasKey(matchSet.prev) then {
						matchSets[matchSet.prev].next :=  matchSet.next;
					} else {
						__user.__qLogger.instanceLog("Unexpected matchset (prev) " + matchSet.prev.toString() + " in " + self.toString(), "ERROR", false);
					}
				}
				if(matchSet.next != -1) then {
					if matchSets.hasKey(matchSet.next) then {
						matchSets[matchSet.next].prev :=  matchSet.prev;
					} else {
						__user.__qLogger.instanceLog("Unexpected matchset (next) " + matchSet.next.toString() + " in " + self.toString(), "ERROR", false);
					}
				}
				if mostRecentMatchSet = matchSet.id then {
					mostRecentMatchSet := matchSet.next;
				}
				matchSets.remove(matchSet.id);
			} // else may have already been discarded - ignore
		}


		action evalConditions_node_1(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// if we have all of these terms, we can evaluate an and-term of the
			// where clause
			if true and matchSet.has_t2 then {
				if andTerm_3(matchSet.csnmt_t1, matchSet.csnmt_t2) = false then {
					// If the and-term is false, then no matter what the
					// other and-terms evaluate to, the entire where
					// clause must be false. We can discard this matchSet
					// right now.
					return false;
				} // if it is true, then we keep evaluating this matchset.
			}

			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		/* Pattern node for a coassignment from HelloDBP$HelloEvents$ThingEvent to t1 */
		action pattern_node_1(__MatchSet matchSet, integer evalState) returns boolean {
			// if we already have this coassignmnet, we evaluate to true, and don't copy or do anything:
			if matchSet.triggered_t1 > 0 then {
				if (evalState = EVAL_CONDITIONS) and (matchSet.triggered_t1  = EVAL_EVAL) then {
					matchSet.triggered_t1 := EVAL_CONDITIONS;
					boolean matchedWhere := evalConditions_node_1(matchSet);
					if not matchedWhere then {
						discard(matchSet);
					}
					return matchedWhere;
				}
				return true;
			}

			if "HelloDBP$HelloEvents$ThingEvent" = inputs.getType() then {
				if evalState = EVAL_MATCHEVENTS then {
					// coassign the event
					matchSet.csnmt_t1 := inputs.window_HelloDBP$HelloEvents$ThingEvent[inputs.getIndex()];
					matchSet.has_t1 := true;
					matchSet.timestamp_t1 := inputs.getCurrentTimestamp();

					haveConsumed := haveConsumed + 1;
					if matchingCurrentEvent then {
						matchSet.containsCurrent := matchSet.containsCurrent + 1;
					}

					return true;
				}
			}

			if evalState = EVAL_EVAL and matchSet.has_t1 then {
				boolean doCopy := true;
		 // TODO: is this really the right predicate?
				boolean allAndTermsTrue := true;

				if not( true and matchSet.has_t2 and matchSet.triggered_t2 = EVAL_CONDITIONS ) then {
					allAndTermsTrue := false;
				}


				if allAndTermsTrue and matchSet.containsCurrent > 0 then {
					matchSet.triggered_t1 := EVAL_CONDITIONS;
					boolean matchedWhere := evalConditions_node_1(matchSet);
					if not matchedWhere then {
						// optimisation : rather than copy and discard this, just null out this coassignment - similar to the code below for the copy:
						matchSet.has_t1 := false;
						matchSet.triggered_t1 := 0;
						haveConsumed := haveConsumed - 1;

						if matchingCurrentEvent then {
							matchSet.containsCurrent := matchSet.containsCurrent - 1;
							if matchSet.containsCurrent = 0 then {
								discard(matchSet);
							}
						}
					}
					return matchedWhere;
				}
				// create a new match set not including this event.
				// special case: we don't for the 'current' event if the copy would end up with containsCurrent = 0:
				if not matchingCurrentEvent or matchSet.containsCurrent > 1 then {			__MatchSet copy := addMatchSetAfter(matchSet);
					copy.has_t1 := false;
					copy.triggered_t1 := 0;
					if matchingCurrentEvent then {
						copy.containsCurrent := copy.containsCurrent - 1;
					}
				}
				matchSet.triggered_t1 := EVAL_EVAL;
				return true;
			} else {
				return false;
			}
		}

		action pattern_tidy_node_1(__MatchSet matchSet, integer evalState) {
			if(evalState = EVAL_PURGE) {
				matchSet.csnmt_t1 := new ThingEvent;
				matchSet.has_t1 := false;
				matchSet.timestamp_t1 := float.NAN;
			}
		}



		action evalConditions_node_2(__MatchSet matchSet) returns boolean {

			// what positive where clauses can we now evaluate?
			// if we have all of these terms, we can evaluate an and-term of the
			// where clause
			if true and matchSet.has_t1 then {
				if andTerm_3(matchSet.csnmt_t1, matchSet.csnmt_t2) = false then {
					// If the and-term is false, then no matter what the
					// other and-terms evaluate to, the entire where
					// clause must be false. We can discard this matchSet
					// right now.
					return false;
				} // if it is true, then we keep evaluating this matchset.
			}

			// what without where clauses can we now evaluate?

			// do any withouts invalidate this matchset?

			return true;
		}

		/* Pattern node for a coassignment from HelloDBP$HelloEvents$ThingEvent to t2 */
		action pattern_node_2(__MatchSet matchSet, integer evalState) returns boolean {
			// if we already have this coassignmnet, we evaluate to true, and don't copy or do anything:
			if matchSet.triggered_t2 > 0 then {
				if (evalState = EVAL_CONDITIONS) and (matchSet.triggered_t2  = EVAL_EVAL) then {
					matchSet.triggered_t2 := EVAL_CONDITIONS;
					boolean matchedWhere := evalConditions_node_2(matchSet);
					if not matchedWhere then {
						discard(matchSet);
					}
					return matchedWhere;
				}
				return true;
			}

			if "HelloDBP$HelloEvents$ThingEvent" = inputs.getType() then {
				if evalState = EVAL_MATCHEVENTS then {
					// coassign the event
					matchSet.csnmt_t2 := inputs.window_HelloDBP$HelloEvents$ThingEvent[inputs.getIndex()];
					matchSet.has_t2 := true;
					matchSet.timestamp_t2 := inputs.getCurrentTimestamp();

					haveConsumed := haveConsumed + 1;
					if matchingCurrentEvent then {
						matchSet.containsCurrent := matchSet.containsCurrent + 1;
					}

					return true;
				}
			}

			if evalState = EVAL_EVAL and matchSet.has_t2 then {
				boolean doCopy := true;
		 // TODO: is this really the right predicate?
				boolean allAndTermsTrue := true;

				if not( true and matchSet.has_t1 and matchSet.triggered_t1 = EVAL_CONDITIONS ) then {
					allAndTermsTrue := false;
				}


				if allAndTermsTrue and matchSet.containsCurrent > 0 then {
					matchSet.triggered_t2 := EVAL_CONDITIONS;
					boolean matchedWhere := evalConditions_node_2(matchSet);
					if not matchedWhere then {
						// optimisation : rather than copy and discard this, just null out this coassignment - similar to the code below for the copy:
						matchSet.has_t2 := false;
						matchSet.triggered_t2 := 0;
						haveConsumed := haveConsumed - 1;

						if matchingCurrentEvent then {
							matchSet.containsCurrent := matchSet.containsCurrent - 1;
							if matchSet.containsCurrent = 0 then {
								discard(matchSet);
							}
						}
					}
					return matchedWhere;
				}
				// create a new match set not including this event.
				// special case: we don't for the 'current' event if the copy would end up with containsCurrent = 0:
				if not matchingCurrentEvent or matchSet.containsCurrent > 1 then {			__MatchSet copy := addMatchSetAfter(matchSet);
					copy.has_t2 := false;
					copy.triggered_t2 := 0;
					if matchingCurrentEvent then {
						copy.containsCurrent := copy.containsCurrent - 1;
					}
				}
				matchSet.triggered_t2 := EVAL_EVAL;
				return true;
			} else {
				return false;
			}
		}

		action pattern_tidy_node_2(__MatchSet matchSet, integer evalState) {
			if(evalState = EVAL_PURGE) {
				matchSet.csnmt_t2 := new ThingEvent;
				matchSet.has_t2 := false;
				matchSet.timestamp_t2 := float.NAN;
			}
		}


		/* Pattern node for a followed by operator */
		action pattern_node_0(__MatchSet matchSet, integer evalState) returns boolean {
			if (matchSet.fby_node_0_lookingLeft) then {
				/* if fby_node_0_lookingLeft is true, we must
				   have previously evaluated the RHS to true */
				return pattern_node_1(matchSet, evalState);
			} else {
				boolean r := pattern_node_2(matchSet, evalState);
				if(evalState = EVAL_CONDITIONS) then {
					// if right evaluates to true, we should be looking left next time, else right again:
					matchSet.fby_node_0_lookingLeft := r;
				}
				// either way, a single event cannot make us true
				return false;
			}
		}

		action pattern_tidy_node_0(__MatchSet matchSet, integer evalState) {
			pattern_tidy_node_1(matchSet, evalState);
			pattern_tidy_node_2(matchSet, evalState);
		}


		// an 'and-term' fragment of the 'where' clause:
		action andTerm_3(ThingEvent t1, ThingEvent t2) returns boolean {
			try {
				return __user.__andTerm_3( t1, t2);
			} catch(com.apama.exceptions.Exception __e) {
				 
				__user.__qLogger.instanceLog("Match set threw exception from where clause \"(t1.Health.toFloat() - t2.Health.toFloat()) / t1.Health.toFloat() >= 0.5\""
					+ ": " + __e.getType() + " - " + __e.getMessage(), "WARN", false); 
				return false;
			}
		}


	}

	/* End of evaluation actions for each node in the pattern */

	action initWithinFilters() {
	}

	//wait duration
	action initWaits() {
	}
	
	/* Common code */
	/* =========== */
	
	/** Gets the next context for round-robin distribution of input events. */
	action nextContext() returns context {
		if workers.ctxs.size() <= 1 then {
			qLogger.instanceLog("Invalid state: No worker contexts.", "ERROR", false);
			shouldRespawn := false;
			die;
		}
		
		index := (index + 1) % workers.ctxs.size();
		if workers.ctxs[index].getId() = workers.gc_ctx.getId() then  {
			index := (index + 1) % workers.ctxs.size();
		}
		return workers.ctxs[index];
	}
	
	/** 
	* Called if the system is reconfigured.
	* Updates the set of contexts over which to distribute events.
	*/
	action onNewContexts( __WorkerContextSet workers_ ) {
		workers := workers_;
		context ctx;
		for ctx in workers.ctxs {
			spawn newWorker() to ctx;
		}

		queryScenarioService.updateWorkerContexts(workers);
	}
	
	/** Terminates a worker instance */
	action terminateWorker() {
		// Check if we've got any waits outstanding before shutting down.
		shouldRespawn := false;
		die;
	}
	
	/** Re-evaluate patterns
	* timer - details of the time we should re-evaluate at.
	*/
	action reEvaluateInputs(__RestartQueryTimer timer) {
		if not timerMgr.hasTimer(timer) then {
			timerMgr.add(timer);
			log "Added timer: " + timer.toString() at DEBUG;
			if(timer.waitExpiryTime > currentTime) then {
				on wait(timer.waitExpiryTime - currentTime) {
					fireTimer(timer, 10);
				}
			} else {
				fireTimer(timer, 10);
			}
		}
	}

	/** Find new definitive times since our last evaluation.
	* populates definitiveTimes with any source-realm definitive timestamps which were not definitive as of the last evaluation.
	*/
	action findValidNewDefinitiveTimes(sequence<float> definitiveTimes, float previousDefinitiveTime, float definitiveTime, float waitTime, sequence<float> sourceTimes, sequence<float> times) {
		integer i:=0;
		while(i < times.size() and i < sourceTimes.size()) {
			// must be (previous, current] definitive time, and not invalid (discarded due to delay > waitTime)
			if sourceTimes[i] > previousDefinitiveTime and sourceTimes[i] <= definitiveTime and times[i] - sourceTimes[i] <= waitTime then {
				definitiveTimes.append(sourceTimes[i]);
			}
			i := i + 1;
		}
	}


	/** 
	 * Process a stored snapshot for one of the inputs of this query
	 */
	action gotSnapshot(__StoredSnapshot ss) {
		boolean isEvalOnWaitExpiry:= ss.isEvalOnWaitExpiry;
		float expiredWaitStartTime:= ss.expiredWaitStartTime;
		float expiredWaitEndTime := ss.expiredWaitEndTime;

		// Set up input __EvaluationState variables
		__EvaluationState evalState := newEvaluationState(ss);
		dictionary<string, float> inputWaitTimes := new dictionary<string, float>;
		dictionary<string, float> dict := new dictionary<string, float>;

		// no source timestamps => single evaluation always
		if not anyHaveSourceTimestamps then {
			evalWindowOnce(evalState, ss, ss.latestEvent.processedTimestamp, currentTime, isEvalOnWaitExpiry, expiredWaitStartTime, expiredWaitEndTime, false, dict, dict, new dictionary<string, __DelayedOutOfOrderTime>);
		} else {
			inputWaitTimes := {};
			// Calculate previous definitive time, based on previousEvalTimestamp
			dictionary<string, float> previousDefinitiveTimes := new dictionary<string, float>;
			dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders := {};
			populateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(ss, previousDefinitiveTimes, true, delayedOutOfOrders);

			// Calculate current defintive time:
			dictionary<string, float> definitiveTimesDict := new dictionary<string, float>;
			populateInputDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(ss, definitiveTimesDict, false, delayedOutOfOrders);
			float previousDefinitiveTime := calculateQueryDefinitiveTime(previousDefinitiveTimes, "previous");
			float definitiveTime := calculateQueryDefinitiveTime(definitiveTimesDict, "current");

			float beginDefinitiveSearchRange := previousDefinitiveTime;
			float endDefinitiveSearchRange := definitiveTime;
			// determine what new definitive times we have:
			sequence<float> definitiveTimes := []; // populated by calls to findValidNewDefinitiveTimes
			{
				sequence<float> sourceTimes := ss.allEvts[sharedId_HelloDBP$HelloEvents$ThingEvent].timestamps;
				float waitTime:=0.0;
				findValidNewDefinitiveTimes(definitiveTimes, beginDefinitiveSearchRange, endDefinitiveSearchRange, waitTime, sourceTimes, ss.allEvts[sharedId_HelloDBP$HelloEvents$ThingEvent].timestamps);
			}
			definitiveTimes.sort();

			float evalDefinitiveTime;
			for evalDefinitiveTime in definitiveTimes {
				evalWindowOnce(evalState.clone(), ss.clone(), evalDefinitiveTime, definitiveTime, false, float.NAN, float.NAN, false, dict, inputWaitTimes, delayedOutOfOrders);
			}

			if anyHaveSourceTimestamps and not isEvalOnWaitExpiry then {
				// now perform speculative search through window to determine if any timers should be set up
				evalWindowOnce(evalState, ss, float.INFINITY, definitiveTime, false, float.NAN, float.NAN, true, definitiveTimesDict, inputWaitTimes, delayedOutOfOrders);
			}
		}
	}

	/** 
	 * Evaluate the window, up to the point indicated in source time by definitive time
	 */
	action evalWindowOnce(__EvaluationState evalState, __StoredSnapshot ss, float definitiveTime, float maxDefinitiveTime, boolean isEvalOnWaitExpiry, float expiredWaitStartTime, float expiredWaitEndTime, boolean isSpeculating, dictionary<string, float> definitiveTimes, dictionary<string, float> inputWaitTimes, dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders) {
		// Set up the rest of input __EvaluationState variables
		evalState.maxDefinitiveTime := maxDefinitiveTime;
		evalState.evalOnWaitExpiry := isEvalOnWaitExpiry;
		evalState.expiredWaitStartTime := expiredWaitStartTime;
		evalState.findAllMatches := ss.findAllMatches;

		// Trim relevant windows based on the queries definitive time
		scopeWindowToDefinitiveTime_HelloDBP$HelloEvents$ThingEvent(evalState.inputs.window_HelloDBP$HelloEvents$ThingEvent, definitiveTime, ss, isSpeculating, maxDefinitiveTime);
		// set evalState.inputs.timestampOfLatestReceived to the timestamp available to
		// __WindowsIterator which is sew.sourceTimestamp if available, otherwise sew.timestamp
		evalState.inputs.timestampOfLatestReceived := ss.latestEvent.sourceTimestamp;

		// Execute patternTrigger
		// If isSpeculating = true we scan through once to determine any future matchSets and get the max wait value
		evalState.patternTrigger(expiredWaitEndTime, definitiveTimes, inputWaitTimes, isSpeculating, delayedOutOfOrders);
	}


	/**
	 * Actually re-evaluate an expired timer
	 */
	action fireTimer(__RestartQueryTimer timer, integer retryCount) {
		string key := timer.windowKey;
		__StoredSnapshot ss;
		try {
			ss := windowManager_HelloDBP$HelloEvents$ThingEvent.getSnapshot(key, false);
			// correlator timestamp of events can go
			// slightly ahead of correlator time, so
			// processedTimestamp is the max of
			// ss.latestEvent and the timer expiry time:
			ss.latestEvent.processedTimestamp := float.max(ss.latestEvent.processedTimestamp, timer.waitExpiryTime);
			ss.isEvalOnWaitExpiry := true;
			ss.expiredWaitStartTime := timer.waitStartTime;
			ss.expiredWaitEndTime := timer.waitExpiryTime;
		} catch (com.apama.exceptions.Exception __e) {
			if (retryCount > 0) then {
				qLogger.instanceLog("Caught exception (retries="+retryCount.toString()+") "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString()+" - "+__e.getStackTrace().toString(), "ERROR", false);
				terminationMgr.incrOutstandingRetries();
				on wait(1.0) {
					fireTimer(timer, retryCount - 1);
					terminationMgr.decrOutstandingRetries();
				}
				return;
			} else {
				qLogger.instanceLog("Terminating query instance. Exception "+__e.getType()+" - "+__e.getMessage()+" - "+__e.toString(), "FATAL", false);
				shouldTerminateWorkers := true;
				die;
			}
		}
		// We have timers per query instance; just eval locally.
		gotSnapshot(ss);
		timerMgr.remove(timer);
		send __ScheduleTimerRemoval(integer.getUnique(), queryScenarioService.masterId, queryScenarioService.instancePxyId.toString(), timer) to __TimerRemoverChannel.CHANNEL;
	}

	// Set up variables required when instantiating __EvalutationState
	action newEvaluationState(__StoredSnapshot ss) returns __EvaluationState {
		__EvaluationState evalState := new __EvaluationState;
		evalState.key := ss.key;
		evalState.reEvaluateInputsAction := reEvaluateInputs;
	
		evalState.queryScenarioService := queryScenarioService;
		__user.__qLogger := qLogger;
		evalState.__user := __user.clone();
		
		// set the key values:
		sequence<string> keyValues := sequence<string>.parse(ss.key);
		integer i:=0;
		evalState.__user.Id := keyValues[i];
		i := i+1;

		evalState.inputs.window_HelloDBP$HelloEvents$ThingEvent := getWindow_HelloDBP$HelloEvents$ThingEvent(ss);

		shouldRespawn := true;
		return evalState;
	}

	action getCurrentTime(float maxTimestamp, boolean breakTie) returns float {
		 if(currentTime > maxTimestamp) then { 	 
			return currentTime;
		} else if breakTie then {
			return maxTimestamp + __TS.TIEBREAKER;
		} else {
			return maxTimestamp;
		}
	}

	/* 
	 * Calculates the definitive time of the input window corresponding to the 
	 * sourceTimestamps passed in. Calculated as the maximum of:
	 * 	Most recent timestamp or source timestamp
	 * 	Correlator's current time - input wait time
	 */
	action calculateInputDefinitiveTime(sequence<float> definitiveTimestamps, 
			sequence<float> correlatorTimestamps, 
			float evalCurrentTime, float inputWait, 
			float heartbeatTime, 
			dictionary<string, __DelayedOutOfOrderTime> delayedOutOfOrders, 
			string thisInput, 
			boolean outOfOrder) returns float {

		if outOfOrder then {
			return float.max(evalCurrentTime - inputWait, heartbeatTime);
		}

		float dt := -float.INFINITY;
		float maxTimeOutOfOrder := -float.INFINITY;
		float timeWillBecomeDefinitive := -float.INFINITY;
		integer i:=0;
		while(i < definitiveTimestamps.size()) {
			float evtDelayTime := correlatorTimestamps[i] - definitiveTimestamps[i];
			float evtAge := evalCurrentTime - correlatorTimestamps[i];
			if( evtDelayTime <= queryScenarioService.delayLeeway.delayLeeway or 
			     evtAge >= queryScenarioService.delayLeeway.reorderBuffer) then {
				if maxTimeOutOfOrder = -float.INFINITY then {
					dt := float.max(dt, definitiveTimestamps[i]);
				}
			} else {
				maxTimeOutOfOrder := float.max(maxTimeOutOfOrder, definitiveTimestamps[i]);
				timeWillBecomeDefinitive := float.max(timeWillBecomeDefinitive, correlatorTimestamps[i] + queryScenarioService.delayLeeway.reorderBuffer);
			}
			i := i + 1;
		}
		if(maxTimeOutOfOrder != -float.INFINITY and thisInput != "") then {
			delayedOutOfOrders[thisInput] := __DelayedOutOfOrderTime(maxTimeOutOfOrder, timeWillBecomeDefinitive);
		}

		return float.max(float.max(dt, evalCurrentTime - inputWait), heartbeatTime);
	}

	/* 
	 * Calculates the definitive time of the query. Calculated as the minimum of
	 * all the input definitive times.
	 * Definitive time defines the time the query is accurate up to, across all
	 * inputs, taking into account any source times the inputs may have. It is the point
	 * in time for which the query runtime knows it has received all the events it is 
	 * going to receive. Only from this time onwards will patterns match.
	 * This is definied for queries with and without any getSourceTime actions 
	 * implemented but only has special method when at least one is present;
	 */
	action calculateQueryDefinitiveTime(dictionary<string, float> dts, string type) returns float {
		float dt := float.INFINITY;
		string dt_key;
		for dt_key in dts.keys() {
			dt := float.min(dt, dts[dt_key]);
		}

		return dt;
	}
	
	action getMetadataMap() returns dictionary<string, string> {
		return new dictionary<string,string>;
	}
}

// QUERY SOURCE:
// This is a base64-encoded copy of the query source (generated by rel/10.1.0.x@324292) that generated this .mon file
// Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLy8gVGl0bGU6ICAgICAgICAgSGVsbG9RdWVyeQ0KLy8gRGVzY3JpcHRpb246ICAgSGVsbG9RdWVyeSBkZXNjcmlwdGlvbg0KLy8gRGVwZW5kZW5jaWVzOiAgTm9uZQ0KLy8gQXV0aG9yOiAgICAgICAgamFndA0KLy8NCi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCg0KDQoNCnVzaW5nIEhlbGxvREJQLkhlbGxvRXZlbnRzLlRoaW5nRXZlbnQ7DQpxdWVyeSBIZWxsb1F1ZXJ5IHsJDQoJaW5wdXRzICB7DQoJCVRoaW5nRXZlbnQoKSBrZXkgSWQgd2l0aGluIDE1IHNlYzsNCg0KCX0NCg0KCWZpbmQgVGhpbmdFdmVudCBhcyB0MSAtPiBUaGluZ0V2ZW50IGFzIHQyDQoJd2hlcmUgKHQxLkhlYWx0aC50b0Zsb2F0KCkgLSB0Mi5IZWFsdGgudG9GbG9hdCgpKSAvIHQxLkhlYWx0aC50b0Zsb2F0KCkgPj0gMC41ICB7DQoNCgkNCgkJJWN1c3RvbSgidGl0bGUiOiJDdXN0b20gRVBMIEFjdGlvbiAxIiwiZGVzY3JpcHRpb24iOiIiKSB7DQoJCQlzZW5kIEhlbGxvREJQLkhlbGxvRXZlbnRzLlRoaW5nQWxlcnQoIHQxLklkLCAiVGhpbmcgJyIgKyBUaGluZy5nZXRUaGluZ05hbWUodDEuSWQpICsgIicgbWF5IGJlIHVuaGVhbHRoeS4iLCB0MS5FdmVudFRpbWUsICIiLCBuZXcgc2VxdWVuY2U8aW50ZWdlcj4gKSB0byBIZWxsb0RCUC5IZWxsb0V2ZW50cy5UaGluZ0FsZXJ0LkNIQU5ORUw7DQoJCX0NCgl9DQp9DQo=
 0000003c C:\Users\jagt\workspace101\HelloApama\queries\HelloQuery.qry
TIME 0000000f 1522267307.9,12
TIME 0000000f 1522267307.9,20
TIME 0000000e 1522267307.9,6
TIME 0000000e 1522267307.9,7
TIME 0000000e 1522267307.9,8
TIME 0000000e 1522267307.9,9
TIME 0000000f 1522267307.9,10
TIME 0000000f 1522267307.9,11
TIME 0000000f 1522267307.9,13
TIME 0000000f 1522267307.9,14
TIME 0000000f 1522267307.9,15
TIME 0000000f 1522267307.9,16
TIME 0000000f 1522267307.9,17
TIME 0000000e 1522267307.9,1
TIME 0000000f 1522267307.9,19
TIME 0000000e 1522267307.9,2
TIME 0000000e 1522267307.9,5
TIME 0000000e 1522267307.9,3
TIME 0000000c 1522267308,1
TIME 0000000d 1522267308,12
TIME 0000000d 1522267308,13
TIME 0000000c 1522267308,6
TIME 0000000d 1522267308,19
TIME 0000000d 1522267308,14
TIME 0000000c 1522267308,2
TIME 0000000d 1522267308,10
TIME 0000000c 1522267308,4
TIME 0000000c 1522267308,9
TIME 0000000d 1522267308,11
TIME 0000000c 1522267308,7
TIME 0000000c 1522267308,5
TIME 0000000d 1522267308,20
TIME 0000000d 1522267308,17
TIME 0000000c 1522267308,8
TIME 0000000c 1522267308,3
TIME 0000000d 1522267308,16
TIME 0000000e 1522267308.2,4
EVNT 0000003d 7940883334667444254 "",com.apama.queries.AllQueriesInjected()
TIME 0000000e 1522267308.2,1
TIME 0000000f 1522267308.2,20
TIME 0000000f 1522267308.2,18
TIME 0000000f 1522267308.2,19
TIME 0000000f 1522267308.2,12
TIME 0000000f 1522267308.2,13
TIME 0000000e 1522267308.2,6
TIME 0000000f 1522267308.2,14
TIME 0000000e 1522267308.2,2
TIME 0000000f 1522267308.2,10
TIME 0000000e 1522267308.2,9
TIME 0000000f 1522267308.2,11
TIME 0000000f 1522267308.2,15
TIME 0000000e 1522267308.2,7
TIME 0000000e 1522267308.2,5
TIME 0000000f 1522267308.2,17
TIME 0000000e 1522267308.2,8
TIME 0000000e 1522267308.2,3
TIME 0000000f 1522267308.2,16
DISC 0000003c 7940883334667444254:7940896640478355486 from 127.0.0.1:64968
CONN 0000003c 7940883334667444254:7940902773692964894 from 127.0.0.1:64993
DISC 0000003c 7940883334667444254:7940902773692964894 from 127.0.0.1:64993
TIME 0000000f 1522267312.7,10
TIME 0000000f 1522267312.7,11
TIME 0000000f 1522267312.7,12
TIME 0000000e 1522267312.7,9
TIME 0000000f 1522267312.7,13
TIME 0000000f 1522267312.7,15
TIME 0000000f 1522267312.7,14
TIME 0000000f 1522267312.7,16
TIME 0000000f 1522267312.7,17
TIME 0000000e 1522267312.7,7
TIME 0000000e 1522267312.7,5
TIME 0000000e 1522267312.7,8
TIME 0000000e 1522267312.7,6
TIME 0000000e 1522267317.7,4
TIME 0000000e 1522267317.7,6
TIME 0000000e 1522267317.7,7
TIME 0000000e 1522267317.7,8
TIME 0000000e 1522267317.7,9
TIME 0000000f 1522267317.7,10
TIME 0000000f 1522267317.7,11
TIME 0000000f 1522267317.7,12
TIME 0000000f 1522267317.7,13
TIME 0000000f 1522267317.7,14
TIME 0000000f 1522267317.7,15
TIME 0000000f 1522267317.7,16
TIME 0000000f 1522267317.7,17
TIME 0000000f 1522267317.7,18
TIME 0000000e 1522267317.7,5
TIME 0000000e 1522267317.7,2
TIME 0000000f 1522267318.2,20
TIME 0000000f 1522267322.7,10
TIME 0000000f 1522267322.7,11
TIME 0000000f 1522267322.7,12
TIME 0000000e 1522267322.7,9
TIME 0000000f 1522267322.7,13
TIME 0000000f 1522267322.7,15
TIME 0000000f 1522267322.7,14
TIME 0000000f 1522267322.7,16
TIME 0000000f 1522267322.7,17
TIME 0000000e 1522267322.7,7
TIME 0000000e 1522267322.7,5
TIME 0000000e 1522267322.7,8
TIME 0000000e 1522267322.7,6
TIME 0000000e 1522267327.7,4
TIME 0000000e 1522267327.7,6
TIME 0000000e 1522267327.7,7
TIME 0000000e 1522267327.7,8
TIME 0000000e 1522267327.7,9
TIME 0000000f 1522267327.7,10
TIME 0000000f 1522267327.7,11
TIME 0000000f 1522267327.7,12
TIME 0000000f 1522267327.7,13
TIME 0000000f 1522267327.7,14
TIME 0000000f 1522267327.7,15
TIME 0000000f 1522267327.7,16
TIME 0000000f 1522267327.7,17
TIME 0000000f 1522267327.7,18
TIME 0000000e 1522267327.7,5
TIME 0000000f 1522267328.2,20
TIME 0000000f 1522267332.7,10
TIME 0000000f 1522267332.7,11
TIME 0000000f 1522267332.7,12
TIME 0000000e 1522267332.7,9
TIME 0000000f 1522267332.7,13
TIME 0000000f 1522267332.7,15
TIME 0000000f 1522267332.7,14
TIME 0000000f 1522267332.7,16
TIME 0000000f 1522267332.7,17
TIME 0000000e 1522267332.7,7
TIME 0000000e 1522267332.7,5
TIME 0000000e 1522267332.7,8
TIME 0000000e 1522267332.7,6
TIME 0000000e 1522267337.7,4
TIME 0000000e 1522267337.7,6
TIME 0000000e 1522267337.7,7
TIME 0000000e 1522267337.7,8
TIME 0000000e 1522267337.7,9
TIME 0000000f 1522267337.7,10
TIME 0000000f 1522267337.7,11
TIME 0000000f 1522267337.7,12
TIME 0000000f 1522267337.7,13
TIME 0000000f 1522267337.7,14
TIME 0000000f 1522267337.7,15
TIME 0000000f 1522267337.7,16
TIME 0000000f 1522267337.7,17
TIME 0000000f 1522267337.7,18
TIME 0000000e 1522267337.7,5
TIME 0000000c 1522267338,4
TIME 0000000c 1522267338,6
TIME 0000000c 1522267338,7
TIME 0000000d 1522267338,18
TIME 0000000c 1522267338,8
TIME 0000000c 1522267338,9
TIME 0000000d 1522267338,10
TIME 0000000d 1522267338,11
TIME 0000000d 1522267338,12
TIME 0000000d 1522267338,13
TIME 0000000d 1522267338,14
TIME 0000000d 1522267338,15
TIME 0000000d 1522267338,16
TIME 0000000d 1522267338,17
TIME 0000000f 1522267338.2,20
TIME 0000000f 1522267342.7,10
TIME 0000000f 1522267342.7,11
TIME 0000000f 1522267342.7,12
TIME 0000000e 1522267342.7,9
TIME 0000000f 1522267342.7,13
TIME 0000000f 1522267342.7,15
TIME 0000000f 1522267342.7,14
TIME 0000000f 1522267342.7,16
TIME 0000000f 1522267342.7,17
TIME 0000000e 1522267342.7,7
TIME 0000000e 1522267342.7,5
TIME 0000000e 1522267342.7,8
TIME 0000000e 1522267342.7,6
TIME 0000000e 1522267347.7,4
TIME 0000000e 1522267347.7,6
TIME 0000000e 1522267347.7,7
TIME 0000000e 1522267347.7,8
TIME 0000000e 1522267347.7,9
TIME 0000000f 1522267347.7,10
TIME 0000000f 1522267347.7,11
TIME 0000000f 1522267347.7,12
TIME 0000000f 1522267347.7,13
TIME 0000000f 1522267347.7,14
TIME 0000000f 1522267347.7,15
TIME 0000000f 1522267347.7,16
TIME 0000000f 1522267347.7,17
TIME 0000000f 1522267347.7,18
TIME 0000000e 1522267347.7,5
TIME 0000000f 1522267348.2,20
TIME 0000000f 1522267352.7,10
TIME 0000000f 1522267352.7,11
TIME 0000000f 1522267352.7,12
TIME 0000000e 1522267352.7,9
TIME 0000000f 1522267352.7,13
TIME 0000000f 1522267352.7,15
TIME 0000000f 1522267352.7,14
TIME 0000000f 1522267352.7,16
TIME 0000000f 1522267352.7,17
TIME 0000000e 1522267352.7,7
TIME 0000000e 1522267352.7,5
TIME 0000000e 1522267352.7,8
TIME 0000000e 1522267352.7,6
TIME 0000000e 1522267357.7,4
TIME 0000000e 1522267357.7,6
TIME 0000000e 1522267357.7,7
TIME 0000000e 1522267357.7,8
TIME 0000000e 1522267357.7,9
TIME 0000000f 1522267357.7,10
TIME 0000000f 1522267357.7,11
TIME 0000000f 1522267357.7,12
TIME 0000000f 1522267357.7,13
TIME 0000000f 1522267357.7,14
TIME 0000000f 1522267357.7,15
TIME 0000000f 1522267357.7,16
TIME 0000000f 1522267357.7,17
TIME 0000000f 1522267357.7,18
TIME 0000000e 1522267357.7,5
TIME 0000000f 1522267358.2,20
TIME 0000000f 1522267362.7,10
TIME 0000000f 1522267362.7,11
TIME 0000000f 1522267362.7,12
TIME 0000000e 1522267362.7,9
TIME 0000000f 1522267362.7,13
TIME 0000000f 1522267362.7,15
TIME 0000000f 1522267362.7,14
TIME 0000000f 1522267362.7,16
TIME 0000000f 1522267362.7,17
TIME 0000000e 1522267362.7,7
TIME 0000000e 1522267362.7,5
TIME 0000000e 1522267362.7,8
TIME 0000000e 1522267362.7,6
TIME 0000000e 1522267367.7,4
TIME 0000000e 1522267367.7,6
TIME 0000000e 1522267367.7,7
TIME 0000000e 1522267367.7,8
TIME 0000000e 1522267367.7,9
TIME 0000000f 1522267367.7,10
TIME 0000000f 1522267367.7,11
TIME 0000000f 1522267367.7,12
TIME 0000000f 1522267367.7,13
TIME 0000000f 1522267367.7,14
TIME 0000000f 1522267367.7,15
TIME 0000000f 1522267367.7,16
TIME 0000000f 1522267367.7,17
TIME 0000000f 1522267367.7,18
TIME 0000000e 1522267367.7,5
TIME 0000000c 1522267368,4
TIME 0000000c 1522267368,6
TIME 0000000c 1522267368,7
TIME 0000000c 1522267368,8
TIME 0000000c 1522267368,9
TIME 0000000d 1522267368,10
TIME 0000000d 1522267368,11
TIME 0000000d 1522267368,12
TIME 0000000d 1522267368,13
TIME 0000000d 1522267368,18
TIME 0000000d 1522267368,14
TIME 0000000d 1522267368,15
TIME 0000000d 1522267368,16
TIME 0000000d 1522267368,17
TIME 0000000f 1522267368.2,20
DISC 00000036 6538088283673763839:6537525350900211711 from (unknown)
TIME 0000000d 1522267369,12
TIME 0000000c 1522267369,1
TIME 0000000d 1522267369,13
TIME 0000000c 1522267369,6
TIME 0000000d 1522267369,19
TIME 0000000d 1522267369,14
TIME 0000000c 1522267369,2
TIME 0000000d 1522267369,10
TIME 0000000c 1522267369,4
TIME 0000000c 1522267369,9
TIME 0000000d 1522267369,11
TIME 0000000d 1522267369,15
TIME 0000000c 1522267369,7
TIME 0000000c 1522267369,5
TIME 0000000d 1522267369,20
TIME 0000000d 1522267369,17
TIME 0000000d 1522267369,18
TIME 0000000c 1522267369,8
TIME 0000000c 1522267369,3
TIME 0000000d 1522267369,16
